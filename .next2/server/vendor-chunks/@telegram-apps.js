"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@telegram-apps";
exports.ids = ["vendor-chunks/@telegram-apps"];
exports.modules = {

/***/ "(ssr)/./node_modules/@telegram-apps/sdk/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@telegram-apps/sdk/dist/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BackButton: () => (/* binding */ lt),\n/* harmony export */   BasicNavigator: () => (/* binding */ Ft),\n/* harmony export */   BiometryManager: () => (/* binding */ Pt),\n/* harmony export */   BrowserNavigator: () => (/* binding */ Le),\n/* harmony export */   ClosingBehavior: () => (/* binding */ Ct),\n/* harmony export */   CloudStorage: () => (/* binding */ It),\n/* harmony export */   ERR_INVALID_PATH_BASE: () => (/* binding */ Xe),\n/* harmony export */   ERR_INVOKE_CUSTOM_METHOD_RESPONSE: () => (/* binding */ Je),\n/* harmony export */   ERR_METHOD_PARAMETER_UNSUPPORTED: () => (/* binding */ ze),\n/* harmony export */   ERR_METHOD_UNSUPPORTED: () => (/* binding */ je),\n/* harmony export */   ERR_NAVIGATION_HISTORY_EMPTY: () => (/* binding */ Ze),\n/* harmony export */   ERR_NAVIGATION_INDEX_INVALID: () => (/* binding */ Ke),\n/* harmony export */   ERR_NAVIGATION_ITEM_INVALID: () => (/* binding */ Xt),\n/* harmony export */   ERR_PARSE: () => (/* binding */ ce),\n/* harmony export */   ERR_SSR_INIT: () => (/* binding */ es),\n/* harmony export */   ERR_TIMED_OUT: () => (/* binding */ Qe),\n/* harmony export */   ERR_UNEXPECTED_TYPE: () => (/* binding */ Ye),\n/* harmony export */   ERR_UNKNOWN_ENV: () => (/* binding */ Fe),\n/* harmony export */   EventEmitter: () => (/* binding */ R),\n/* harmony export */   HapticFeedback: () => (/* binding */ qt),\n/* harmony export */   InitData: () => (/* binding */ kt),\n/* harmony export */   Invoice: () => (/* binding */ Nt),\n/* harmony export */   MainButton: () => (/* binding */ Vt),\n/* harmony export */   MiniApp: () => (/* binding */ Bt),\n/* harmony export */   Popup: () => (/* binding */ $t),\n/* harmony export */   QRScanner: () => (/* binding */ Wt),\n/* harmony export */   SDKError: () => (/* binding */ V),\n/* harmony export */   SettingsButton: () => (/* binding */ Ut),\n/* harmony export */   SwipeBehavior: () => (/* binding */ Ht),\n/* harmony export */   ThemeParams: () => (/* binding */ Ot),\n/* harmony export */   Utils: () => (/* binding */ Gt),\n/* harmony export */   Viewport: () => (/* binding */ jt),\n/* harmony export */   array: () => (/* binding */ At),\n/* harmony export */   bindMiniAppCSSVars: () => (/* binding */ vs),\n/* harmony export */   bindThemeParamsCSSVars: () => (/* binding */ Es),\n/* harmony export */   bindViewportCSSVars: () => (/* binding */ Ss),\n/* harmony export */   boolean: () => (/* binding */ b),\n/* harmony export */   captureSameReq: () => (/* binding */ ge),\n/* harmony export */   classNames: () => (/* binding */ z),\n/* harmony export */   compareVersions: () => (/* binding */ ot),\n/* harmony export */   createBrowserNavigatorFromLocation: () => (/* binding */ Qt),\n/* harmony export */   createPostEvent: () => (/* binding */ pt),\n/* harmony export */   createSafeURL: () => (/* binding */ q),\n/* harmony export */   date: () => (/* binding */ Ee),\n/* harmony export */   getHash: () => (/* binding */ As),\n/* harmony export */   getPathname: () => (/* binding */ Be),\n/* harmony export */   initBackButton: () => (/* binding */ ns),\n/* harmony export */   initBiometryManager: () => (/* binding */ rs),\n/* harmony export */   initClosingBehavior: () => (/* binding */ is),\n/* harmony export */   initCloudStorage: () => (/* binding */ os),\n/* harmony export */   initHapticFeedback: () => (/* binding */ as),\n/* harmony export */   initInitData: () => (/* binding */ cs),\n/* harmony export */   initInvoice: () => (/* binding */ hs),\n/* harmony export */   initMainButton: () => (/* binding */ us),\n/* harmony export */   initMiniApp: () => (/* binding */ ls),\n/* harmony export */   initNavigator: () => (/* binding */ Is),\n/* harmony export */   initPopup: () => (/* binding */ ds),\n/* harmony export */   initQRScanner: () => (/* binding */ _s),\n/* harmony export */   initSettingsButton: () => (/* binding */ fs),\n/* harmony export */   initSwipeBehavior: () => (/* binding */ gs),\n/* harmony export */   initThemeParams: () => (/* binding */ ws),\n/* harmony export */   initUtils: () => (/* binding */ ms),\n/* harmony export */   initViewport: () => (/* binding */ ys),\n/* harmony export */   initWeb: () => (/* binding */ Ps),\n/* harmony export */   invokeCustomMethod: () => (/* binding */ C),\n/* harmony export */   isColorDark: () => (/* binding */ ye),\n/* harmony export */   isIframe: () => (/* binding */ _e),\n/* harmony export */   isPageReload: () => (/* binding */ ke),\n/* harmony export */   isRGB: () => (/* binding */ Q),\n/* harmony export */   isRGBShort: () => (/* binding */ ht),\n/* harmony export */   isSDKError: () => (/* binding */ zt),\n/* harmony export */   isSDKErrorOfType: () => (/* binding */ Rs),\n/* harmony export */   isSSR: () => (/* binding */ xs),\n/* harmony export */   isTMA: () => (/* binding */ Cs),\n/* harmony export */   json: () => (/* binding */ g),\n/* harmony export */   mergeClassNames: () => (/* binding */ ss),\n/* harmony export */   mockTelegramEnv: () => (/* binding */ Ts),\n/* harmony export */   number: () => (/* binding */ y),\n/* harmony export */   off: () => (/* binding */ B),\n/* harmony export */   on: () => (/* binding */ w),\n/* harmony export */   parseInitData: () => (/* binding */ ps),\n/* harmony export */   parseLaunchParams: () => (/* binding */ X),\n/* harmony export */   parseThemeParams: () => (/* binding */ De),\n/* harmony export */   postEvent: () => (/* binding */ A),\n/* harmony export */   request: () => (/* binding */ d),\n/* harmony export */   requestBiometryInfo: () => (/* binding */ xt),\n/* harmony export */   requestThemeParams: () => (/* binding */ bs),\n/* harmony export */   requestViewport: () => (/* binding */ Me),\n/* harmony export */   retrieveLaunchParams: () => (/* binding */ vt),\n/* harmony export */   rgb: () => (/* binding */ _t),\n/* harmony export */   searchParams: () => (/* binding */ K),\n/* harmony export */   serializeLaunchParams: () => (/* binding */ yt),\n/* harmony export */   serializeThemeParams: () => (/* binding */ Ie),\n/* harmony export */   setCSSVar: () => (/* binding */ m),\n/* harmony export */   setDebug: () => (/* binding */ Kt),\n/* harmony export */   setTargetOrigin: () => (/* binding */ ts),\n/* harmony export */   string: () => (/* binding */ h),\n/* harmony export */   subscribe: () => (/* binding */ He),\n/* harmony export */   supports: () => (/* binding */ v),\n/* harmony export */   targetOrigin: () => (/* binding */ ct),\n/* harmony export */   toRGB: () => (/* binding */ me),\n/* harmony export */   unsubscribe: () => (/* binding */ ae),\n/* harmony export */   urlToPath: () => (/* binding */ N),\n/* harmony export */   withTimeout: () => (/* binding */ be)\n/* harmony export */ });\nvar We = Object.defineProperty;\nvar Ue = (s, e, t) => e in s ? We(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : s[e] = t;\nvar c = (s, e, t) => (Ue(s, typeof e != \"symbol\" ? e + \"\" : e, t), t);\nfunction oe(s, e) {\n  let t;\n  const n = () => {\n    t !== void 0 && e && e(t), t = void 0;\n  };\n  return [() => t === void 0 ? t = s(n) : t, n];\n}\nfunction ae(s) {\n  const e = M(), { count: t } = e;\n  e.unsubscribe(s), t && !e.count && it();\n}\nfunction He(s) {\n  return M().subscribe(s), () => ae(s);\n}\nclass Oe {\n  constructor(e, t = {}) {\n    this.scope = e, this.options = t;\n  }\n  /**\n   * Prints message into a console in case, logger is currently enabled.\n   * @param level - log level.\n   * @param args - arguments.\n   */\n  print(e, ...t) {\n    const n = /* @__PURE__ */ new Date(), r = Intl.DateTimeFormat(\"en-GB\", {\n      hour: \"2-digit\",\n      minute: \"2-digit\",\n      second: \"2-digit\",\n      fractionalSecondDigits: 3,\n      timeZone: \"UTC\"\n    }).format(n), { textColor: i, bgColor: o } = this.options, a = \"font-weight: bold;padding: 0 5px;border-radius:5px\";\n    console[e](\n      `%c${r}%c / %c${this.scope}`,\n      `${a};background-color: lightblue;color:black`,\n      \"\",\n      `${a};${i ? `color:${i};` : \"\"}${o ? `background-color:${o}` : \"\"}`,\n      ...t\n    );\n  }\n  /**\n   * Prints error message into a console.\n   * @param args\n   */\n  error(...e) {\n    this.print(\"error\", ...e);\n  }\n  /**\n   * Prints log message into a console.\n   * @param args\n   */\n  log(...e) {\n    this.print(\"log\", ...e);\n  }\n}\nconst F = new Oe(\"SDK\", {\n  bgColor: \"forestgreen\",\n  textColor: \"white\"\n});\nlet O = !1;\nconst se = ({ name: s, payload: e }) => {\n  F.log(\"Event received:\", e ? { name: s, payload: e } : { name: s });\n};\nfunction Kt(s) {\n  O !== s && (O = s, s ? He(se) : ae(se));\n}\nfunction Ge(...s) {\n  O && F.log(...s);\n}\nclass R {\n  constructor() {\n    c(this, \"listeners\", /* @__PURE__ */ new Map());\n    c(this, \"listenersCount\", 0);\n    c(this, \"subscribeListeners\", []);\n  }\n  /**\n   * Removes all event listeners.\n   */\n  clear() {\n    this.listeners.clear(), this.subscribeListeners = [];\n  }\n  /**\n   * Returns count of bound listeners.\n   */\n  get count() {\n    return this.listenersCount + this.subscribeListeners.length;\n  }\n  emit(e, ...t) {\n    this.subscribeListeners.forEach((r) => r({\n      event: e,\n      args: t\n    })), (this.listeners.get(e) || []).forEach(([r, i]) => {\n      r(...t), i && this.off(e, r);\n    });\n  }\n  /**\n   * Adds new event listener.\n   * @param event - event name.\n   * @param listener - event listener.\n   * @param once - should listener be called only once.\n   * @returns Function to remove bound event listener.\n   */\n  on(e, t, n) {\n    let r = this.listeners.get(e);\n    return r || this.listeners.set(e, r = []), r.push([t, n]), this.listenersCount += 1, () => this.off(e, t);\n  }\n  /**\n   * Removes event listener. In case, specified listener was bound several times, it removes\n   * only a single one.\n   * @param event - event name.\n   * @param listener - event listener.\n   */\n  off(e, t) {\n    const n = this.listeners.get(e) || [];\n    for (let r = 0; r < n.length; r += 1)\n      if (t === n[r][0]) {\n        n.splice(r, 1), this.listenersCount -= 1;\n        return;\n      }\n  }\n  /**\n   * Adds a new event listener for all events.\n   * @param listener - event listener.\n   * @returns Function to remove event listener.\n   */\n  subscribe(e) {\n    return this.subscribeListeners.push(e), () => this.unsubscribe(e);\n  }\n  /**\n   * Removes global event listener. In case, specified listener was bound several times, it removes\n   * only a single one.\n   * @param listener - event listener.\n   */\n  unsubscribe(e) {\n    for (let t = 0; t < this.subscribeListeners.length; t += 1)\n      if (this.subscribeListeners[t] === e) {\n        this.subscribeListeners.splice(t, 1);\n        return;\n      }\n  }\n}\nfunction G(s, e, t) {\n  return window.addEventListener(s, e, t), () => window.removeEventListener(s, e, t);\n}\nfunction J(...s) {\n  let e = !1;\n  const t = s.flat(1);\n  return [\n    (n) => !e && t.push(n),\n    () => {\n      e || (e = !0, t.forEach((n) => n()));\n    },\n    e\n  ];\n}\nclass V extends Error {\n  constructor(e, t, n) {\n    super(t, { cause: n }), this.type = e, Object.setPrototypeOf(this, V.prototype);\n  }\n}\nfunction f(s, e, t) {\n  return new V(s, e, t);\n}\nconst je = \"ERR_METHOD_UNSUPPORTED\", ze = \"ERR_METHOD_PARAMETER_UNSUPPORTED\", Fe = \"ERR_UNKNOWN_ENV\", Je = \"ERR_INVOKE_CUSTOM_METHOD_RESPONSE\", Qe = \"ERR_TIMED_OUT\", Ye = \"ERR_UNEXPECTED_TYPE\", ce = \"ERR_PARSE\", Ze = \"ERR_NAVIGATION_LIST_EMPTY\", Ke = \"ERR_NAVIGATION_CURSOR_INVALID\", Xt = \"ERR_NAVIGATION_ITEM_INVALID\", es = \"ERR_SSR_INIT\", Xe = \"ERR_INVALID_PATH_BASE\";\nfunction E() {\n  return f(Ye, \"Value has unexpected type\");\n}\nclass D {\n  constructor(e, t, n) {\n    this.parser = e, this.isOptional = t, this.type = n;\n  }\n  /**\n   * Attempts to parse passed value\n   * @param value - value to parse.\n   * @throws {SDKError} ERR_PARSE\n   * @see ERR_PARSE\n   */\n  parse(e) {\n    if (!(this.isOptional && e === void 0))\n      try {\n        return this.parser(e);\n      } catch (t) {\n        throw f(\n          ce,\n          `Unable to parse value${this.type ? ` as ${this.type}` : \"\"}`,\n          t\n        );\n      }\n  }\n  optional() {\n    return this.isOptional = !0, this;\n  }\n}\nfunction S(s, e) {\n  return () => new D(s, !1, e);\n}\nconst b = S((s) => {\n  if (typeof s == \"boolean\")\n    return s;\n  const e = String(s);\n  if (e === \"1\" || e === \"true\")\n    return !0;\n  if (e === \"0\" || e === \"false\")\n    return !1;\n  throw E();\n}, \"boolean\");\nfunction pe(s, e) {\n  const t = {};\n  for (const n in s) {\n    const r = s[n];\n    if (!r)\n      continue;\n    let i, o;\n    if (typeof r == \"function\" || \"parse\" in r)\n      i = n, o = typeof r == \"function\" ? r : r.parse.bind(r);\n    else {\n      const { type: a } = r;\n      i = r.from || n, o = typeof a == \"function\" ? a : a.parse.bind(a);\n    }\n    try {\n      const a = o(e(i));\n      a !== void 0 && (t[n] = a);\n    } catch (a) {\n      throw f(ce, `Unable to parse field \"${n}\"`, a);\n    }\n  }\n  return t;\n}\nfunction he(s) {\n  let e = s;\n  if (typeof e == \"string\" && (e = JSON.parse(e)), typeof e != \"object\" || e === null || Array.isArray(e))\n    throw E();\n  return e;\n}\nfunction g(s, e) {\n  return new D((t) => {\n    const n = he(t);\n    return pe(s, (r) => n[r]);\n  }, !1, e);\n}\nconst y = S((s) => {\n  if (typeof s == \"number\")\n    return s;\n  if (typeof s == \"string\") {\n    const e = Number(s);\n    if (!Number.isNaN(e))\n      return e;\n  }\n  throw E();\n}, \"number\"), h = S((s) => {\n  if (typeof s == \"string\" || typeof s == \"number\")\n    return s.toString();\n  throw E();\n}, \"string\");\nfunction ue(s) {\n  return g({\n    eventType: h(),\n    eventData: (e) => e\n  }).parse(s);\n}\nfunction et() {\n  [\"TelegramGameProxy_receiveEvent\", \"TelegramGameProxy\", \"Telegram\"].forEach((s) => {\n    delete window[s];\n  });\n}\nfunction j(s, e) {\n  window.dispatchEvent(new MessageEvent(\"message\", {\n    data: JSON.stringify({ eventType: s, eventData: e }),\n    // We specify window.parent to imitate the case, the parent iframe sent us this event.\n    source: window.parent\n  }));\n}\nfunction tt() {\n  [\n    [\"TelegramGameProxy_receiveEvent\"],\n    // Windows Phone.\n    [\"TelegramGameProxy\", \"receiveEvent\"],\n    // Desktop.\n    [\"Telegram\", \"WebView\", \"receiveEvent\"]\n    // Android and iOS.\n  ].forEach((s) => {\n    let e = window;\n    s.forEach((t, n, r) => {\n      if (n === r.length - 1) {\n        e[t] = j;\n        return;\n      }\n      t in e || (e[t] = {}), e = e[t];\n    });\n  });\n}\nconst st = {\n  clipboard_text_received: g({\n    req_id: h(),\n    data: (s) => s === null ? s : h().optional().parse(s)\n  }),\n  custom_method_invoked: g({\n    req_id: h(),\n    result: (s) => s,\n    error: h().optional()\n  }),\n  popup_closed: {\n    parse(s) {\n      return g({\n        button_id: (e) => e == null ? void 0 : h().parse(e)\n      }).parse(s ?? {});\n    }\n  },\n  viewport_changed: g({\n    height: y(),\n    width: (s) => s == null ? window.innerWidth : y().parse(s),\n    is_state_stable: b(),\n    is_expanded: b()\n  })\n};\nfunction nt() {\n  const s = new R(), e = new R();\n  e.subscribe((n) => {\n    s.emit(\"event\", { name: n.event, payload: n.args[0] });\n  }), tt();\n  const [, t] = J(\n    // Don't forget to remove created handlers.\n    et,\n    // Add \"resize\" event listener to make sure, we always have fresh viewport information.\n    // Desktop version of Telegram is sometimes not sending the viewport_changed\n    // event. For example, when the MainButton is shown. That's why we should\n    // add our own listener to make sure, viewport information is always fresh.\n    // Issue: https://github.com/Telegram-Mini-Apps/telegram-apps/issues/10\n    G(\"resize\", () => {\n      e.emit(\"viewport_changed\", {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        is_state_stable: !0,\n        is_expanded: !0\n      });\n    }),\n    // Add listener, which handles events sent from the Telegram web application and also events\n    // generated by the local emitEvent function.\n    G(\"message\", (n) => {\n      if (n.source !== window.parent)\n        return;\n      let r;\n      try {\n        r = ue(n.data);\n      } catch {\n        return;\n      }\n      const { eventType: i, eventData: o } = r, a = st[i];\n      try {\n        const p = a ? a.parse(o) : o;\n        e.emit(...p ? [i, p] : [i]);\n      } catch (p) {\n        F.error(\n          `An error occurred processing the \"${i}\" event from the Telegram application.\nPlease, file an issue here:\nhttps://github.com/Telegram-Mini-Apps/telegram-apps/issues/new/choose`,\n          r,\n          p\n        );\n      }\n    }),\n    // Clear emitters.\n    () => s.clear(),\n    () => e.clear()\n  );\n  return [{\n    on: e.on.bind(e),\n    off: e.off.bind(e),\n    subscribe(n) {\n      return s.on(\"event\", n);\n    },\n    unsubscribe(n) {\n      s.off(\"event\", n);\n    },\n    get count() {\n      return e.count + s.count;\n    }\n  }, t];\n}\nconst [rt, it] = oe(\n  (s) => {\n    const [e, t] = nt(), n = e.off.bind(e);\n    return e.off = (r, i) => {\n      const { count: o } = e;\n      n(r, i), o && !e.count && s();\n    }, [e, t];\n  },\n  ([, s]) => s()\n);\nfunction M() {\n  return rt()[0];\n}\nfunction B(s, e) {\n  M().off(s, e);\n}\nfunction w(s, e, t) {\n  return M().on(s, e, t);\n}\nfunction k(s) {\n  return typeof s == \"object\" && s !== null && !Array.isArray(s);\n}\nfunction ot(s, e) {\n  const t = s.split(\".\"), n = e.split(\".\"), r = Math.max(t.length, n.length);\n  for (let i = 0; i < r; i += 1) {\n    const o = parseInt(t[i] || \"0\", 10), a = parseInt(n[i] || \"0\", 10);\n    if (o !== a)\n      return o > a ? 1 : -1;\n  }\n  return 0;\n}\nfunction _(s, e) {\n  return ot(s, e) <= 0;\n}\nfunction v(s, e, t) {\n  if (typeof t == \"string\") {\n    if (s === \"web_app_open_link\") {\n      if (e === \"try_instant_view\")\n        return _(\"6.4\", t);\n      if (e === \"try_browser\")\n        return _(\"7.6\", t);\n    }\n    if (s === \"web_app_set_header_color\" && e === \"color\")\n      return _(\"6.9\", t);\n    if (s === \"web_app_close\" && e === \"return_back\")\n      return _(\"7.6\", t);\n  }\n  switch (s) {\n    case \"web_app_open_tg_link\":\n    case \"web_app_open_invoice\":\n    case \"web_app_setup_back_button\":\n    case \"web_app_set_background_color\":\n    case \"web_app_set_header_color\":\n    case \"web_app_trigger_haptic_feedback\":\n      return _(\"6.1\", e);\n    case \"web_app_open_popup\":\n      return _(\"6.2\", e);\n    case \"web_app_close_scan_qr_popup\":\n    case \"web_app_open_scan_qr_popup\":\n    case \"web_app_read_text_from_clipboard\":\n      return _(\"6.4\", e);\n    case \"web_app_switch_inline_query\":\n      return _(\"6.7\", e);\n    case \"web_app_invoke_custom_method\":\n    case \"web_app_request_write_access\":\n    case \"web_app_request_phone\":\n      return _(\"6.9\", e);\n    case \"web_app_setup_settings_button\":\n      return _(\"6.10\", e);\n    case \"web_app_biometry_get_info\":\n    case \"web_app_biometry_open_settings\":\n    case \"web_app_biometry_request_access\":\n    case \"web_app_biometry_request_auth\":\n    case \"web_app_biometry_update_token\":\n      return _(\"7.2\", e);\n    case \"web_app_setup_swipe_behavior\":\n      return _(\"7.7\", e);\n    default:\n      return [\n        \"iframe_ready\",\n        \"iframe_will_reload\",\n        \"web_app_close\",\n        \"web_app_data_send\",\n        \"web_app_expand\",\n        \"web_app_open_link\",\n        \"web_app_ready\",\n        \"web_app_request_theme\",\n        \"web_app_request_viewport\",\n        \"web_app_setup_main_button\",\n        \"web_app_setup_closing_behavior\"\n      ].includes(s);\n  }\n}\nfunction le(s) {\n  return \"external\" in s && k(s.external) && \"notify\" in s.external && typeof s.external.notify == \"function\";\n}\nfunction de(s) {\n  return \"TelegramWebviewProxy\" in s && k(s.TelegramWebviewProxy) && \"postEvent\" in s.TelegramWebviewProxy && typeof s.TelegramWebviewProxy.postEvent == \"function\";\n}\nfunction _e() {\n  try {\n    return window.self !== window.top;\n  } catch {\n    return !0;\n  }\n}\nconst at = \"https://web.telegram.org\";\nlet fe = at;\nfunction ts(s) {\n  fe = s;\n}\nfunction ct() {\n  return fe;\n}\nfunction A(s, e, t) {\n  let n = {}, r;\n  if (!e && !t ? n = {} : e && t ? (n = t, r = e) : e && (\"targetOrigin\" in e ? n = e : r = e), Ge(\"Posting event:\", r ? { event: s, data: r } : { event: s }), _e())\n    return window.parent.postMessage(\n      JSON.stringify({ eventType: s, eventData: r }),\n      n.targetOrigin || ct()\n    );\n  if (le(window)) {\n    window.external.notify(JSON.stringify({ eventType: s, eventData: r }));\n    return;\n  }\n  if (de(window)) {\n    window.TelegramWebviewProxy.postEvent(s, JSON.stringify(r));\n    return;\n  }\n  throw f(\n    Fe,\n    \"Unable to determine current environment and possible way to send event. You are probably trying to use Mini Apps method outside the Telegram application environment.\"\n  );\n}\nfunction pt(s) {\n  return (e, t) => {\n    if (!v(e, s))\n      throw f(je, `Method \"${e}\" is unsupported in Mini Apps version ${s}`);\n    if (k(t) && e === \"web_app_set_header_color\" && \"color\" in t && !v(e, \"color\", s))\n      throw f(\n        ze,\n        `Parameter \"color\" of \"${e}\" method is unsupported in Mini Apps version ${s}`\n      );\n    return A(e, t);\n  };\n}\nfunction ge(s) {\n  return ({ req_id: e }) => e === s;\n}\nfunction we(s) {\n  return f(Qe, `Timeout reached: ${s}ms`);\n}\nfunction be(s, e) {\n  return Promise.race([\n    typeof s == \"function\" ? s() : s,\n    new Promise((t, n) => {\n      setTimeout(() => {\n        n(we(e));\n      }, e);\n    })\n  ]);\n}\nasync function d(s) {\n  let e;\n  const t = new Promise((a) => e = a), { event: n, capture: r, timeout: i } = s, [, o] = J(\n    // We need to iterate over all tracked events, and create their event listeners.\n    (Array.isArray(n) ? n : [n]).map((a) => w(a, (p) => {\n      (!r || (Array.isArray(n) ? r({\n        event: a,\n        payload: p\n      }) : r(p))) && e(p);\n    }))\n  );\n  try {\n    return (s.postEvent || A)(s.method, s.params), await (i ? be(t, i) : t);\n  } finally {\n    o();\n  }\n}\nasync function C(s, e, t, n = {}) {\n  const {\n    result: r,\n    error: i\n  } = await d({\n    ...n,\n    method: \"web_app_invoke_custom_method\",\n    event: \"custom_method_invoked\",\n    params: {\n      method: s,\n      params: e,\n      req_id: t\n    },\n    capture: ge(t)\n  });\n  if (i)\n    throw f(Je, i);\n  return r;\n}\nfunction z(...s) {\n  return s.map((e) => {\n    if (typeof e == \"string\")\n      return e;\n    if (k(e))\n      return z(Object.entries(e).map((t) => t[1] && t[0]));\n    if (Array.isArray(e))\n      return z(...e);\n  }).filter(Boolean).join(\" \");\n}\nfunction ss(...s) {\n  return s.reduce((e, t) => (k(t) && Object.entries(t).forEach(([n, r]) => {\n    const i = z(e[n], r);\n    i.length && (e[n] = i);\n  }), e), {});\n}\nfunction Q(s) {\n  return /^#[\\da-f]{6}$/i.test(s);\n}\nfunction ht(s) {\n  return /^#[\\da-f]{3}$/i.test(s);\n}\nfunction me(s) {\n  const e = s.replace(/\\s/g, \"\").toLowerCase();\n  if (Q(e))\n    return e;\n  if (ht(e)) {\n    let n = \"#\";\n    for (let r = 0; r < 3; r += 1)\n      n += e[1 + r].repeat(2);\n    return n;\n  }\n  const t = e.match(/^rgb\\((\\d{1,3}),(\\d{1,3}),(\\d{1,3})\\)$/) || e.match(/^rgba\\((\\d{1,3}),(\\d{1,3}),(\\d{1,3}),\\d{1,3}\\)$/);\n  if (!t)\n    throw new Error(`Value \"${s}\" does not satisfy any of known RGB formats.`);\n  return t.slice(1).reduce((n, r) => {\n    const i = parseInt(r, 10).toString(16);\n    return n + (i.length === 1 ? \"0\" : \"\") + i;\n  }, \"#\");\n}\nfunction ye(s) {\n  const e = me(s);\n  return Math.sqrt(\n    [0.299, 0.587, 0.114].reduce((t, n, r) => {\n      const i = parseInt(e.slice(1 + r * 2, 1 + (r + 1) * 2), 16);\n      return t + i * i * n;\n    }, 0)\n  ) < 120;\n}\nclass ut {\n  constructor(e) {\n    c(this, \"ee\", new R());\n    /**\n     * Adds new event listener.\n     */\n    c(this, \"on\", this.ee.on.bind(this.ee));\n    /**\n     * Removes event listener.\n     */\n    c(this, \"off\", this.ee.off.bind(this.ee));\n    this.state = e;\n  }\n  /**\n   * Clones current state and returns its copy.\n   */\n  clone() {\n    return { ...this.state };\n  }\n  set(e, t) {\n    Object.entries(typeof e == \"string\" ? { [e]: t } : e).reduce((r, [i, o]) => this.state[i] === o || o === void 0 ? r : (this.state[i] = o, this.ee.emit(`change:${i}`, o), !0), !1) && this.ee.emit(\"change\", this.state);\n  }\n  /**\n   * Returns value by specified key.\n   * @param key - state key.\n   */\n  get(e) {\n    return this.state[e];\n  }\n}\nclass Y {\n  constructor(e) {\n    c(this, \"state\");\n    /**\n     * Gets the state value.\n     */\n    c(this, \"get\");\n    /**\n     * Sets the state value.\n     */\n    c(this, \"set\");\n    /**\n     * Clones the current state.\n     */\n    c(this, \"clone\");\n    this.state = new ut(e), this.set = this.state.set.bind(this.state), this.get = this.state.get.bind(this.state), this.clone = this.state.clone.bind(this.state);\n  }\n}\nfunction ve(s, e) {\n  return (t) => v(e[t], s);\n}\nclass Z extends Y {\n  constructor(t, n, r) {\n    super(t);\n    /**\n     * @returns True, if specified method is supported by the current component.\n     */\n    c(this, \"supports\");\n    this.supports = ve(n, r);\n  }\n}\nclass lt extends Z {\n  constructor(t, n, r) {\n    super({ isVisible: t }, n, {\n      show: \"web_app_setup_back_button\",\n      hide: \"web_app_setup_back_button\"\n    });\n    /**\n     * Adds a new event listener.\n     * @param event - event to listen.\n     * @param listener - listener to add.\n     */\n    c(this, \"on\", (t, n) => t === \"click\" ? w(\"back_button_pressed\", n) : this.state.on(t, n));\n    /**\n     * Removes the event listener.\n     * @param event - event to listen.\n     * @param listener - listener to remove.\n     */\n    c(this, \"off\", (t, n) => t === \"click\" ? B(\"back_button_pressed\", n) : this.state.off(t, n));\n    this.postEvent = r;\n  }\n  set isVisible(t) {\n    this.set(\"isVisible\", t), this.postEvent(\"web_app_setup_back_button\", { is_visible: t });\n  }\n  /**\n   * True if BackButton is currently visible.\n   */\n  get isVisible() {\n    return this.get(\"isVisible\");\n  }\n  /**\n   * Hides the BackButton.\n   */\n  hide() {\n    this.isVisible = !1;\n  }\n  /**\n   * Shows the BackButton.\n   */\n  show() {\n    this.isVisible = !0;\n  }\n}\nconst Ee = S((s) => s instanceof Date ? s : new Date(y().parse(s) * 1e3), \"Date\");\nfunction K(s, e) {\n  return new D((t) => {\n    if (typeof t != \"string\" && !(t instanceof URLSearchParams))\n      throw E();\n    const n = typeof t == \"string\" ? new URLSearchParams(t) : t;\n    return pe(s, (r) => {\n      const i = n.get(r);\n      return i === null ? void 0 : i;\n    });\n  }, !1, e);\n}\nconst dt = g({\n  id: y(),\n  type: h(),\n  title: h(),\n  photoUrl: {\n    type: h().optional(),\n    from: \"photo_url\"\n  },\n  username: h().optional()\n}, \"Chat\").optional(), ne = g({\n  addedToAttachmentMenu: {\n    type: b().optional(),\n    from: \"added_to_attachment_menu\"\n  },\n  allowsWriteToPm: {\n    type: b().optional(),\n    from: \"allows_write_to_pm\"\n  },\n  firstName: {\n    type: h(),\n    from: \"first_name\"\n  },\n  id: y(),\n  isBot: {\n    type: b().optional(),\n    from: \"is_bot\"\n  },\n  isPremium: {\n    type: b().optional(),\n    from: \"is_premium\"\n  },\n  languageCode: {\n    type: h().optional(),\n    from: \"language_code\"\n  },\n  lastName: {\n    type: h().optional(),\n    from: \"last_name\"\n  },\n  photoUrl: {\n    type: h().optional(),\n    from: \"photo_url\"\n  },\n  username: h().optional()\n}, \"User\").optional();\nfunction Se() {\n  return K({\n    authDate: {\n      type: Ee(),\n      from: \"auth_date\"\n    },\n    canSendAfter: {\n      type: y().optional(),\n      from: \"can_send_after\"\n    },\n    chat: dt,\n    chatInstance: {\n      type: h().optional(),\n      from: \"chat_instance\"\n    },\n    chatType: {\n      type: h().optional(),\n      from: \"chat_type\"\n    },\n    hash: h(),\n    queryId: {\n      type: h().optional(),\n      from: \"query_id\"\n    },\n    receiver: ne,\n    startParam: {\n      type: h().optional(),\n      from: \"start_param\"\n    },\n    user: ne\n  }, \"InitData\");\n}\nconst _t = S((s) => me(h().parse(s)), \"rgb\");\nfunction ft(s) {\n  return s.replace(/_[a-z]/g, (e) => e[1].toUpperCase());\n}\nfunction gt(s) {\n  return s.replace(/[A-Z]/g, (e) => `_${e.toLowerCase()}`);\n}\nconst Pe = S(\n  (s) => {\n    const e = _t().optional();\n    return Object.entries(he(s)).reduce((t, [n, r]) => (t[ft(n)] = e.parse(r), t), {});\n  },\n  \"ThemeParams\"\n);\nfunction X(s) {\n  return K({\n    botInline: {\n      type: b().optional(),\n      from: \"tgWebAppBotInline\"\n    },\n    initData: {\n      type: Se().optional(),\n      from: \"tgWebAppData\"\n    },\n    initDataRaw: {\n      type: h().optional(),\n      from: \"tgWebAppData\"\n    },\n    platform: {\n      type: h(),\n      from: \"tgWebAppPlatform\"\n    },\n    showSettings: {\n      type: b().optional(),\n      from: \"tgWebAppShowSettings\"\n    },\n    startParam: {\n      type: h().optional(),\n      from: \"tgWebAppStartParam\"\n    },\n    themeParams: {\n      type: Pe(),\n      from: \"tgWebAppThemeParams\"\n    },\n    version: {\n      type: h(),\n      from: \"tgWebAppVersion\"\n    }\n  }).parse(s);\n}\nfunction xe(s) {\n  return X(\n    s.replace(/^[^?#]*[?#]/, \"\").replace(/[?#]/g, \"&\")\n  );\n}\nfunction wt() {\n  return xe(window.location.href);\n}\nfunction Ce() {\n  return performance.getEntriesByType(\"navigation\")[0];\n}\nfunction bt() {\n  const s = Ce();\n  if (!s)\n    throw new Error(\"Unable to get first navigation entry.\");\n  return xe(s.name);\n}\nfunction Te(s) {\n  return `telegram-apps/${s.replace(/[A-Z]/g, (e) => `-${e.toLowerCase()}`)}`;\n}\nfunction Re(s, e) {\n  sessionStorage.setItem(Te(s), JSON.stringify(e));\n}\nfunction Ae(s) {\n  const e = sessionStorage.getItem(Te(s));\n  try {\n    return e ? JSON.parse(e) : void 0;\n  } catch {\n  }\n}\nfunction mt() {\n  return X(Ae(\"launchParams\") || \"\");\n}\nfunction Ie(s) {\n  return JSON.stringify(\n    Object.fromEntries(\n      Object.entries(s).map(([e, t]) => [gt(e), t])\n    )\n  );\n}\nfunction yt(s) {\n  const {\n    initDataRaw: e,\n    themeParams: t,\n    platform: n,\n    version: r,\n    showSettings: i,\n    startParam: o,\n    botInline: a\n  } = s, p = new URLSearchParams();\n  return p.set(\"tgWebAppPlatform\", n), p.set(\"tgWebAppThemeParams\", Ie(t)), p.set(\"tgWebAppVersion\", r), e && p.set(\"tgWebAppData\", e), o && p.set(\"tgWebAppStartParam\", o), typeof i == \"boolean\" && p.set(\"tgWebAppShowSettings\", i ? \"1\" : \"0\"), typeof a == \"boolean\" && p.set(\"tgWebAppBotInline\", a ? \"1\" : \"0\"), p.toString();\n}\nfunction qe(s) {\n  Re(\"launchParams\", yt(s));\n}\nfunction vt() {\n  const s = [];\n  for (const e of [\n    // Try to retrieve launch parameters from the current location. This method can return\n    // nothing in case, location was changed, and then the page was reloaded.\n    wt,\n    // Then, try using the lower level API - window.performance.\n    bt,\n    // Finally, try to extract launch parameters from the session storage.\n    mt\n  ])\n    try {\n      const t = e();\n      return qe(t), t;\n    } catch (t) {\n      s.push(t instanceof Error ? t.message : JSON.stringify(t));\n    }\n  throw new Error([\n    `Unable to retrieve launch parameters from any known source. Perhaps, you have opened your app outside Telegram?\n`,\n    \"ðŸ“– Refer to docs for more information:\",\n    `https://docs.telegram-mini-apps.com/packages/telegram-apps-sdk/environment\n`,\n    \"Collected errors:\",\n    s.map((e) => `â€” ${e}`)\n  ].join(`\n`));\n}\nfunction ke() {\n  const s = Ce();\n  return !!(s && s.type === \"reload\");\n}\nfunction Et() {\n  let s = 0;\n  return () => (s += 1).toString();\n}\nconst [St] = oe(Et);\nfunction l(s, e) {\n  return () => {\n    const t = vt(), n = {\n      ...t,\n      postEvent: pt(t.version),\n      createRequestId: St()\n    };\n    if (typeof s == \"function\")\n      return s(n);\n    const [r, i, o] = J(), a = e({\n      ...n,\n      // State should only be passed only in case, current page was reloaded. If we don't add\n      // this check, state restoration will work improperly in the web version of Telegram,\n      // when we are always working in the same \"session\" (tab).\n      state: ke() ? Ae(s) : void 0,\n      addCleanup: r\n    }), p = (u) => (o || r(\n      u.on(\"change\", ($e) => {\n        Re(s, $e);\n      })\n    ), u);\n    return [\n      a instanceof Promise ? a.then(p) : p(a),\n      i\n    ];\n  };\n}\nconst ns = l(\"backButton\", ({\n  postEvent: s,\n  version: e,\n  state: t = { isVisible: !1 }\n}) => new lt(t.isVisible, e, s));\nclass P extends Z {\n  constructor() {\n    super(...arguments);\n    /**\n     * Adds a new event listener.\n     */\n    c(this, \"on\", this.state.on.bind(this.state));\n    /**\n     * Removes the event listener.\n     */\n    c(this, \"off\", this.state.off.bind(this.state));\n  }\n}\nfunction Ne(s) {\n  const e = s.available ? s : {\n    available: !1,\n    device_id: \"\",\n    token_saved: !1,\n    access_requested: !1,\n    access_granted: !1,\n    type: \"\"\n  };\n  return {\n    available: !0,\n    type: e.type,\n    deviceId: e.device_id,\n    tokenSaved: e.token_saved,\n    accessRequested: e.access_requested,\n    accessGranted: e.access_granted\n  };\n}\nclass Pt extends P {\n  constructor({ postEvent: t, version: n, ...r }) {\n    super(r, n, {\n      auth: \"web_app_biometry_request_auth\",\n      openSettings: \"web_app_biometry_open_settings\",\n      requestAccess: \"web_app_biometry_request_access\",\n      updateToken: \"web_app_biometry_update_token\"\n    });\n    c(this, \"postEvent\");\n    c(this, \"authPromise\");\n    c(this, \"accessPromise\");\n    this.postEvent = t;\n  }\n  /**\n   * Shows whether biometry is available.\n   */\n  get available() {\n    return this.get(\"available\");\n  }\n  /**\n   * Shows whether permission to use biometrics has been granted.\n   */\n  get accessGranted() {\n    return this.get(\"accessGranted\");\n  }\n  /**\n   * Shows whether if permission to use biometrics has been requested.\n   */\n  get accessRequested() {\n    return this.get(\"accessRequested\");\n  }\n  /**\n   * Authenticates the user using biometrics.\n   * @param options - method options.\n   * @since 7.2\n   * @returns Token from the local secure storage, if authentication was successful.\n   */\n  async authenticate({\n    reason: t,\n    ...n\n  }) {\n    return this.authPromise || (this.authPromise = d({\n      ...n,\n      method: \"web_app_biometry_request_auth\",\n      event: \"biometry_auth_requested\",\n      postEvent: this.postEvent,\n      params: {\n        // TODO: Check if reason is empty works fine.\n        reason: (t || \"\").trim()\n      }\n    }).then(({ token: r }) => r).finally(() => this.authPromise = void 0)), this.authPromise;\n  }\n  /**\n   * A unique device identifier that can be used to match the token to the device.\n   */\n  get deviceId() {\n    return this.get(\"deviceId\");\n  }\n  /**\n   * Opens the biometric access settings for bots. Useful when you need to request biometrics\n   * access to users who haven't granted it yet.\n   *\n   * _Note that this method can be called only in response to user interaction with the Mini App\n   * interface (e.g. a click inside the Mini App or on the main button)_.\n   * @since 7.2\n   */\n  openSettings() {\n    this.postEvent(\"web_app_biometry_open_settings\");\n  }\n  /**\n   * Requests permission to use biometrics.\n   * @since 7.2\n   * @returns Promise with true, if access was granted.\n   */\n  requestAccess({ reason: t, ...n } = {}) {\n    return this.accessPromise || (this.accessPromise = d({\n      ...n,\n      postEvent: this.postEvent,\n      method: \"web_app_biometry_request_access\",\n      event: \"biometry_info_received\",\n      params: { reason: t || \"\" }\n    }).then((r) => {\n      const i = Ne(r);\n      return this.set(i), i.accessGranted;\n    }).finally(() => this.accessPromise = void 0)), this.accessPromise;\n  }\n  /**\n   * The type of biometrics currently available on the device.\n   */\n  get biometryType() {\n    return this.get(\"biometryType\");\n  }\n  /**\n   * Shows whether token was saved previously in the local secure storage.\n   */\n  get tokenSaved() {\n    return this.get(\"tokenSaved\");\n  }\n  /**\n   * Updates the biometric token in a secure storage on the device.\n   * @returns Promise with `true`, if token was updated.\n   */\n  async updateToken({ token: t, ...n } = {}) {\n    return [\"removed\", \"updated\"].includes(\n      (await d({\n        ...n,\n        postEvent: this.postEvent,\n        method: \"web_app_biometry_update_token\",\n        event: \"biometry_token_updated\",\n        params: { token: t || \"\" }\n      })).status\n    );\n  }\n}\nasync function xt(s) {\n  return Ne(\n    await d({\n      ...s || {},\n      method: \"web_app_biometry_get_info\",\n      event: \"biometry_info_received\"\n    })\n  );\n}\nconst rs = l(\n  \"biometryManager\",\n  async ({ postEvent: s, version: e, state: t }) => new Pt({\n    ...t || v(\"web_app_biometry_get_info\", e) ? t || await xt({ timeout: 1e3 }) : {\n      available: !1,\n      accessGranted: !1,\n      accessRequested: !1,\n      tokenSaved: !1,\n      deviceId: \"\"\n    },\n    version: e,\n    postEvent: s\n  })\n);\nclass ee extends Y {\n  constructor() {\n    super(...arguments);\n    /**\n     * Adds a new event listener.\n     */\n    c(this, \"on\", this.state.on.bind(this.state));\n    /**\n     * Removes the event listener.\n     */\n    c(this, \"off\", this.state.off.bind(this.state));\n  }\n}\nclass Ct extends ee {\n  constructor(e, t) {\n    super({ isConfirmationNeeded: e }), this.postEvent = t;\n  }\n  set isConfirmationNeeded(e) {\n    this.set(\"isConfirmationNeeded\", e), this.postEvent(\"web_app_setup_closing_behavior\", { need_confirmation: e });\n  }\n  /**\n   * True, if the confirmation dialog should be shown while the user is trying to close\n   * the Mini App.\n   */\n  get isConfirmationNeeded() {\n    return this.get(\"isConfirmationNeeded\");\n  }\n  /**\n   * Disables the confirmation dialog when closing the Mini App.\n   */\n  disableConfirmation() {\n    this.isConfirmationNeeded = !1;\n  }\n  /**\n   * Enables the confirmation dialog when closing the Mini App.\n   */\n  enableConfirmation() {\n    this.isConfirmationNeeded = !0;\n  }\n}\nconst is = l(\n  \"closingBehavior\",\n  ({\n    postEvent: s,\n    state: e = { isConfirmationNeeded: !1 }\n  }) => new Ct(e.isConfirmationNeeded, s)\n);\nclass te {\n  constructor(e, t) {\n    /**\n     * @returns True, if specified method is supported by the current component.\n     */\n    c(this, \"supports\");\n    this.supports = ve(e, t);\n  }\n}\nfunction Tt(s) {\n  if (Array.isArray(s))\n    return s;\n  if (typeof s == \"string\")\n    try {\n      const e = JSON.parse(s);\n      if (Array.isArray(e))\n        return e;\n    } catch {\n    }\n  throw E();\n}\nclass Rt extends D {\n  constructor(t, n, r) {\n    super(Tt, n, r);\n    c(this, \"itemParser\");\n    this.itemParser = typeof t == \"function\" ? t : t.parse.bind(t);\n  }\n  /**\n   * Attempts to parse passed value\n   * @param value - value to parse.\n   * @throws {SDKError} ERR_PARSE\n   * @see ERR_PARSE\n   */\n  parse(t) {\n    const n = super.parse(t);\n    return n === void 0 ? n : n.map(this.itemParser);\n  }\n  of(t) {\n    return this.itemParser = typeof t == \"function\" ? t : t.parse.bind(t), this;\n  }\n}\nfunction At(s) {\n  return new Rt((e) => e, !1, s);\n}\nfunction re(s, e) {\n  return Object.fromEntries(s.map((t) => [t, e]));\n}\nclass It extends te {\n  constructor(e, t, n) {\n    super(e, {\n      delete: \"web_app_invoke_custom_method\",\n      get: \"web_app_invoke_custom_method\",\n      getKeys: \"web_app_invoke_custom_method\",\n      set: \"web_app_invoke_custom_method\"\n    }), this.createRequestId = t, this.postEvent = n;\n  }\n  /**\n   * Deletes specified key or keys from the cloud storage.\n   * @param keyOrKeys - key or keys to delete.\n   * @param options - request execution options.\n   */\n  async delete(e, t = {}) {\n    const n = Array.isArray(e) ? e : [e];\n    n.length && await C(\n      \"deleteStorageValues\",\n      { keys: n },\n      this.createRequestId(),\n      { ...t, postEvent: this.postEvent }\n    );\n  }\n  /**\n   * Returns list of all keys presented in the cloud storage.\n   * @param options - request execution options.\n   */\n  async getKeys(e = {}) {\n    return At().of(h()).parse(\n      await C(\n        \"getStorageKeys\",\n        {},\n        this.createRequestId(),\n        { ...e, postEvent: this.postEvent }\n      )\n    );\n  }\n  async get(e, t = {}) {\n    const n = Array.isArray(e) ? e : [e];\n    if (!n.length)\n      return re(n, \"\");\n    const r = await C(\n      \"getStorageValues\",\n      { keys: n },\n      this.createRequestId(),\n      { ...t, postEvent: this.postEvent }\n    ), i = g(re(n, h()), \"CloudStorageData\").parse(r);\n    return Array.isArray(e) ? i : i[e];\n  }\n  /**\n   * Saves specified value by key.\n   * @param key - storage key.\n   * @param value - storage value.\n   * @param options - request execution options.\n   */\n  async set(e, t, n = {}) {\n    await C(\n      \"saveStorageValue\",\n      { key: e, value: t },\n      this.createRequestId(),\n      { ...n, postEvent: this.postEvent }\n    );\n  }\n}\nconst os = l(\n  ({ createRequestId: s, postEvent: e, version: t }) => new It(t, s, e)\n);\nclass qt extends te {\n  constructor(e, t) {\n    super(e, {\n      impactOccurred: \"web_app_trigger_haptic_feedback\",\n      notificationOccurred: \"web_app_trigger_haptic_feedback\",\n      selectionChanged: \"web_app_trigger_haptic_feedback\"\n    }), this.postEvent = t;\n  }\n  /**\n   * A method tells that an impact occurred. The Telegram app may play the\n   * appropriate haptics based on style value passed.\n   * @param style - impact style.\n   */\n  impactOccurred(e) {\n    this.postEvent(\"web_app_trigger_haptic_feedback\", {\n      type: \"impact\",\n      impact_style: e\n    });\n  }\n  /**\n   * A method tells that a task or action has succeeded, failed, or produced\n   * a warning. The Telegram app may play the appropriate haptics based on\n   * type value passed.\n   * @param type - notification type.\n   */\n  notificationOccurred(e) {\n    this.postEvent(\"web_app_trigger_haptic_feedback\", {\n      type: \"notification\",\n      notification_type: e\n    });\n  }\n  /**\n   * A method tells that the user has changed a selection. The Telegram app\n   * may play the appropriate haptics.\n   *\n   * Do not use this feedback when the user makes or confirms a selection;\n   * use it only when the selection changes.\n   */\n  selectionChanged() {\n    this.postEvent(\"web_app_trigger_haptic_feedback\", { type: \"selection_change\" });\n  }\n}\nconst as = l(\n  ({ version: s, postEvent: e }) => new qt(s, e)\n);\nclass kt {\n  constructor(e) {\n    this.initData = e;\n  }\n  /**\n   * @see InitDataParsed.authDate\n   */\n  get authDate() {\n    return this.initData.authDate;\n  }\n  /**\n   * @see InitDataParsed.canSendAfter\n   */\n  get canSendAfter() {\n    return this.initData.canSendAfter;\n  }\n  /**\n   * Date after which it is allowed to call\n   * the [answerWebAppQuery](https://core.telegram.org/bots/api#answerwebappquery) method.\n   */\n  get canSendAfterDate() {\n    const { canSendAfter: e } = this;\n    return e ? new Date(this.authDate.getTime() + e * 1e3) : void 0;\n  }\n  /**\n   * @see InitDataParsed.chat\n   */\n  get chat() {\n    return this.initData.chat;\n  }\n  /**\n   * @see InitDataParsed.chatType\n   */\n  get chatType() {\n    return this.initData.chatType;\n  }\n  /**\n   * @see InitDataParsed.chatInstance\n   */\n  get chatInstance() {\n    return this.initData.chatInstance;\n  }\n  /**\n   * @see InitDataParsed.hash\n   */\n  get hash() {\n    return this.initData.hash;\n  }\n  /**\n   * @see InitDataParsed.queryId\n   */\n  get queryId() {\n    return this.initData.queryId;\n  }\n  /**\n   * @see InitDataParsed.receiver\n   */\n  get receiver() {\n    return this.initData.receiver;\n  }\n  /**\n   * @see InitDataParsed.startParam\n   */\n  get startParam() {\n    return this.initData.startParam;\n  }\n  /**\n   * @see InitDataParsed.user\n   */\n  get user() {\n    return this.initData.user;\n  }\n}\nconst cs = l(\n  ({ initData: s }) => s ? new kt(s) : void 0\n);\nfunction ps(s) {\n  return Se().parse(s);\n}\nclass Nt extends P {\n  constructor(e, t, n) {\n    super({ isOpened: e }, t, { open: \"web_app_open_invoice\" }), this.postEvent = n;\n  }\n  set isOpened(e) {\n    this.set(\"isOpened\", e);\n  }\n  /**\n   * True if invoice is currently opened.\n   */\n  get isOpened() {\n    return this.get(\"isOpened\");\n  }\n  async open(e, t) {\n    if (this.isOpened)\n      throw new Error(\"Invoice is already opened\");\n    let n;\n    if (!t)\n      n = e;\n    else {\n      const { hostname: r, pathname: i } = new URL(e, window.location.href);\n      if (r !== \"t.me\")\n        throw new Error(`Incorrect hostname: ${r}`);\n      const o = i.match(/^\\/(\\$|invoice\\/)([A-Za-z0-9\\-_=]+)$/);\n      if (!o)\n        throw new Error('Link pathname has incorrect format. Expected to receive \"/invoice/{slug}\" or \"/${slug}\"');\n      [, , n] = o;\n    }\n    this.isOpened = !0;\n    try {\n      return (await d({\n        method: \"web_app_open_invoice\",\n        event: \"invoice_closed\",\n        params: { slug: n },\n        postEvent: this.postEvent,\n        capture(i) {\n          return n === i.slug;\n        }\n      })).status;\n    } finally {\n      this.isOpened = !1;\n    }\n  }\n}\nconst hs = l(\n  ({ version: s, postEvent: e }) => new Nt(!1, s, e)\n);\nclass Vt extends Y {\n  constructor({ postEvent: t, ...n }) {\n    super(n);\n    c(this, \"postEvent\");\n    /**\n     * Adds a new event listener.\n     * @param event - event to listen.\n     * @param listener - listener to add.\n     */\n    c(this, \"on\", (t, n) => t === \"click\" ? w(\"main_button_pressed\", n) : this.state.on(t, n));\n    /**\n     * Removes the event listener.\n     * @param event - event to listen.\n     * @param listener - listener to remove.\n     */\n    c(this, \"off\", (t, n) => t === \"click\" ? B(\"main_button_pressed\", n) : this.state.off(t, n));\n    this.postEvent = t;\n  }\n  /**\n   * The MainButton background color.\n   */\n  get bgColor() {\n    return this.get(\"bgColor\");\n  }\n  /**\n   * Sends current local state to the Telegram application.\n   */\n  commit() {\n    this.text !== \"\" && this.postEvent(\"web_app_setup_main_button\", {\n      is_visible: this.isVisible,\n      is_active: this.isEnabled,\n      is_progress_visible: this.isLoaderVisible,\n      text: this.text,\n      color: this.bgColor,\n      text_color: this.textColor\n    });\n  }\n  /**\n   * Disables the MainButton.\n   * @see Does not work on Android: https://github.com/Telegram-Mini-Apps/issues/issues/1\n   */\n  disable() {\n    return this.isEnabled = !1, this;\n  }\n  /**\n   * Enables the MainButton.\n   */\n  enable() {\n    return this.isEnabled = !0, this;\n  }\n  /**\n   * Hides the MainButton.\n   */\n  hide() {\n    return this.isVisible = !1, this;\n  }\n  /**\n   * Hides the MainButton loading indicator.\n   */\n  hideLoader() {\n    return this.isLoaderVisible = !1, this;\n  }\n  set isEnabled(t) {\n    this.setParams({ isEnabled: t });\n  }\n  /**\n   * True if the MainButton is enabled.\n   */\n  get isEnabled() {\n    return this.get(\"isEnabled\");\n  }\n  set isLoaderVisible(t) {\n    this.setParams({ isLoaderVisible: t });\n  }\n  /**\n   * True if the MainButton loader is visible.\n   */\n  get isLoaderVisible() {\n    return this.get(\"isLoaderVisible\");\n  }\n  set isVisible(t) {\n    this.setParams({ isVisible: t });\n  }\n  /**\n   * True if the MainButton is visible.\n   */\n  get isVisible() {\n    return this.get(\"isVisible\");\n  }\n  /**\n   * Shows the MainButton.\n   *\n   * Note that opening the Mini App from the attachment menu hides the main button until the\n   * user interacts with the Mini App interface.\n   */\n  show() {\n    return this.isVisible = !0, this;\n  }\n  /**\n   * Shows a loading indicator on the Main Button.\n   */\n  showLoader() {\n    return this.isLoaderVisible = !0, this;\n  }\n  /**\n   * Sets a new MainButton text. Minimal length for the text is 1 symbol, and maximum is 64 symbols.\n   * @param text - a new text.\n   */\n  setText(t) {\n    return this.setParams({ text: t });\n  }\n  /**\n   * Sets a new Main Button text color.\n   * @param textColor - new text color.\n   */\n  setTextColor(t) {\n    return this.setParams({ textColor: t });\n  }\n  /**\n   * Updates current Main Button color.\n   * @param bgColor - color to set.\n   */\n  setBgColor(t) {\n    return this.setParams({ bgColor: t });\n  }\n  /**\n   * Allows setting multiple Main Button parameters.\n   * @param params - Main Button parameters.\n   */\n  setParams(t) {\n    return this.set(t), this.commit(), this;\n  }\n  /**\n   * The MainButton text.\n   */\n  get text() {\n    return this.get(\"text\");\n  }\n  /**\n   * The MainButton text color.\n   */\n  get textColor() {\n    return this.get(\"textColor\");\n  }\n}\nconst us = l(\n  \"mainButton\",\n  ({\n    postEvent: s,\n    themeParams: e,\n    state: t = {\n      isVisible: !1,\n      isEnabled: !1,\n      text: \"\",\n      isLoaderVisible: !1,\n      textColor: e.buttonTextColor || \"#ffffff\",\n      bgColor: e.buttonColor || \"#000000\"\n    }\n  }) => new Vt({ ...t, postEvent: s })\n);\nfunction Dt() {\n  return K({\n    contact: g({\n      userId: {\n        type: y(),\n        from: \"user_id\"\n      },\n      phoneNumber: {\n        type: h(),\n        from: \"phone_number\"\n      },\n      firstName: {\n        type: h(),\n        from: \"first_name\"\n      },\n      lastName: {\n        type: h().optional(),\n        from: \"last_name\"\n      }\n    }),\n    authDate: {\n      type: Ee(),\n      from: \"auth_date\"\n    },\n    hash: h()\n  }, \"RequestedContact\");\n}\nfunction Ve(s, e) {\n  return (t) => {\n    const [n, r] = e[t];\n    return v(n, r, s);\n  };\n}\nfunction Mt(s) {\n  return new Promise((e) => {\n    setTimeout(e, s);\n  });\n}\nclass Bt extends P {\n  constructor({ postEvent: t, createRequestId: n, version: r, botInline: i, ...o }) {\n    super(o, r, {\n      requestPhoneAccess: \"web_app_request_phone\",\n      requestWriteAccess: \"web_app_request_write_access\",\n      switchInlineQuery: \"web_app_switch_inline_query\",\n      setHeaderColor: \"web_app_set_header_color\",\n      setBackgroundColor: \"web_app_set_background_color\"\n    });\n    c(this, \"botInline\");\n    c(this, \"postEvent\");\n    c(this, \"createRequestId\");\n    c(this, \"requestPhoneAccessPromise\");\n    c(this, \"requestWriteAccessPromise\");\n    /**\n     * Checks if specified method parameter is supported by current component.\n     */\n    c(this, \"supportsParam\");\n    this.createRequestId = n, this.postEvent = t, this.botInline = i;\n    const a = this.supports.bind(this);\n    this.supports = (p) => a(p) ? p !== \"switchInlineQuery\" || i : !1, this.supportsParam = Ve(r, {\n      \"setHeaderColor.color\": [\"web_app_set_header_color\", \"color\"],\n      \"close.returnBack\": [\"web_app_close\", \"return_back\"]\n    });\n  }\n  /**\n   * Attempts to get requested contact.\n   * @param timeout - request timeout.\n   */\n  async getRequestedContact({\n    timeout: t = 1e4\n  } = {}) {\n    return Dt().parse(\n      await C(\n        \"getRequestedContact\",\n        {},\n        this.createRequestId(),\n        { postEvent: this.postEvent, timeout: t }\n      )\n    );\n  }\n  /**\n   * The Mini App background color.\n   * @example \"#ffaabb\"\n   */\n  get bgColor() {\n    return this.get(\"bgColor\");\n  }\n  /**\n   * Closes the Mini App.\n   * @param returnBack - should the application be wrapped into the bottom bar.\n   */\n  close(t) {\n    this.postEvent(\"web_app_close\", this.supportsParam(\"close.returnBack\") ? { return_back: t } : {});\n  }\n  /**\n   * The Mini App header color.\n   * @example \"#ffaabb\"\n   * @example \"bg_color\"\n   */\n  get headerColor() {\n    return this.get(\"headerColor\");\n  }\n  /**\n   * True if the Mini App is currently launched in bot inline mode.\n   */\n  get isBotInline() {\n    return this.botInline;\n  }\n  /**\n   * True if the current Mini App background color is recognized as dark.\n   */\n  get isDark() {\n    return ye(this.bgColor);\n  }\n  /**\n   * Informs the Telegram app that the Mini App is ready to be displayed.\n   *\n   * It is recommended to call this method as early as possible, as soon as all essential\n   * interface elements loaded. Once this method called, the loading placeholder is hidden\n   * and the Mini App shown.\n   *\n   * If the method not called, the placeholder will be hidden only when the page fully loaded.\n   */\n  ready() {\n    this.postEvent(\"web_app_ready\");\n  }\n  /**\n   * Requests current user contact information. In contrary to requestPhoneAccess, this method\n   * returns promise with contact information that rejects in case, user denied access, or request\n   * failed.\n   * @param options - additional options.\n   */\n  async requestContact({ timeout: t = 5e3 } = {}) {\n    try {\n      return await this.getRequestedContact();\n    } catch {\n    }\n    if (await this.requestPhoneAccess() !== \"sent\")\n      throw new Error(\"Access denied.\");\n    const r = Date.now() + t;\n    let i = 50;\n    return be(async () => {\n      for (; Date.now() < r; ) {\n        try {\n          return await this.getRequestedContact();\n        } catch {\n        }\n        await Mt(i), i += 50;\n      }\n      throw we(t);\n    }, t);\n  }\n  /**\n   * Requests current user phone access. Method returns promise, which resolves\n   * status of the request. In case, user accepted the request, Mini App bot will receive\n   * the according notification.\n   *\n   * To obtain the retrieved information instead, utilize the `requestContact` method.\n   * @param options - additional options.\n   * @see requestContact\n   */\n  async requestPhoneAccess(t = {}) {\n    return this.requestPhoneAccessPromise || (this.requestPhoneAccessPromise = d({\n      ...t,\n      method: \"web_app_request_phone\",\n      event: \"phone_requested\",\n      postEvent: this.postEvent\n    }).then(({ status: n }) => n).finally(() => this.requestPhoneAccessPromise = void 0)), this.requestPhoneAccessPromise;\n  }\n  /**\n   * Requests write message access to current user.\n   * @param options - additional options.\n   */\n  async requestWriteAccess(t = {}) {\n    return this.requestWriteAccessPromise || (this.requestWriteAccessPromise = d({\n      ...t,\n      method: \"web_app_request_write_access\",\n      event: \"write_access_requested\",\n      postEvent: this.postEvent\n    }).then(({ status: n }) => n).finally(() => this.requestWriteAccessPromise = void 0)), this.requestWriteAccessPromise;\n  }\n  /**\n   * A method used to send data to the bot. When this method called, a service message sent to\n   * the bot containing the data of the length up to 4096 bytes, and the Mini App closed. See the\n   * field `web_app_data` in the class [Message](https://core.telegram.org/bots/api#message).\n   *\n   * This method is only available for Mini Apps launched via a Keyboard button.\n   * @param data - data to send to bot.\n   * @throws {Error} data has incorrect size.\n   */\n  sendData(t) {\n    const { size: n } = new Blob([t]);\n    if (!n || n > 4096)\n      throw new Error(`Passed data has incorrect size: ${n}`);\n    this.postEvent(\"web_app_data_send\", { data: t });\n  }\n  /**\n   * Updates current Mini App header color.\n   *\n   * @see No effect on desktop: https://github.com/Telegram-Mini-Apps/telegram-apps/issues/9\n   * @see Works incorrectly in Android: https://github.com/Telegram-Mini-Apps/telegram-apps/issues/8\n   * @param color - color key or RGB color.\n   */\n  setHeaderColor(t) {\n    this.postEvent(\"web_app_set_header_color\", Q(t) ? { color: t } : { color_key: t }), this.set(\"headerColor\", t);\n  }\n  /**\n   * Updates current Mini App background color.\n   *\n   * @see No effect on desktop: https://github.com/Telegram-Mini-Apps/telegram-apps/issues/9\n   * @see Works incorrectly in Android: https://github.com/Telegram-Mini-Apps/telegram-apps/issues/8\n   * @param color - RGB color.\n   */\n  setBgColor(t) {\n    this.postEvent(\"web_app_set_background_color\", { color: t }), this.set(\"bgColor\", t);\n  }\n  /**\n   * Inserts the bot's username and the specified inline query in the current chat's input field.\n   * Query may be empty, in which case only the bot's username will be inserted. The client prompts\n   * the user to choose a specific chat, then opens that chat and inserts the bot's username and\n   * the specified inline query in the input field.\n   * @param text - text which should be inserted in the input after the current bot name. Max\n   * length is 256 symbols.\n   * @param chatTypes - List of chat types which could be chosen to send the message. Could be\n   * empty list.\n   */\n  switchInlineQuery(t, n = []) {\n    if (!this.supports(\"switchInlineQuery\") && !this.isBotInline)\n      throw new Error(\"Method is unsupported because Mini App should be launched in inline mode.\");\n    this.postEvent(\"web_app_switch_inline_query\", { query: t, chat_types: n });\n  }\n}\nconst ls = l(\n  \"miniApp\",\n  ({\n    themeParams: s,\n    botInline: e = !1,\n    state: t = {\n      bgColor: s.bgColor || \"#ffffff\",\n      headerColor: s.headerBgColor || \"#000000\"\n    },\n    ...n\n  }) => new Bt({ ...n, ...t, botInline: e })\n);\nfunction Lt(s) {\n  const e = s.message.trim(), t = (s.title || \"\").trim(), n = s.buttons || [];\n  let r;\n  if (t.length > 64)\n    throw new Error(`Title has incorrect size: ${t.length}`);\n  if (!e.length || e.length > 256)\n    throw new Error(`Message has incorrect size: ${e.length}`);\n  if (n.length > 3)\n    throw new Error(`Buttons have incorrect size: ${n.length}`);\n  return n.length ? r = n.map((i) => {\n    const { id: o = \"\" } = i;\n    if (o.length > 64)\n      throw new Error(`Button ID has incorrect size: ${o}`);\n    if (!i.type || i.type === \"default\" || i.type === \"destructive\") {\n      const a = i.text.trim();\n      if (!a.length || a.length > 64) {\n        const p = i.type || \"default\";\n        throw new Error(`Button text with type \"${p}\" has incorrect size: ${i.text.length}`);\n      }\n      return { ...i, text: a, id: o };\n    }\n    return { ...i, id: o };\n  }) : r = [{ type: \"close\", id: \"\" }], { title: t, message: e, buttons: r };\n}\nclass $t extends P {\n  constructor(e, t, n) {\n    super({ isOpened: e }, t, { open: \"web_app_open_popup\" }), this.postEvent = n;\n  }\n  set isOpened(e) {\n    this.set(\"isOpened\", e);\n  }\n  /**\n   * True if the Popup is opened.\n   */\n  get isOpened() {\n    return this.get(\"isOpened\");\n  }\n  /**\n   * A method that shows a native popup described by the `params` argument.\n   * Promise will be resolved when popup is closed. Resolved value will have\n   * an identifier of pressed button.\n   *\n   * In case, user clicked outside the popup or clicked top right popup close\n   * button, null will be returned.\n   *\n   * @param options - popup parameters.\n   * @throws {Error} Popup is already opened.\n   */\n  async open(e) {\n    if (this.isOpened)\n      throw new Error(\"Popup is already opened.\");\n    this.isOpened = !0;\n    try {\n      const { button_id: t = null } = await d({\n        event: \"popup_closed\",\n        method: \"web_app_open_popup\",\n        postEvent: this.postEvent,\n        params: Lt(e)\n      });\n      return t;\n    } finally {\n      this.isOpened = !1;\n    }\n  }\n}\nconst ds = l(\n  ({ postEvent: s, version: e }) => new $t(!1, e, s)\n);\nclass Wt extends P {\n  constructor(e, t, n) {\n    super({ isOpened: e }, t, {\n      close: \"web_app_close_scan_qr_popup\",\n      open: \"web_app_open_scan_qr_popup\"\n    }), this.postEvent = n;\n  }\n  /**\n   * Closes the scanner.\n   */\n  close() {\n    this.postEvent(\"web_app_close_scan_qr_popup\"), this.isOpened = !1;\n  }\n  set isOpened(e) {\n    this.set(\"isOpened\", e);\n  }\n  /**\n   * Returns true if the scanner is currently opened.\n   */\n  get isOpened() {\n    return this.get(\"isOpened\");\n  }\n  async open(e) {\n    if (this.isOpened)\n      throw new Error(\"The scanner is already opened\");\n    const { text: t, capture: n } = (typeof e == \"string\" ? { text: e } : e) || {};\n    this.isOpened = !0;\n    try {\n      const i = (await d({\n        method: \"web_app_open_scan_qr_popup\",\n        event: [\"qr_text_received\", \"scan_qr_popup_closed\"],\n        postEvent: this.postEvent,\n        params: { text: t },\n        capture(o) {\n          return o.event === \"scan_qr_popup_closed\" || !n || n(o.payload);\n        }\n      }) || {}).data || null;\n      return i && this.close(), i;\n    } finally {\n      this.isOpened = !1;\n    }\n  }\n  // TODO: Streaming mode, allowing to scan several QRs until closed.\n}\nconst _s = l(\n  ({ version: s, postEvent: e }) => new Wt(!1, s, e)\n);\nclass Ut extends Z {\n  constructor(t, n, r) {\n    super({ isVisible: t }, n, {\n      show: \"web_app_setup_settings_button\",\n      hide: \"web_app_setup_settings_button\"\n    });\n    /**\n     * Adds a new event listener.\n     * @param event - event to listen.\n     * @param listener - listener to add.\n     */\n    c(this, \"on\", (t, n) => t === \"click\" ? w(\"settings_button_pressed\", n) : this.state.on(t, n));\n    /**\n     * Removes the event listener.\n     * @param event - event to listen.\n     * @param listener - listener to remove.\n     */\n    c(this, \"off\", (t, n) => t === \"click\" ? B(\"settings_button_pressed\", n) : this.state.off(t, n));\n    this.postEvent = r;\n  }\n  set isVisible(t) {\n    this.set(\"isVisible\", t), this.postEvent(\"web_app_setup_settings_button\", { is_visible: t });\n  }\n  /**\n   * True if the SettingsButton is visible.\n   */\n  get isVisible() {\n    return this.get(\"isVisible\");\n  }\n  /**\n   * Hides the SettingsButton.\n   */\n  hide() {\n    this.isVisible = !1;\n  }\n  /**\n   * Shows the SettingsButton.\n   */\n  show() {\n    this.isVisible = !0;\n  }\n}\nconst fs = l(\n  \"settingsButton\",\n  ({\n    version: s,\n    postEvent: e,\n    state: t = { isVisible: !1 }\n  }) => new Ut(t.isVisible, s, e)\n);\nclass Ht extends P {\n  constructor(e, t, n) {\n    super({ isVerticalSwipeEnabled: e }, t, {\n      disableVerticalSwipe: \"web_app_setup_swipe_behavior\",\n      enableVerticalSwipe: \"web_app_setup_swipe_behavior\"\n    }), this.postEvent = n;\n  }\n  set isVerticalSwipeEnabled(e) {\n    this.set(\"isVerticalSwipeEnabled\", e), this.postEvent(\"web_app_setup_swipe_behavior\", { allow_vertical_swipe: e });\n  }\n  /**\n   * True, if the vertical swipe enabled.\n   */\n  get isVerticalSwipeEnabled() {\n    return this.get(\"isVerticalSwipeEnabled\");\n  }\n  /**\n   * Disables the vertical swipe.\n   */\n  disableVerticalSwipe() {\n    this.isVerticalSwipeEnabled = !1;\n  }\n  /**\n   * Enables the vertical swipe.\n   */\n  enableVerticalSwipe() {\n    this.isVerticalSwipeEnabled = !0;\n  }\n}\nconst gs = l(\n  \"swipeBehavior\",\n  ({\n    postEvent: s,\n    state: e = { isVerticalSwipeEnabled: !0 },\n    version: t\n  }) => new Ht(e.isVerticalSwipeEnabled, t, s)\n);\nfunction De(s) {\n  return Pe().parse(s);\n}\nclass Ot extends ee {\n  /**\n   * @since v6.10\n   */\n  get accentTextColor() {\n    return this.get(\"accentTextColor\");\n  }\n  get bgColor() {\n    return this.get(\"bgColor\");\n  }\n  get buttonColor() {\n    return this.get(\"buttonColor\");\n  }\n  get buttonTextColor() {\n    return this.get(\"buttonTextColor\");\n  }\n  get destructiveTextColor() {\n    return this.get(\"destructiveTextColor\");\n  }\n  /**\n   * Returns the copy of the internal state of the current component instance.\n   */\n  getState() {\n    return this.clone();\n  }\n  /**\n   * @since v6.10\n   */\n  get headerBgColor() {\n    return this.get(\"headerBgColor\");\n  }\n  get hintColor() {\n    return this.get(\"hintColor\");\n  }\n  /**\n   * @returns True in case, current color scheme is recognized as dark. This\n   * value is calculated according to theme bg color.\n   */\n  get isDark() {\n    return !this.bgColor || ye(this.bgColor);\n  }\n  get linkColor() {\n    return this.get(\"linkColor\");\n  }\n  get secondaryBgColor() {\n    return this.get(\"secondaryBgColor\");\n  }\n  /**\n   * @since v6.10\n   */\n  get sectionBgColor() {\n    return this.get(\"sectionBgColor\");\n  }\n  /**\n   * @since v6.10\n   */\n  get sectionHeaderTextColor() {\n    return this.get(\"sectionHeaderTextColor\");\n  }\n  /**\n   * @since v7.6\n   */\n  get sectionSeparatorColor() {\n    return this.get(\"sectionHeaderTextColor\");\n  }\n  /**\n   * Starts listening to the external theme changes and applies them.\n   * @returns Function to stop listening.\n   */\n  listen() {\n    return w(\"theme_changed\", (e) => {\n      this.set(De(e.theme_params));\n    });\n  }\n  /**\n   * @since v6.10\n   */\n  get subtitleTextColor() {\n    return this.get(\"subtitleTextColor\");\n  }\n  get textColor() {\n    return this.get(\"textColor\");\n  }\n}\nconst ws = l(\n  \"themeParams\",\n  ({ themeParams: s, state: e = s, addCleanup: t }) => {\n    const n = new Ot(e);\n    return t(n.listen()), n;\n  }\n);\nfunction bs(s = {}) {\n  return d({\n    ...s,\n    method: \"web_app_request_theme\",\n    event: \"theme_changed\"\n  }).then(De);\n}\nfunction I(s, e) {\n  return s.startsWith(e) ? s : `${e}${s}`;\n}\nfunction q(s) {\n  return new URL(\n    typeof s == \"string\" ? s : `${s.pathname || \"\"}${I(s.search || \"\", \"?\")}${I(s.hash || \"\", \"#\")}`,\n    \"http://a\"\n  );\n}\nclass Gt extends te {\n  constructor(t, n, r) {\n    super(t, { readTextFromClipboard: \"web_app_read_text_from_clipboard\" });\n    /**\n     * Checks if specified method parameter is supported by current component.\n     */\n    c(this, \"supportsParam\");\n    this.version = t, this.createRequestId = n, this.postEvent = r, this.supportsParam = Ve(t, {\n      \"openLink.tryInstantView\": [\"web_app_open_link\", \"try_instant_view\"]\n    });\n  }\n  openLink(t, n) {\n    const r = q(t).toString();\n    if (!v(\"web_app_open_link\", this.version)) {\n      window.open(r, \"_blank\");\n      return;\n    }\n    const i = typeof n == \"boolean\" ? { tryInstantView: n } : n || {};\n    this.postEvent(\"web_app_open_link\", {\n      url: r,\n      try_browser: i.tryBrowser,\n      try_instant_view: i.tryInstantView\n    });\n  }\n  /**\n   * Opens a Telegram link inside Telegram app. The Mini App will be closed. It expects passing\n   * link in full format, with hostname \"t.me\".\n   * @param url - URL to be opened.\n   * @throws {Error} URL has not allowed hostname.\n   */\n  openTelegramLink(t) {\n    const { hostname: n, pathname: r, search: i } = new URL(t, \"https://t.me\");\n    if (n !== \"t.me\")\n      throw new Error(`URL has not allowed hostname: ${n}. Only \"t.me\" is allowed`);\n    if (!v(\"web_app_open_tg_link\", this.version)) {\n      window.location.href = t;\n      return;\n    }\n    this.postEvent(\"web_app_open_tg_link\", { path_full: r + i });\n  }\n  /**\n   * Reads text from clipboard and returns string or null. null is returned\n   * in cases:\n   * - Value in clipboard is not text\n   * - Access to clipboard is not allowed\n   */\n  async readTextFromClipboard() {\n    const t = this.createRequestId(), {\n      data: n = null\n    } = await d({\n      method: \"web_app_read_text_from_clipboard\",\n      event: \"clipboard_text_received\",\n      postEvent: this.postEvent,\n      params: { req_id: t },\n      capture: ge(t)\n    });\n    return n;\n  }\n  /**\n   * Shares specified URL with the passed to the chats, selected by user. After being called,\n   * it closes the mini application.\n   *\n   * This method uses Telegram's Share Links.\n   * @param url - URL to share.\n   * @param text - text to append after the URL.\n   * @see https://core.telegram.org/api/links#share-links\n   * @see https://core.telegram.org/widgets/share#custom-buttons\n   */\n  shareURL(t, n) {\n    this.openTelegramLink(\n      \"https://t.me/share/url?\" + new URLSearchParams({ url: t, text: n || \"\" }).toString().replace(/\\+/g, \"%20\")\n    );\n  }\n}\nconst ms = l(\n  ({ version: s, postEvent: e, createRequestId: t }) => new Gt(s, t, e)\n);\nasync function Me(s = {}) {\n  const {\n    is_expanded: e,\n    is_state_stable: t,\n    ...n\n  } = await d({\n    ...s,\n    method: \"web_app_request_viewport\",\n    event: \"viewport_changed\"\n  });\n  return { ...n, isExpanded: e, isStateStable: t };\n}\nfunction x(s) {\n  return s < 0 ? 0 : s;\n}\nclass jt extends ee {\n  constructor({ postEvent: t, stableHeight: n, height: r, width: i, isExpanded: o }) {\n    super({\n      height: x(r),\n      isExpanded: o,\n      stableHeight: x(n),\n      width: x(i)\n    });\n    c(this, \"postEvent\");\n    this.postEvent = t;\n  }\n  /**\n   * Requests viewport information from the Telegram application and updates current Viewport\n   * instance.\n   * @param options - options to request fresh data.\n   */\n  async sync(t) {\n    const { isStateStable: n, ...r } = await Me(t);\n    this.set({\n      ...r,\n      stableHeight: n ? r.height : this.get(\"stableHeight\")\n    });\n  }\n  /**\n   * The current height of the **visible area** of the Mini App.\n   *\n   * The application can display just the top part of the Mini App, with its lower part remaining\n   * outside the screen area. From this position, the user can \"pull\" the Mini App to its\n   * maximum height, while the bot can do the same by calling `expand` method. As the position of\n   * the Mini App changes, the current height value of the visible area will be updated  in real\n   * time.\n   *\n   * Please note that the refresh rate of this value is not sufficient to smoothly follow the\n   * lower border of the window. It should not be used to pin interface elements to the bottom\n   * of the visible area. It's more appropriate to use the value of the `stableHeight`\n   * field for this purpose.\n   *\n   * @see stableHeight\n   */\n  get height() {\n    return this.get(\"height\");\n  }\n  /**\n   * The height of the visible area of the Mini App in its last stable state.\n   *\n   * The application can display just the top part of the Mini App, with its lower part remaining\n   * outside the screen area. From this position, the user can \"pull\" the Mini App to its\n   * maximum height, while the application can do the same by calling `expand` method.\n   *\n   * Unlike the value of `height`, the value of `stableHeight` does not change as the position\n   * of the Mini App changes with user gestures or during animations. The value of `stableHeight`\n   * will be updated after all gestures and animations are completed and\n   * the Mini App reaches its final size.\n   *\n   * @see height\n   */\n  get stableHeight() {\n    return this.get(\"stableHeight\");\n  }\n  /**\n   * Starts listening to viewport changes and applies them.\n   * @returns Function to stop listening.\n   */\n  listen() {\n    return w(\"viewport_changed\", (t) => {\n      const {\n        height: n,\n        width: r,\n        is_expanded: i,\n        is_state_stable: o\n      } = t, a = x(n);\n      this.set({\n        height: a,\n        isExpanded: i,\n        width: x(r),\n        ...o ? { stableHeight: a } : {}\n      });\n    });\n  }\n  /**\n   * True if the Mini App is expanded to the maximum available height. Otherwise, if\n   * the Mini App occupies part of the screen and can be expanded to the full height using\n   * `expand` method.\n   * @see expand\n   */\n  get isExpanded() {\n    return this.get(\"isExpanded\");\n  }\n  /**\n   * Current visible area width.\n   */\n  get width() {\n    return this.get(\"width\");\n  }\n  /**\n   * A method that expands the Mini App to the maximum available height. To find out if the Mini\n   * App is expanded to the maximum height, refer to the value of the `isExpanded`.\n   * @see isExpanded\n   */\n  expand() {\n    this.postEvent(\"web_app_expand\"), this.set(\"isExpanded\", !0);\n  }\n  /**\n   * True if the current viewport height is stable and is not going to change in the next moment.\n   */\n  get isStable() {\n    return this.stableHeight === this.height;\n  }\n}\nconst ys = l(\n  \"viewport\",\n  async ({ state: s, platform: e, postEvent: t, addCleanup: n }) => {\n    let r = !1, i = 0, o = 0, a = 0;\n    if (s)\n      r = s.isExpanded, i = s.height, o = s.width, a = s.stableHeight;\n    else if ([\"macos\", \"tdesktop\", \"unigram\", \"webk\", \"weba\", \"web\"].includes(e))\n      r = !0, i = window.innerHeight, o = window.innerWidth, a = window.innerHeight;\n    else {\n      const u = await Me({ timeout: 1e3, postEvent: t });\n      r = u.isExpanded, i = u.height, o = u.width, a = u.isStateStable ? i : 0;\n    }\n    const p = new jt({\n      postEvent: t,\n      height: i,\n      width: o,\n      stableHeight: a,\n      isExpanded: r\n    });\n    return n(p.listen()), p;\n  }\n);\nfunction m(s, e) {\n  document.documentElement.style.setProperty(s, e);\n}\nfunction vs(s, e, t) {\n  t || (t = (a) => `--tg-${a}-color`);\n  const n = t(\"header\"), r = t(\"bg\"), i = () => {\n    const { headerColor: a } = s;\n    if (Q(a))\n      m(n, a);\n    else {\n      const { bgColor: p, secondaryBgColor: u } = e;\n      a === \"bg_color\" && p ? m(n, p) : a === \"secondary_bg_color\" && u && m(n, u);\n    }\n    m(r, s.bgColor);\n  }, o = [\n    e.on(\"change\", i),\n    s.on(\"change\", i)\n  ];\n  return i(), () => o.forEach((a) => a());\n}\nfunction Es(s, e) {\n  e || (e = (n) => `--tg-theme-${n.replace(/[A-Z]/g, (r) => `-${r.toLowerCase()}`)}`);\n  const t = () => {\n    Object.entries(s.getState()).forEach(([n, r]) => {\n      r && m(e(n), r);\n    });\n  };\n  return t(), s.on(\"change\", t);\n}\nfunction Ss(s, e) {\n  e || (e = (u) => `--tg-viewport-${u}`);\n  const [\n    t,\n    n,\n    r\n  ] = [\"height\", \"width\", \"stable-height\"].map((u) => e(u)), i = () => m(t, `${s.height}px`), o = () => m(n, `${s.width}px`), a = () => m(r, `${s.stableHeight}px`), p = [\n    s.on(\"change:height\", i),\n    s.on(\"change:width\", o),\n    s.on(\"change:stableHeight\", a)\n  ];\n  return i(), o(), a(), () => p.forEach((u) => u());\n}\nfunction Ps(s = !0) {\n  const e = [\n    w(\"reload_iframe\", () => {\n      A(\"iframe_will_reload\"), window.location.reload();\n    })\n  ], t = () => e.forEach((n) => n());\n  if (s) {\n    const n = document.createElement(\"style\");\n    n.id = \"telegram-custom-styles\", document.head.appendChild(n), e.push(\n      w(\"set_custom_style\", (r) => {\n        n.innerHTML = r;\n      }),\n      () => document.head.removeChild(n)\n    );\n  }\n  return A(\"iframe_ready\", { reload_supported: !0 }), t;\n}\nfunction xs() {\n  return typeof window > \"u\";\n}\nasync function Cs() {\n  if (de(window))\n    return !0;\n  try {\n    return await d({ method: \"web_app_request_theme\", event: \"theme_changed\", timeout: 100 }), !0;\n  } catch {\n    return !1;\n  }\n}\nfunction Ts(s) {\n  const e = typeof s == \"string\" ? X(s) : s;\n  qe(e);\n  function t(r) {\n    if (typeof r == \"string\")\n      try {\n        const { eventType: i } = ue(r);\n        i === \"web_app_request_theme\" && j(\"theme_changed\", {\n          theme_params: JSON.parse(Ie(e.themeParams))\n        }), i === \"web_app_request_viewport\" && j(\"viewport_changed\", {\n          width: window.innerWidth,\n          height: window.innerHeight,\n          is_state_stable: !0,\n          is_expanded: !0\n        });\n      } catch {\n      }\n  }\n  if (_e()) {\n    const r = window.parent.postMessage.bind(window.parent);\n    window.parent.postMessage = (i) => {\n      t(i), r(i);\n    };\n    return;\n  }\n  if (le(window)) {\n    const r = window.external.notify.bind(window.external);\n    window.external.notify = (i) => {\n      t(i), r(i);\n    };\n    return;\n  }\n  const n = window.TelegramWebviewProxy;\n  window.TelegramWebviewProxy = {\n    ...n || {},\n    postEvent(...r) {\n      t(JSON.stringify({ eventType: r[0], eventData: r[1] })), n && n.postEvent(...r);\n    }\n  };\n}\nfunction zt(s) {\n  return s instanceof V;\n}\nfunction Rs(s, e) {\n  return zt(s) && s.type === e;\n}\nfunction L(s, e) {\n  let t, n, r;\n  return typeof s == \"string\" ? t = s : (t = s.pathname === void 0 ? e : s.pathname, n = s.params, r = s.id), Object.freeze({\n    id: r || (Math.random() * 2 ** 14 | 0).toString(16),\n    pathname: t,\n    params: n\n  });\n}\nclass Ft {\n  constructor(e, t, n = A) {\n    /**\n     * Navigation history.\n     */\n    c(this, \"history\");\n    c(this, \"ee\", new R());\n    /**\n     * True, if current navigator is currently attached.\n     */\n    c(this, \"attached\", !1);\n    /**\n     * Goes to the previous history item.\n     */\n    c(this, \"back\", () => this.go(-1));\n    /**\n     * Adds new event listener.\n     */\n    c(this, \"on\", this.ee.on.bind(this.ee));\n    /**\n     * Removes event listener.\n     */\n    c(this, \"off\", this.ee.off.bind(this.ee));\n    if (this._index = t, this.postEvent = n, e.length === 0)\n      throw f(Ze, \"History should not be empty.\");\n    if (t < 0 || t >= e.length)\n      throw f(\n        Ke,\n        \"Index should not be zero and higher or equal than history size.\"\n      );\n    this.history = e.map((r) => L(r, \"\"));\n  }\n  /**\n   * Allows this navigator to control the `BackButton` visibility state. It also tracks the\n   * `BackButton` clicks and calls the `back` method.\n   */\n  attach() {\n    this.attached || (this.attached = !0, this.sync(), w(\"back_button_pressed\", this.back));\n  }\n  /**\n   * Currently active history item.\n   */\n  get current() {\n    return this.history[this.index];\n  }\n  /**\n   * Prevents current navigator from controlling the BackButton visibility state.\n   */\n  detach() {\n    this.attached = !1, B(\"back_button_pressed\", this.back);\n  }\n  /**\n   * Goes to the next history item.\n   */\n  forward() {\n    this.go(1);\n  }\n  /**\n   * Changes currently active history item index by the specified delta. This method doesn't\n   * change index in case, the updated index points to the non-existing history item. This behavior\n   * is preserved until the `fit` argument is specified.\n   * @param delta - index delta.\n   * @param fit - cuts the delta argument to fit the bounds `[0, history.length - 1]`.\n   */\n  go(e, t) {\n    const n = this.index + e, r = Math.min(\n      Math.max(0, n),\n      this.history.length - 1\n    );\n    (n === r || t) && this.replaceAndMove(r, this.history[r]);\n  }\n  /**\n   * Goes to the specified index. Method does nothing in case, passed index is out of bounds.\n   *\n   * If \"fit\" option was specified and index is out of bounds, it will be cut to the nearest\n   * bound.\n   * @param index - target index.\n   * @param fit - cuts the index argument to fit the bounds `[0, history.length - 1]`.\n   */\n  goTo(e, t) {\n    this.go(e - this.index, t);\n  }\n  /**\n   * True if navigator has items before the current item.\n   */\n  get hasPrev() {\n    return this.index > 0;\n  }\n  /**\n   * True if navigator has items after the current item.\n   */\n  get hasNext() {\n    return this.index !== this.history.length - 1;\n  }\n  /**\n   * Currently active history item index.\n   */\n  get index() {\n    return this._index;\n  }\n  /**\n   * Adds a new history item removing all after the current one.\n   * @param item - item to add.\n   */\n  push(e) {\n    this.hasNext && this.history.splice(this.index + 1), this.replaceAndMove(this.index + 1, L(e, this.current.pathname));\n  }\n  /**\n   * Replaces the current history item.\n   * @param item - item to replace the current item with.\n   */\n  replace(e) {\n    this.replaceAndMove(this.index, L(e, this.current.pathname));\n  }\n  /**\n   * Sets history item by the specified index.\n   * @param index - history item index to replace.\n   * @param historyItem - history item to set.\n   */\n  replaceAndMove(e, t) {\n    const n = e - this.index;\n    if (!n && this.current === t)\n      return;\n    const r = this.current;\n    if (this.index !== e) {\n      const i = this._index;\n      this._index = e, this.attached && i > 0 != e > 0 && this.sync();\n    }\n    this.history[e] = t, this.ee.emit(\"change\", {\n      navigator: this,\n      from: r,\n      to: this.current,\n      delta: n\n    });\n  }\n  /**\n   * Actualizes the `BackButton` visibility state.\n   */\n  sync() {\n    this.postEvent(\"web_app_setup_back_button\", { is_visible: !!this.index });\n  }\n}\nfunction $({\n  params: s,\n  ...e\n}) {\n  return { ...s || { hash: \"\", search: \"\" }, ...e };\n}\nfunction N(s) {\n  const e = typeof s == \"string\" ? s.startsWith(\"/\") : !!(s.pathname && s.pathname.startsWith(\"/\")), t = q(s);\n  return `${e ? t.pathname : t.pathname.slice(1)}${t.search}${t.hash}`;\n}\nfunction W(s, e, t) {\n  let n, r;\n  typeof s == \"string\" ? n = s : (n = N(s), t = s.state, r = s.id);\n  const { pathname: i, search: o, hash: a } = new URL(n, `http://a${I(e, \"/\")}`);\n  return { id: r, pathname: i, params: { hash: a, search: o, state: t } };\n}\nasync function T(s) {\n  return s === 0 ? !0 : Promise.race([\n    new Promise((e) => {\n      const t = G(\"popstate\", () => {\n        t(), e(!0);\n      });\n      window.history.go(s);\n    }),\n    // Usually, it takes about 1ms to emit this event, but we use some buffer.\n    new Promise((e) => {\n      setTimeout(e, 50, !1);\n    })\n  ]);\n}\nasync function Jt() {\n  if (window.history.length <= 1 || (window.history.pushState(null, \"\"), await T(1 - window.history.length)))\n    return;\n  let e = await T(-1);\n  for (; e; )\n    e = await T(-1);\n}\nfunction Be(s) {\n  return q(s).pathname;\n}\nconst ie = 0, U = 1, H = 2;\nclass Le {\n  constructor(e, t, { postEvent: n, hashMode: r = \"classic\", base: i } = {}) {\n    c(this, \"navigator\");\n    c(this, \"ee\", new R());\n    c(this, \"hashMode\");\n    c(this, \"base\");\n    /**\n     * Shows whether the navigator is currently attached to the browser history.\n     */\n    c(this, \"attached\", !1);\n    /**\n     * Handles the window \"popstate\" event.\n     * @param state - event state.\n     */\n    c(this, \"onPopState\", ({ state: e }) => {\n      if (e === null)\n        return this.push(this.parsePath(window.location.href));\n      e === ie ? window.history.forward() : e === U && this.back(), e === H && this.forward();\n    });\n    /**\n     * Underlying navigator change event listener.\n     */\n    c(this, \"onNavigatorChange\", async ({\n      to: e,\n      from: t,\n      delta: n\n    }) => {\n      this.attached && await this.syncHistory(), this.ee.emit(\"change\", {\n        delta: n,\n        from: $(t),\n        to: $(e),\n        navigator: this\n      });\n    });\n    /**\n     * Adds new event listener.\n     */\n    c(this, \"on\", this.ee.on.bind(this.ee));\n    /**\n     * Removes event listener.\n     */\n    c(this, \"off\", this.ee.off.bind(this.ee));\n    this.navigator = new Ft(\n      e.map((o) => W(o, \"/\")),\n      t,\n      n\n    ), this.navigator.on(\"change\", (o) => {\n      this.onNavigatorChange(o);\n    }), this.hashMode = r, this.base = Be(i || \"\");\n  }\n  /**\n   * Attaches current navigator to the browser history allowing navigator to manipulate it.\n   */\n  async attach() {\n    this.attached || (this.attached = !0, this.navigator.attach(), window.addEventListener(\"popstate\", this.onPopState), await this.syncHistory());\n  }\n  /**\n   * Goes back in history by 1.\n   */\n  back() {\n    this.navigator.back();\n  }\n  /**\n   * Detaches current navigator from the browser history.\n   */\n  detach() {\n    this.attached = !1, this.navigator.detach(), window.removeEventListener(\"popstate\", this.onPopState);\n  }\n  /**\n   * Goes forward in history.\n   */\n  forward() {\n    return this.navigator.forward();\n  }\n  /**\n   * Current history cursor.\n   */\n  get index() {\n    return this.navigator.index;\n  }\n  /**\n   * Current history item identifier.\n   */\n  get id() {\n    return this.navigator.current.id;\n  }\n  /**\n   * Changes currently active history item index by the specified delta. This method doesn't\n   * change index in case, the updated index points to the non-existing history item. This behavior\n   * is preserved until the `fit` argument is specified.\n   * @param delta - index delta.\n   * @param fit - cuts the delta argument to fit the bounds `[0, history.length - 1]`.\n   */\n  go(e, t) {\n    return this.navigator.go(e, t);\n  }\n  /**\n   * Goes to the specified index. Method does nothing in case, passed index is out of bounds.\n   *\n   * If \"fit\" option was specified and index is out of bounds, it will be cut to the nearest\n   * bound.\n   * @param index - target index.\n   * @param fit - cuts the index argument to fit the bounds `[0, history.length - 1]`.\n   */\n  goTo(e, t) {\n    this.navigator.goTo(e, t);\n  }\n  /**\n   * Current history item hash.\n   * @see URL.hash\n   * @example\n   * \"\", \"#my-hash\"\n   */\n  get hash() {\n    return (this.navigator.current.params || {}).hash || \"\";\n  }\n  /**\n   * True if navigator has items before the current item.\n   */\n  get hasPrev() {\n    return this.navigator.hasPrev;\n  }\n  /**\n   * True if navigator has items after the current item.\n   */\n  get hasNext() {\n    return this.navigator.hasNext;\n  }\n  /**\n   * Navigation history.\n   */\n  get history() {\n    return this.navigator.history.map($);\n  }\n  /**\n   * Path, including pathname, search and hash.\n   * @example Pathname only.\n   * \"/pathname\"\n   * @example Pathname + search.\n   * \"/pathname?search\"\n   * @example Pathname + hash.\n   * \"/pathname#hash\"\n   * @example Pathname + search + hash.\n   * \"/pathname?search#hash\"\n   */\n  get path() {\n    return N(this);\n  }\n  /**\n   * Current pathname. Always starts with the slash.\n   * @see URL.pathname\n   * @example\n   * \"/\", \"/abc\"\n   */\n  get pathname() {\n    return this.navigator.current.pathname;\n  }\n  /**\n   * Depending on the current navigation type, parses incoming path and returns it presented as\n   * an object. In other words, this method parses the passed path and returns object, describing\n   * how the navigator \"sees\" it.\n   *\n   * @example Hash mode is omitted.\n   * parsePath('/abc?a=1#hash');\n   * // { pathname: '/abc', search: '?a=1', hash: '#hash' }\n   * parsePath('http://example.com/abc?a=1#hash');\n   * // { pathname: '/abc', search: '?a=1', hash: '#hash' }\n   *\n   * @example Hash mode is enabled.\n   * parsePath('/abc?a=1#tma?is=cool#yeah');\n   * // { pathname: '/tma', search: '?is=cool', hash: '#yeah' }\n   * parsePath('http://example.com/abc?a=1#tma?is=cool#yeah');\n   * // { pathname: '/tma', search: '?is=cool', hash: '#yeah' }\n   */\n  parsePath(e) {\n    let t = q(e);\n    return this.hashMode && (t = q(t.hash.slice(1))), {\n      pathname: t.pathname,\n      search: t.search,\n      hash: t.hash\n    };\n  }\n  push(e, t) {\n    const n = W(e, this.path), { state: r = t } = n.params;\n    this.navigator.push({ ...n, params: { ...n.params, state: r } });\n  }\n  replace(e, t) {\n    const n = W(e, this.path), { state: r = t } = n.params;\n    this.navigator.replace({ ...n, params: { ...n.params, state: r } });\n  }\n  /**\n   * Combines the navigator `base` property with the passed path data applying the navigator\n   * navigation mode.\n   * @param value - path presented as string or URLLike.\n   */\n  renderPath(e) {\n    const t = (this.base.length === 1 ? \"\" : this.base) + I(N(e), \"/\");\n    return this.hashMode ? I(t.slice(1), this.hashMode === \"classic\" ? \"#\" : \"#/\") : t;\n  }\n  /**\n   * Synchronizes current navigator state with browser history.\n   */\n  async syncHistory() {\n    window.removeEventListener(\"popstate\", this.onPopState);\n    const { state: e } = this, t = this.renderPath(this);\n    await Jt(), this.hasPrev && this.hasNext ? (window.history.replaceState(U, \"\"), window.history.pushState(e, \"\", t), window.history.pushState(H, \"\"), await T(-1)) : this.hasPrev ? (window.history.replaceState(U, \"\"), window.history.pushState(e, \"\", t)) : this.hasNext ? (window.history.replaceState(e, t), window.history.pushState(H, \"\"), await T(-1)) : (window.history.replaceState(ie, \"\"), window.history.pushState(e, \"\", t)), window.addEventListener(\"popstate\", this.onPopState);\n  }\n  /**\n   * Current query parameters.\n   * @see URL.search\n   * @example\n   * \"\", \"?\", \"?a=1\"\n   */\n  get search() {\n    return (this.navigator.current.params || {}).search || \"\";\n  }\n  /**\n   * Current history item state.\n   */\n  get state() {\n    return (this.navigator.current.params || {}).state;\n  }\n}\nfunction Qt(s) {\n  s || (s = {});\n  const { href: e, hash: t } = window.location;\n  let n = N(\n    s.hashMode === null ? e : t.includes(\"?\") ? t.slice(1) : `?${t.slice(1)}`\n  );\n  const r = s.base ? Be(s.base) : void 0;\n  if (r) {\n    if (!n.startsWith(r))\n      throw f(\n        Xe,\n        `Path \"${n}\" expected to be starting with \"${r}\"`\n      );\n    n = n.slice(r.length);\n  }\n  return new Le([n], 0, s);\n}\nfunction As(s) {\n  const e = s.match(/#(.+)/);\n  return e ? e[1] : null;\n}\nfunction Yt(s, e) {\n  if (ke()) {\n    const t = sessionStorage.getItem(s);\n    if (t)\n      try {\n        const { index: n, history: r } = JSON.parse(t);\n        return new Le(\n          r,\n          n,\n          e\n        );\n      } catch (n) {\n        console.error(\"Unable to restore hash navigator state.\", n);\n      }\n  }\n  return Qt(e);\n}\nfunction Is(s, e) {\n  const t = Yt(s, e), n = () => sessionStorage.setItem(s, JSON.stringify({\n    index: t.index,\n    history: t.history\n  }));\n  return t.on(\"change\", n), n(), t;\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRlbGVncmFtLWFwcHMvc2RrL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBLDBDQUEwQywwREFBMEQ7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFdBQVc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGVBQWUsMkJBQTJCLHVDQUF1QyxlQUFlO0FBQ3JHO0FBQ0EsV0FBVyxFQUFFLFNBQVMsV0FBVztBQUNqQyxTQUFTLEdBQUcsNEJBQTRCO0FBQ3hDO0FBQ0EsU0FBUyxHQUFHLEVBQUUsYUFBYSxHQUFHLE9BQU8sRUFBRSx3QkFBd0IsRUFBRSxPQUFPO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGNBQWMscUJBQXFCO0FBQ25DLGlDQUFpQyxzQkFBc0IsSUFBSSxTQUFTO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLGVBQWU7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxnQkFBZ0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUY7QUFDckYsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLCtCQUErQixnQkFBZ0IsR0FBRztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsRUFBRTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsMEJBQTBCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsV0FBVyxVQUFVLHNCQUFzQjtBQUMzQztBQUNBO0FBQ0E7QUFDQSxZQUFZLHFDQUFxQyxFQUFFLFNBQVMsRUFBRSxPQUFPO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrQ0FBa0Msd0JBQXdCLFVBQVU7QUFDOUUsV0FBVyw4QkFBOEI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEdBQUc7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpREFBaUQsSUFBSTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsVUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxlQUFlO0FBQ2hELDBCQUEwQixnQkFBZ0IseUJBQXlCO0FBQ25FO0FBQ0E7QUFDQSxpQ0FBaUMsZUFBZTtBQUNoRCw2QkFBNkIsZ0JBQWdCLHlCQUF5QjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLFVBQVUsbUJBQW1CO0FBQzdCO0FBQ0EsaUVBQWlFLFdBQVc7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLEVBQUUsa0NBQWtDLEVBQUU7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1QkFBdUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQTBHRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpY2tlci10ZWxlZ3JhbS1hcHAtdmlzdWFsLy4vbm9kZV9tb2R1bGVzL0B0ZWxlZ3JhbS1hcHBzL3Nkay9kaXN0L2luZGV4LmpzP2M3NDIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIFdlID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIFVlID0gKHMsIGUsIHQpID0+IGUgaW4gcyA/IFdlKHMsIGUsIHsgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCwgdmFsdWU6IHQgfSkgOiBzW2VdID0gdDtcbnZhciBjID0gKHMsIGUsIHQpID0+IChVZShzLCB0eXBlb2YgZSAhPSBcInN5bWJvbFwiID8gZSArIFwiXCIgOiBlLCB0KSwgdCk7XG5mdW5jdGlvbiBvZShzLCBlKSB7XG4gIGxldCB0O1xuICBjb25zdCBuID0gKCkgPT4ge1xuICAgIHQgIT09IHZvaWQgMCAmJiBlICYmIGUodCksIHQgPSB2b2lkIDA7XG4gIH07XG4gIHJldHVybiBbKCkgPT4gdCA9PT0gdm9pZCAwID8gdCA9IHMobikgOiB0LCBuXTtcbn1cbmZ1bmN0aW9uIGFlKHMpIHtcbiAgY29uc3QgZSA9IE0oKSwgeyBjb3VudDogdCB9ID0gZTtcbiAgZS51bnN1YnNjcmliZShzKSwgdCAmJiAhZS5jb3VudCAmJiBpdCgpO1xufVxuZnVuY3Rpb24gSGUocykge1xuICByZXR1cm4gTSgpLnN1YnNjcmliZShzKSwgKCkgPT4gYWUocyk7XG59XG5jbGFzcyBPZSB7XG4gIGNvbnN0cnVjdG9yKGUsIHQgPSB7fSkge1xuICAgIHRoaXMuc2NvcGUgPSBlLCB0aGlzLm9wdGlvbnMgPSB0O1xuICB9XG4gIC8qKlxuICAgKiBQcmludHMgbWVzc2FnZSBpbnRvIGEgY29uc29sZSBpbiBjYXNlLCBsb2dnZXIgaXMgY3VycmVudGx5IGVuYWJsZWQuXG4gICAqIEBwYXJhbSBsZXZlbCAtIGxvZyBsZXZlbC5cbiAgICogQHBhcmFtIGFyZ3MgLSBhcmd1bWVudHMuXG4gICAqL1xuICBwcmludChlLCAuLi50KSB7XG4gICAgY29uc3QgbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLCByID0gSW50bC5EYXRlVGltZUZvcm1hdChcImVuLUdCXCIsIHtcbiAgICAgIGhvdXI6IFwiMi1kaWdpdFwiLFxuICAgICAgbWludXRlOiBcIjItZGlnaXRcIixcbiAgICAgIHNlY29uZDogXCIyLWRpZ2l0XCIsXG4gICAgICBmcmFjdGlvbmFsU2Vjb25kRGlnaXRzOiAzLFxuICAgICAgdGltZVpvbmU6IFwiVVRDXCJcbiAgICB9KS5mb3JtYXQobiksIHsgdGV4dENvbG9yOiBpLCBiZ0NvbG9yOiBvIH0gPSB0aGlzLm9wdGlvbnMsIGEgPSBcImZvbnQtd2VpZ2h0OiBib2xkO3BhZGRpbmc6IDAgNXB4O2JvcmRlci1yYWRpdXM6NXB4XCI7XG4gICAgY29uc29sZVtlXShcbiAgICAgIGAlYyR7cn0lYyAvICVjJHt0aGlzLnNjb3BlfWAsXG4gICAgICBgJHthfTtiYWNrZ3JvdW5kLWNvbG9yOiBsaWdodGJsdWU7Y29sb3I6YmxhY2tgLFxuICAgICAgXCJcIixcbiAgICAgIGAke2F9OyR7aSA/IGBjb2xvcjoke2l9O2AgOiBcIlwifSR7byA/IGBiYWNrZ3JvdW5kLWNvbG9yOiR7b31gIDogXCJcIn1gLFxuICAgICAgLi4udFxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFByaW50cyBlcnJvciBtZXNzYWdlIGludG8gYSBjb25zb2xlLlxuICAgKiBAcGFyYW0gYXJnc1xuICAgKi9cbiAgZXJyb3IoLi4uZSkge1xuICAgIHRoaXMucHJpbnQoXCJlcnJvclwiLCAuLi5lKTtcbiAgfVxuICAvKipcbiAgICogUHJpbnRzIGxvZyBtZXNzYWdlIGludG8gYSBjb25zb2xlLlxuICAgKiBAcGFyYW0gYXJnc1xuICAgKi9cbiAgbG9nKC4uLmUpIHtcbiAgICB0aGlzLnByaW50KFwibG9nXCIsIC4uLmUpO1xuICB9XG59XG5jb25zdCBGID0gbmV3IE9lKFwiU0RLXCIsIHtcbiAgYmdDb2xvcjogXCJmb3Jlc3RncmVlblwiLFxuICB0ZXh0Q29sb3I6IFwid2hpdGVcIlxufSk7XG5sZXQgTyA9ICExO1xuY29uc3Qgc2UgPSAoeyBuYW1lOiBzLCBwYXlsb2FkOiBlIH0pID0+IHtcbiAgRi5sb2coXCJFdmVudCByZWNlaXZlZDpcIiwgZSA/IHsgbmFtZTogcywgcGF5bG9hZDogZSB9IDogeyBuYW1lOiBzIH0pO1xufTtcbmZ1bmN0aW9uIEt0KHMpIHtcbiAgTyAhPT0gcyAmJiAoTyA9IHMsIHMgPyBIZShzZSkgOiBhZShzZSkpO1xufVxuZnVuY3Rpb24gR2UoLi4ucykge1xuICBPICYmIEYubG9nKC4uLnMpO1xufVxuY2xhc3MgUiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGModGhpcywgXCJsaXN0ZW5lcnNcIiwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gICAgYyh0aGlzLCBcImxpc3RlbmVyc0NvdW50XCIsIDApO1xuICAgIGModGhpcywgXCJzdWJzY3JpYmVMaXN0ZW5lcnNcIiwgW10pO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBldmVudCBsaXN0ZW5lcnMuXG4gICAqL1xuICBjbGVhcigpIHtcbiAgICB0aGlzLmxpc3RlbmVycy5jbGVhcigpLCB0aGlzLnN1YnNjcmliZUxpc3RlbmVycyA9IFtdO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGNvdW50IG9mIGJvdW5kIGxpc3RlbmVycy5cbiAgICovXG4gIGdldCBjb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lcnNDb3VudCArIHRoaXMuc3Vic2NyaWJlTGlzdGVuZXJzLmxlbmd0aDtcbiAgfVxuICBlbWl0KGUsIC4uLnQpIHtcbiAgICB0aGlzLnN1YnNjcmliZUxpc3RlbmVycy5mb3JFYWNoKChyKSA9PiByKHtcbiAgICAgIGV2ZW50OiBlLFxuICAgICAgYXJnczogdFxuICAgIH0pKSwgKHRoaXMubGlzdGVuZXJzLmdldChlKSB8fCBbXSkuZm9yRWFjaCgoW3IsIGldKSA9PiB7XG4gICAgICByKC4uLnQpLCBpICYmIHRoaXMub2ZmKGUsIHIpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIG5ldyBldmVudCBsaXN0ZW5lci5cbiAgICogQHBhcmFtIGV2ZW50IC0gZXZlbnQgbmFtZS5cbiAgICogQHBhcmFtIGxpc3RlbmVyIC0gZXZlbnQgbGlzdGVuZXIuXG4gICAqIEBwYXJhbSBvbmNlIC0gc2hvdWxkIGxpc3RlbmVyIGJlIGNhbGxlZCBvbmx5IG9uY2UuXG4gICAqIEByZXR1cm5zIEZ1bmN0aW9uIHRvIHJlbW92ZSBib3VuZCBldmVudCBsaXN0ZW5lci5cbiAgICovXG4gIG9uKGUsIHQsIG4pIHtcbiAgICBsZXQgciA9IHRoaXMubGlzdGVuZXJzLmdldChlKTtcbiAgICByZXR1cm4gciB8fCB0aGlzLmxpc3RlbmVycy5zZXQoZSwgciA9IFtdKSwgci5wdXNoKFt0LCBuXSksIHRoaXMubGlzdGVuZXJzQ291bnQgKz0gMSwgKCkgPT4gdGhpcy5vZmYoZSwgdCk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgZXZlbnQgbGlzdGVuZXIuIEluIGNhc2UsIHNwZWNpZmllZCBsaXN0ZW5lciB3YXMgYm91bmQgc2V2ZXJhbCB0aW1lcywgaXQgcmVtb3Zlc1xuICAgKiBvbmx5IGEgc2luZ2xlIG9uZS5cbiAgICogQHBhcmFtIGV2ZW50IC0gZXZlbnQgbmFtZS5cbiAgICogQHBhcmFtIGxpc3RlbmVyIC0gZXZlbnQgbGlzdGVuZXIuXG4gICAqL1xuICBvZmYoZSwgdCkge1xuICAgIGNvbnN0IG4gPSB0aGlzLmxpc3RlbmVycy5nZXQoZSkgfHwgW107XG4gICAgZm9yIChsZXQgciA9IDA7IHIgPCBuLmxlbmd0aDsgciArPSAxKVxuICAgICAgaWYgKHQgPT09IG5bcl1bMF0pIHtcbiAgICAgICAgbi5zcGxpY2UociwgMSksIHRoaXMubGlzdGVuZXJzQ291bnQgLT0gMTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgbmV3IGV2ZW50IGxpc3RlbmVyIGZvciBhbGwgZXZlbnRzLlxuICAgKiBAcGFyYW0gbGlzdGVuZXIgLSBldmVudCBsaXN0ZW5lci5cbiAgICogQHJldHVybnMgRnVuY3Rpb24gdG8gcmVtb3ZlIGV2ZW50IGxpc3RlbmVyLlxuICAgKi9cbiAgc3Vic2NyaWJlKGUpIHtcbiAgICByZXR1cm4gdGhpcy5zdWJzY3JpYmVMaXN0ZW5lcnMucHVzaChlKSwgKCkgPT4gdGhpcy51bnN1YnNjcmliZShlKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBnbG9iYWwgZXZlbnQgbGlzdGVuZXIuIEluIGNhc2UsIHNwZWNpZmllZCBsaXN0ZW5lciB3YXMgYm91bmQgc2V2ZXJhbCB0aW1lcywgaXQgcmVtb3Zlc1xuICAgKiBvbmx5IGEgc2luZ2xlIG9uZS5cbiAgICogQHBhcmFtIGxpc3RlbmVyIC0gZXZlbnQgbGlzdGVuZXIuXG4gICAqL1xuICB1bnN1YnNjcmliZShlKSB7XG4gICAgZm9yIChsZXQgdCA9IDA7IHQgPCB0aGlzLnN1YnNjcmliZUxpc3RlbmVycy5sZW5ndGg7IHQgKz0gMSlcbiAgICAgIGlmICh0aGlzLnN1YnNjcmliZUxpc3RlbmVyc1t0XSA9PT0gZSkge1xuICAgICAgICB0aGlzLnN1YnNjcmliZUxpc3RlbmVycy5zcGxpY2UodCwgMSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gRyhzLCBlLCB0KSB7XG4gIHJldHVybiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihzLCBlLCB0KSwgKCkgPT4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIocywgZSwgdCk7XG59XG5mdW5jdGlvbiBKKC4uLnMpIHtcbiAgbGV0IGUgPSAhMTtcbiAgY29uc3QgdCA9IHMuZmxhdCgxKTtcbiAgcmV0dXJuIFtcbiAgICAobikgPT4gIWUgJiYgdC5wdXNoKG4pLFxuICAgICgpID0+IHtcbiAgICAgIGUgfHwgKGUgPSAhMCwgdC5mb3JFYWNoKChuKSA9PiBuKCkpKTtcbiAgICB9LFxuICAgIGVcbiAgXTtcbn1cbmNsYXNzIFYgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIG4pIHtcbiAgICBzdXBlcih0LCB7IGNhdXNlOiBuIH0pLCB0aGlzLnR5cGUgPSBlLCBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgVi5wcm90b3R5cGUpO1xuICB9XG59XG5mdW5jdGlvbiBmKHMsIGUsIHQpIHtcbiAgcmV0dXJuIG5ldyBWKHMsIGUsIHQpO1xufVxuY29uc3QgamUgPSBcIkVSUl9NRVRIT0RfVU5TVVBQT1JURURcIiwgemUgPSBcIkVSUl9NRVRIT0RfUEFSQU1FVEVSX1VOU1VQUE9SVEVEXCIsIEZlID0gXCJFUlJfVU5LTk9XTl9FTlZcIiwgSmUgPSBcIkVSUl9JTlZPS0VfQ1VTVE9NX01FVEhPRF9SRVNQT05TRVwiLCBRZSA9IFwiRVJSX1RJTUVEX09VVFwiLCBZZSA9IFwiRVJSX1VORVhQRUNURURfVFlQRVwiLCBjZSA9IFwiRVJSX1BBUlNFXCIsIFplID0gXCJFUlJfTkFWSUdBVElPTl9MSVNUX0VNUFRZXCIsIEtlID0gXCJFUlJfTkFWSUdBVElPTl9DVVJTT1JfSU5WQUxJRFwiLCBYdCA9IFwiRVJSX05BVklHQVRJT05fSVRFTV9JTlZBTElEXCIsIGVzID0gXCJFUlJfU1NSX0lOSVRcIiwgWGUgPSBcIkVSUl9JTlZBTElEX1BBVEhfQkFTRVwiO1xuZnVuY3Rpb24gRSgpIHtcbiAgcmV0dXJuIGYoWWUsIFwiVmFsdWUgaGFzIHVuZXhwZWN0ZWQgdHlwZVwiKTtcbn1cbmNsYXNzIEQge1xuICBjb25zdHJ1Y3RvcihlLCB0LCBuKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBlLCB0aGlzLmlzT3B0aW9uYWwgPSB0LCB0aGlzLnR5cGUgPSBuO1xuICB9XG4gIC8qKlxuICAgKiBBdHRlbXB0cyB0byBwYXJzZSBwYXNzZWQgdmFsdWVcbiAgICogQHBhcmFtIHZhbHVlIC0gdmFsdWUgdG8gcGFyc2UuXG4gICAqIEB0aHJvd3Mge1NES0Vycm9yfSBFUlJfUEFSU0VcbiAgICogQHNlZSBFUlJfUEFSU0VcbiAgICovXG4gIHBhcnNlKGUpIHtcbiAgICBpZiAoISh0aGlzLmlzT3B0aW9uYWwgJiYgZSA9PT0gdm9pZCAwKSlcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlcihlKTtcbiAgICAgIH0gY2F0Y2ggKHQpIHtcbiAgICAgICAgdGhyb3cgZihcbiAgICAgICAgICBjZSxcbiAgICAgICAgICBgVW5hYmxlIHRvIHBhcnNlIHZhbHVlJHt0aGlzLnR5cGUgPyBgIGFzICR7dGhpcy50eXBlfWAgOiBcIlwifWAsXG4gICAgICAgICAgdFxuICAgICAgICApO1xuICAgICAgfVxuICB9XG4gIG9wdGlvbmFsKCkge1xuICAgIHJldHVybiB0aGlzLmlzT3B0aW9uYWwgPSAhMCwgdGhpcztcbiAgfVxufVxuZnVuY3Rpb24gUyhzLCBlKSB7XG4gIHJldHVybiAoKSA9PiBuZXcgRChzLCAhMSwgZSk7XG59XG5jb25zdCBiID0gUygocykgPT4ge1xuICBpZiAodHlwZW9mIHMgPT0gXCJib29sZWFuXCIpXG4gICAgcmV0dXJuIHM7XG4gIGNvbnN0IGUgPSBTdHJpbmcocyk7XG4gIGlmIChlID09PSBcIjFcIiB8fCBlID09PSBcInRydWVcIilcbiAgICByZXR1cm4gITA7XG4gIGlmIChlID09PSBcIjBcIiB8fCBlID09PSBcImZhbHNlXCIpXG4gICAgcmV0dXJuICExO1xuICB0aHJvdyBFKCk7XG59LCBcImJvb2xlYW5cIik7XG5mdW5jdGlvbiBwZShzLCBlKSB7XG4gIGNvbnN0IHQgPSB7fTtcbiAgZm9yIChjb25zdCBuIGluIHMpIHtcbiAgICBjb25zdCByID0gc1tuXTtcbiAgICBpZiAoIXIpXG4gICAgICBjb250aW51ZTtcbiAgICBsZXQgaSwgbztcbiAgICBpZiAodHlwZW9mIHIgPT0gXCJmdW5jdGlvblwiIHx8IFwicGFyc2VcIiBpbiByKVxuICAgICAgaSA9IG4sIG8gPSB0eXBlb2YgciA9PSBcImZ1bmN0aW9uXCIgPyByIDogci5wYXJzZS5iaW5kKHIpO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgeyB0eXBlOiBhIH0gPSByO1xuICAgICAgaSA9IHIuZnJvbSB8fCBuLCBvID0gdHlwZW9mIGEgPT0gXCJmdW5jdGlvblwiID8gYSA6IGEucGFyc2UuYmluZChhKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGEgPSBvKGUoaSkpO1xuICAgICAgYSAhPT0gdm9pZCAwICYmICh0W25dID0gYSk7XG4gICAgfSBjYXRjaCAoYSkge1xuICAgICAgdGhyb3cgZihjZSwgYFVuYWJsZSB0byBwYXJzZSBmaWVsZCBcIiR7bn1cImAsIGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIGhlKHMpIHtcbiAgbGV0IGUgPSBzO1xuICBpZiAodHlwZW9mIGUgPT0gXCJzdHJpbmdcIiAmJiAoZSA9IEpTT04ucGFyc2UoZSkpLCB0eXBlb2YgZSAhPSBcIm9iamVjdFwiIHx8IGUgPT09IG51bGwgfHwgQXJyYXkuaXNBcnJheShlKSlcbiAgICB0aHJvdyBFKCk7XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gZyhzLCBlKSB7XG4gIHJldHVybiBuZXcgRCgodCkgPT4ge1xuICAgIGNvbnN0IG4gPSBoZSh0KTtcbiAgICByZXR1cm4gcGUocywgKHIpID0+IG5bcl0pO1xuICB9LCAhMSwgZSk7XG59XG5jb25zdCB5ID0gUygocykgPT4ge1xuICBpZiAodHlwZW9mIHMgPT0gXCJudW1iZXJcIilcbiAgICByZXR1cm4gcztcbiAgaWYgKHR5cGVvZiBzID09IFwic3RyaW5nXCIpIHtcbiAgICBjb25zdCBlID0gTnVtYmVyKHMpO1xuICAgIGlmICghTnVtYmVyLmlzTmFOKGUpKVxuICAgICAgcmV0dXJuIGU7XG4gIH1cbiAgdGhyb3cgRSgpO1xufSwgXCJudW1iZXJcIiksIGggPSBTKChzKSA9PiB7XG4gIGlmICh0eXBlb2YgcyA9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBzID09IFwibnVtYmVyXCIpXG4gICAgcmV0dXJuIHMudG9TdHJpbmcoKTtcbiAgdGhyb3cgRSgpO1xufSwgXCJzdHJpbmdcIik7XG5mdW5jdGlvbiB1ZShzKSB7XG4gIHJldHVybiBnKHtcbiAgICBldmVudFR5cGU6IGgoKSxcbiAgICBldmVudERhdGE6IChlKSA9PiBlXG4gIH0pLnBhcnNlKHMpO1xufVxuZnVuY3Rpb24gZXQoKSB7XG4gIFtcIlRlbGVncmFtR2FtZVByb3h5X3JlY2VpdmVFdmVudFwiLCBcIlRlbGVncmFtR2FtZVByb3h5XCIsIFwiVGVsZWdyYW1cIl0uZm9yRWFjaCgocykgPT4ge1xuICAgIGRlbGV0ZSB3aW5kb3dbc107XG4gIH0pO1xufVxuZnVuY3Rpb24gaihzLCBlKSB7XG4gIHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBNZXNzYWdlRXZlbnQoXCJtZXNzYWdlXCIsIHtcbiAgICBkYXRhOiBKU09OLnN0cmluZ2lmeSh7IGV2ZW50VHlwZTogcywgZXZlbnREYXRhOiBlIH0pLFxuICAgIC8vIFdlIHNwZWNpZnkgd2luZG93LnBhcmVudCB0byBpbWl0YXRlIHRoZSBjYXNlLCB0aGUgcGFyZW50IGlmcmFtZSBzZW50IHVzIHRoaXMgZXZlbnQuXG4gICAgc291cmNlOiB3aW5kb3cucGFyZW50XG4gIH0pKTtcbn1cbmZ1bmN0aW9uIHR0KCkge1xuICBbXG4gICAgW1wiVGVsZWdyYW1HYW1lUHJveHlfcmVjZWl2ZUV2ZW50XCJdLFxuICAgIC8vIFdpbmRvd3MgUGhvbmUuXG4gICAgW1wiVGVsZWdyYW1HYW1lUHJveHlcIiwgXCJyZWNlaXZlRXZlbnRcIl0sXG4gICAgLy8gRGVza3RvcC5cbiAgICBbXCJUZWxlZ3JhbVwiLCBcIldlYlZpZXdcIiwgXCJyZWNlaXZlRXZlbnRcIl1cbiAgICAvLyBBbmRyb2lkIGFuZCBpT1MuXG4gIF0uZm9yRWFjaCgocykgPT4ge1xuICAgIGxldCBlID0gd2luZG93O1xuICAgIHMuZm9yRWFjaCgodCwgbiwgcikgPT4ge1xuICAgICAgaWYgKG4gPT09IHIubGVuZ3RoIC0gMSkge1xuICAgICAgICBlW3RdID0gajtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdCBpbiBlIHx8IChlW3RdID0ge30pLCBlID0gZVt0XTtcbiAgICB9KTtcbiAgfSk7XG59XG5jb25zdCBzdCA9IHtcbiAgY2xpcGJvYXJkX3RleHRfcmVjZWl2ZWQ6IGcoe1xuICAgIHJlcV9pZDogaCgpLFxuICAgIGRhdGE6IChzKSA9PiBzID09PSBudWxsID8gcyA6IGgoKS5vcHRpb25hbCgpLnBhcnNlKHMpXG4gIH0pLFxuICBjdXN0b21fbWV0aG9kX2ludm9rZWQ6IGcoe1xuICAgIHJlcV9pZDogaCgpLFxuICAgIHJlc3VsdDogKHMpID0+IHMsXG4gICAgZXJyb3I6IGgoKS5vcHRpb25hbCgpXG4gIH0pLFxuICBwb3B1cF9jbG9zZWQ6IHtcbiAgICBwYXJzZShzKSB7XG4gICAgICByZXR1cm4gZyh7XG4gICAgICAgIGJ1dHRvbl9pZDogKGUpID0+IGUgPT0gbnVsbCA/IHZvaWQgMCA6IGgoKS5wYXJzZShlKVxuICAgICAgfSkucGFyc2UocyA/PyB7fSk7XG4gICAgfVxuICB9LFxuICB2aWV3cG9ydF9jaGFuZ2VkOiBnKHtcbiAgICBoZWlnaHQ6IHkoKSxcbiAgICB3aWR0aDogKHMpID0+IHMgPT0gbnVsbCA/IHdpbmRvdy5pbm5lcldpZHRoIDogeSgpLnBhcnNlKHMpLFxuICAgIGlzX3N0YXRlX3N0YWJsZTogYigpLFxuICAgIGlzX2V4cGFuZGVkOiBiKClcbiAgfSlcbn07XG5mdW5jdGlvbiBudCgpIHtcbiAgY29uc3QgcyA9IG5ldyBSKCksIGUgPSBuZXcgUigpO1xuICBlLnN1YnNjcmliZSgobikgPT4ge1xuICAgIHMuZW1pdChcImV2ZW50XCIsIHsgbmFtZTogbi5ldmVudCwgcGF5bG9hZDogbi5hcmdzWzBdIH0pO1xuICB9KSwgdHQoKTtcbiAgY29uc3QgWywgdF0gPSBKKFxuICAgIC8vIERvbid0IGZvcmdldCB0byByZW1vdmUgY3JlYXRlZCBoYW5kbGVycy5cbiAgICBldCxcbiAgICAvLyBBZGQgXCJyZXNpemVcIiBldmVudCBsaXN0ZW5lciB0byBtYWtlIHN1cmUsIHdlIGFsd2F5cyBoYXZlIGZyZXNoIHZpZXdwb3J0IGluZm9ybWF0aW9uLlxuICAgIC8vIERlc2t0b3AgdmVyc2lvbiBvZiBUZWxlZ3JhbSBpcyBzb21ldGltZXMgbm90IHNlbmRpbmcgdGhlIHZpZXdwb3J0X2NoYW5nZWRcbiAgICAvLyBldmVudC4gRm9yIGV4YW1wbGUsIHdoZW4gdGhlIE1haW5CdXR0b24gaXMgc2hvd24uIFRoYXQncyB3aHkgd2Ugc2hvdWxkXG4gICAgLy8gYWRkIG91ciBvd24gbGlzdGVuZXIgdG8gbWFrZSBzdXJlLCB2aWV3cG9ydCBpbmZvcm1hdGlvbiBpcyBhbHdheXMgZnJlc2guXG4gICAgLy8gSXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9UZWxlZ3JhbS1NaW5pLUFwcHMvdGVsZWdyYW0tYXBwcy9pc3N1ZXMvMTBcbiAgICBHKFwicmVzaXplXCIsICgpID0+IHtcbiAgICAgIGUuZW1pdChcInZpZXdwb3J0X2NoYW5nZWRcIiwge1xuICAgICAgICB3aWR0aDogd2luZG93LmlubmVyV2lkdGgsXG4gICAgICAgIGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0LFxuICAgICAgICBpc19zdGF0ZV9zdGFibGU6ICEwLFxuICAgICAgICBpc19leHBhbmRlZDogITBcbiAgICAgIH0pO1xuICAgIH0pLFxuICAgIC8vIEFkZCBsaXN0ZW5lciwgd2hpY2ggaGFuZGxlcyBldmVudHMgc2VudCBmcm9tIHRoZSBUZWxlZ3JhbSB3ZWIgYXBwbGljYXRpb24gYW5kIGFsc28gZXZlbnRzXG4gICAgLy8gZ2VuZXJhdGVkIGJ5IHRoZSBsb2NhbCBlbWl0RXZlbnQgZnVuY3Rpb24uXG4gICAgRyhcIm1lc3NhZ2VcIiwgKG4pID0+IHtcbiAgICAgIGlmIChuLnNvdXJjZSAhPT0gd2luZG93LnBhcmVudClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgbGV0IHI7XG4gICAgICB0cnkge1xuICAgICAgICByID0gdWUobi5kYXRhKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB7IGV2ZW50VHlwZTogaSwgZXZlbnREYXRhOiBvIH0gPSByLCBhID0gc3RbaV07XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBwID0gYSA/IGEucGFyc2UobykgOiBvO1xuICAgICAgICBlLmVtaXQoLi4ucCA/IFtpLCBwXSA6IFtpXSk7XG4gICAgICB9IGNhdGNoIChwKSB7XG4gICAgICAgIEYuZXJyb3IoXG4gICAgICAgICAgYEFuIGVycm9yIG9jY3VycmVkIHByb2Nlc3NpbmcgdGhlIFwiJHtpfVwiIGV2ZW50IGZyb20gdGhlIFRlbGVncmFtIGFwcGxpY2F0aW9uLlxuUGxlYXNlLCBmaWxlIGFuIGlzc3VlIGhlcmU6XG5odHRwczovL2dpdGh1Yi5jb20vVGVsZWdyYW0tTWluaS1BcHBzL3RlbGVncmFtLWFwcHMvaXNzdWVzL25ldy9jaG9vc2VgLFxuICAgICAgICAgIHIsXG4gICAgICAgICAgcFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pLFxuICAgIC8vIENsZWFyIGVtaXR0ZXJzLlxuICAgICgpID0+IHMuY2xlYXIoKSxcbiAgICAoKSA9PiBlLmNsZWFyKClcbiAgKTtcbiAgcmV0dXJuIFt7XG4gICAgb246IGUub24uYmluZChlKSxcbiAgICBvZmY6IGUub2ZmLmJpbmQoZSksXG4gICAgc3Vic2NyaWJlKG4pIHtcbiAgICAgIHJldHVybiBzLm9uKFwiZXZlbnRcIiwgbik7XG4gICAgfSxcbiAgICB1bnN1YnNjcmliZShuKSB7XG4gICAgICBzLm9mZihcImV2ZW50XCIsIG4pO1xuICAgIH0sXG4gICAgZ2V0IGNvdW50KCkge1xuICAgICAgcmV0dXJuIGUuY291bnQgKyBzLmNvdW50O1xuICAgIH1cbiAgfSwgdF07XG59XG5jb25zdCBbcnQsIGl0XSA9IG9lKFxuICAocykgPT4ge1xuICAgIGNvbnN0IFtlLCB0XSA9IG50KCksIG4gPSBlLm9mZi5iaW5kKGUpO1xuICAgIHJldHVybiBlLm9mZiA9IChyLCBpKSA9PiB7XG4gICAgICBjb25zdCB7IGNvdW50OiBvIH0gPSBlO1xuICAgICAgbihyLCBpKSwgbyAmJiAhZS5jb3VudCAmJiBzKCk7XG4gICAgfSwgW2UsIHRdO1xuICB9LFxuICAoWywgc10pID0+IHMoKVxuKTtcbmZ1bmN0aW9uIE0oKSB7XG4gIHJldHVybiBydCgpWzBdO1xufVxuZnVuY3Rpb24gQihzLCBlKSB7XG4gIE0oKS5vZmYocywgZSk7XG59XG5mdW5jdGlvbiB3KHMsIGUsIHQpIHtcbiAgcmV0dXJuIE0oKS5vbihzLCBlLCB0KTtcbn1cbmZ1bmN0aW9uIGsocykge1xuICByZXR1cm4gdHlwZW9mIHMgPT0gXCJvYmplY3RcIiAmJiBzICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KHMpO1xufVxuZnVuY3Rpb24gb3QocywgZSkge1xuICBjb25zdCB0ID0gcy5zcGxpdChcIi5cIiksIG4gPSBlLnNwbGl0KFwiLlwiKSwgciA9IE1hdGgubWF4KHQubGVuZ3RoLCBuLmxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcjsgaSArPSAxKSB7XG4gICAgY29uc3QgbyA9IHBhcnNlSW50KHRbaV0gfHwgXCIwXCIsIDEwKSwgYSA9IHBhcnNlSW50KG5baV0gfHwgXCIwXCIsIDEwKTtcbiAgICBpZiAobyAhPT0gYSlcbiAgICAgIHJldHVybiBvID4gYSA/IDEgOiAtMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIF8ocywgZSkge1xuICByZXR1cm4gb3QocywgZSkgPD0gMDtcbn1cbmZ1bmN0aW9uIHYocywgZSwgdCkge1xuICBpZiAodHlwZW9mIHQgPT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChzID09PSBcIndlYl9hcHBfb3Blbl9saW5rXCIpIHtcbiAgICAgIGlmIChlID09PSBcInRyeV9pbnN0YW50X3ZpZXdcIilcbiAgICAgICAgcmV0dXJuIF8oXCI2LjRcIiwgdCk7XG4gICAgICBpZiAoZSA9PT0gXCJ0cnlfYnJvd3NlclwiKVxuICAgICAgICByZXR1cm4gXyhcIjcuNlwiLCB0KTtcbiAgICB9XG4gICAgaWYgKHMgPT09IFwid2ViX2FwcF9zZXRfaGVhZGVyX2NvbG9yXCIgJiYgZSA9PT0gXCJjb2xvclwiKVxuICAgICAgcmV0dXJuIF8oXCI2LjlcIiwgdCk7XG4gICAgaWYgKHMgPT09IFwid2ViX2FwcF9jbG9zZVwiICYmIGUgPT09IFwicmV0dXJuX2JhY2tcIilcbiAgICAgIHJldHVybiBfKFwiNy42XCIsIHQpO1xuICB9XG4gIHN3aXRjaCAocykge1xuICAgIGNhc2UgXCJ3ZWJfYXBwX29wZW5fdGdfbGlua1wiOlxuICAgIGNhc2UgXCJ3ZWJfYXBwX29wZW5faW52b2ljZVwiOlxuICAgIGNhc2UgXCJ3ZWJfYXBwX3NldHVwX2JhY2tfYnV0dG9uXCI6XG4gICAgY2FzZSBcIndlYl9hcHBfc2V0X2JhY2tncm91bmRfY29sb3JcIjpcbiAgICBjYXNlIFwid2ViX2FwcF9zZXRfaGVhZGVyX2NvbG9yXCI6XG4gICAgY2FzZSBcIndlYl9hcHBfdHJpZ2dlcl9oYXB0aWNfZmVlZGJhY2tcIjpcbiAgICAgIHJldHVybiBfKFwiNi4xXCIsIGUpO1xuICAgIGNhc2UgXCJ3ZWJfYXBwX29wZW5fcG9wdXBcIjpcbiAgICAgIHJldHVybiBfKFwiNi4yXCIsIGUpO1xuICAgIGNhc2UgXCJ3ZWJfYXBwX2Nsb3NlX3NjYW5fcXJfcG9wdXBcIjpcbiAgICBjYXNlIFwid2ViX2FwcF9vcGVuX3NjYW5fcXJfcG9wdXBcIjpcbiAgICBjYXNlIFwid2ViX2FwcF9yZWFkX3RleHRfZnJvbV9jbGlwYm9hcmRcIjpcbiAgICAgIHJldHVybiBfKFwiNi40XCIsIGUpO1xuICAgIGNhc2UgXCJ3ZWJfYXBwX3N3aXRjaF9pbmxpbmVfcXVlcnlcIjpcbiAgICAgIHJldHVybiBfKFwiNi43XCIsIGUpO1xuICAgIGNhc2UgXCJ3ZWJfYXBwX2ludm9rZV9jdXN0b21fbWV0aG9kXCI6XG4gICAgY2FzZSBcIndlYl9hcHBfcmVxdWVzdF93cml0ZV9hY2Nlc3NcIjpcbiAgICBjYXNlIFwid2ViX2FwcF9yZXF1ZXN0X3Bob25lXCI6XG4gICAgICByZXR1cm4gXyhcIjYuOVwiLCBlKTtcbiAgICBjYXNlIFwid2ViX2FwcF9zZXR1cF9zZXR0aW5nc19idXR0b25cIjpcbiAgICAgIHJldHVybiBfKFwiNi4xMFwiLCBlKTtcbiAgICBjYXNlIFwid2ViX2FwcF9iaW9tZXRyeV9nZXRfaW5mb1wiOlxuICAgIGNhc2UgXCJ3ZWJfYXBwX2Jpb21ldHJ5X29wZW5fc2V0dGluZ3NcIjpcbiAgICBjYXNlIFwid2ViX2FwcF9iaW9tZXRyeV9yZXF1ZXN0X2FjY2Vzc1wiOlxuICAgIGNhc2UgXCJ3ZWJfYXBwX2Jpb21ldHJ5X3JlcXVlc3RfYXV0aFwiOlxuICAgIGNhc2UgXCJ3ZWJfYXBwX2Jpb21ldHJ5X3VwZGF0ZV90b2tlblwiOlxuICAgICAgcmV0dXJuIF8oXCI3LjJcIiwgZSk7XG4gICAgY2FzZSBcIndlYl9hcHBfc2V0dXBfc3dpcGVfYmVoYXZpb3JcIjpcbiAgICAgIHJldHVybiBfKFwiNy43XCIsIGUpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gW1xuICAgICAgICBcImlmcmFtZV9yZWFkeVwiLFxuICAgICAgICBcImlmcmFtZV93aWxsX3JlbG9hZFwiLFxuICAgICAgICBcIndlYl9hcHBfY2xvc2VcIixcbiAgICAgICAgXCJ3ZWJfYXBwX2RhdGFfc2VuZFwiLFxuICAgICAgICBcIndlYl9hcHBfZXhwYW5kXCIsXG4gICAgICAgIFwid2ViX2FwcF9vcGVuX2xpbmtcIixcbiAgICAgICAgXCJ3ZWJfYXBwX3JlYWR5XCIsXG4gICAgICAgIFwid2ViX2FwcF9yZXF1ZXN0X3RoZW1lXCIsXG4gICAgICAgIFwid2ViX2FwcF9yZXF1ZXN0X3ZpZXdwb3J0XCIsXG4gICAgICAgIFwid2ViX2FwcF9zZXR1cF9tYWluX2J1dHRvblwiLFxuICAgICAgICBcIndlYl9hcHBfc2V0dXBfY2xvc2luZ19iZWhhdmlvclwiXG4gICAgICBdLmluY2x1ZGVzKHMpO1xuICB9XG59XG5mdW5jdGlvbiBsZShzKSB7XG4gIHJldHVybiBcImV4dGVybmFsXCIgaW4gcyAmJiBrKHMuZXh0ZXJuYWwpICYmIFwibm90aWZ5XCIgaW4gcy5leHRlcm5hbCAmJiB0eXBlb2Ygcy5leHRlcm5hbC5ub3RpZnkgPT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24gZGUocykge1xuICByZXR1cm4gXCJUZWxlZ3JhbVdlYnZpZXdQcm94eVwiIGluIHMgJiYgayhzLlRlbGVncmFtV2Vidmlld1Byb3h5KSAmJiBcInBvc3RFdmVudFwiIGluIHMuVGVsZWdyYW1XZWJ2aWV3UHJveHkgJiYgdHlwZW9mIHMuVGVsZWdyYW1XZWJ2aWV3UHJveHkucG9zdEV2ZW50ID09IFwiZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIF9lKCkge1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cuc2VsZiAhPT0gd2luZG93LnRvcDtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuICEwO1xuICB9XG59XG5jb25zdCBhdCA9IFwiaHR0cHM6Ly93ZWIudGVsZWdyYW0ub3JnXCI7XG5sZXQgZmUgPSBhdDtcbmZ1bmN0aW9uIHRzKHMpIHtcbiAgZmUgPSBzO1xufVxuZnVuY3Rpb24gY3QoKSB7XG4gIHJldHVybiBmZTtcbn1cbmZ1bmN0aW9uIEEocywgZSwgdCkge1xuICBsZXQgbiA9IHt9LCByO1xuICBpZiAoIWUgJiYgIXQgPyBuID0ge30gOiBlICYmIHQgPyAobiA9IHQsIHIgPSBlKSA6IGUgJiYgKFwidGFyZ2V0T3JpZ2luXCIgaW4gZSA/IG4gPSBlIDogciA9IGUpLCBHZShcIlBvc3RpbmcgZXZlbnQ6XCIsIHIgPyB7IGV2ZW50OiBzLCBkYXRhOiByIH0gOiB7IGV2ZW50OiBzIH0pLCBfZSgpKVxuICAgIHJldHVybiB3aW5kb3cucGFyZW50LnBvc3RNZXNzYWdlKFxuICAgICAgSlNPTi5zdHJpbmdpZnkoeyBldmVudFR5cGU6IHMsIGV2ZW50RGF0YTogciB9KSxcbiAgICAgIG4udGFyZ2V0T3JpZ2luIHx8IGN0KClcbiAgICApO1xuICBpZiAobGUod2luZG93KSkge1xuICAgIHdpbmRvdy5leHRlcm5hbC5ub3RpZnkoSlNPTi5zdHJpbmdpZnkoeyBldmVudFR5cGU6IHMsIGV2ZW50RGF0YTogciB9KSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChkZSh3aW5kb3cpKSB7XG4gICAgd2luZG93LlRlbGVncmFtV2Vidmlld1Byb3h5LnBvc3RFdmVudChzLCBKU09OLnN0cmluZ2lmeShyKSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRocm93IGYoXG4gICAgRmUsXG4gICAgXCJVbmFibGUgdG8gZGV0ZXJtaW5lIGN1cnJlbnQgZW52aXJvbm1lbnQgYW5kIHBvc3NpYmxlIHdheSB0byBzZW5kIGV2ZW50LiBZb3UgYXJlIHByb2JhYmx5IHRyeWluZyB0byB1c2UgTWluaSBBcHBzIG1ldGhvZCBvdXRzaWRlIHRoZSBUZWxlZ3JhbSBhcHBsaWNhdGlvbiBlbnZpcm9ubWVudC5cIlxuICApO1xufVxuZnVuY3Rpb24gcHQocykge1xuICByZXR1cm4gKGUsIHQpID0+IHtcbiAgICBpZiAoIXYoZSwgcykpXG4gICAgICB0aHJvdyBmKGplLCBgTWV0aG9kIFwiJHtlfVwiIGlzIHVuc3VwcG9ydGVkIGluIE1pbmkgQXBwcyB2ZXJzaW9uICR7c31gKTtcbiAgICBpZiAoayh0KSAmJiBlID09PSBcIndlYl9hcHBfc2V0X2hlYWRlcl9jb2xvclwiICYmIFwiY29sb3JcIiBpbiB0ICYmICF2KGUsIFwiY29sb3JcIiwgcykpXG4gICAgICB0aHJvdyBmKFxuICAgICAgICB6ZSxcbiAgICAgICAgYFBhcmFtZXRlciBcImNvbG9yXCIgb2YgXCIke2V9XCIgbWV0aG9kIGlzIHVuc3VwcG9ydGVkIGluIE1pbmkgQXBwcyB2ZXJzaW9uICR7c31gXG4gICAgICApO1xuICAgIHJldHVybiBBKGUsIHQpO1xuICB9O1xufVxuZnVuY3Rpb24gZ2Uocykge1xuICByZXR1cm4gKHsgcmVxX2lkOiBlIH0pID0+IGUgPT09IHM7XG59XG5mdW5jdGlvbiB3ZShzKSB7XG4gIHJldHVybiBmKFFlLCBgVGltZW91dCByZWFjaGVkOiAke3N9bXNgKTtcbn1cbmZ1bmN0aW9uIGJlKHMsIGUpIHtcbiAgcmV0dXJuIFByb21pc2UucmFjZShbXG4gICAgdHlwZW9mIHMgPT0gXCJmdW5jdGlvblwiID8gcygpIDogcyxcbiAgICBuZXcgUHJvbWlzZSgodCwgbikgPT4ge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIG4od2UoZSkpO1xuICAgICAgfSwgZSk7XG4gICAgfSlcbiAgXSk7XG59XG5hc3luYyBmdW5jdGlvbiBkKHMpIHtcbiAgbGV0IGU7XG4gIGNvbnN0IHQgPSBuZXcgUHJvbWlzZSgoYSkgPT4gZSA9IGEpLCB7IGV2ZW50OiBuLCBjYXB0dXJlOiByLCB0aW1lb3V0OiBpIH0gPSBzLCBbLCBvXSA9IEooXG4gICAgLy8gV2UgbmVlZCB0byBpdGVyYXRlIG92ZXIgYWxsIHRyYWNrZWQgZXZlbnRzLCBhbmQgY3JlYXRlIHRoZWlyIGV2ZW50IGxpc3RlbmVycy5cbiAgICAoQXJyYXkuaXNBcnJheShuKSA/IG4gOiBbbl0pLm1hcCgoYSkgPT4gdyhhLCAocCkgPT4ge1xuICAgICAgKCFyIHx8IChBcnJheS5pc0FycmF5KG4pID8gcih7XG4gICAgICAgIGV2ZW50OiBhLFxuICAgICAgICBwYXlsb2FkOiBwXG4gICAgICB9KSA6IHIocCkpKSAmJiBlKHApO1xuICAgIH0pKVxuICApO1xuICB0cnkge1xuICAgIHJldHVybiAocy5wb3N0RXZlbnQgfHwgQSkocy5tZXRob2QsIHMucGFyYW1zKSwgYXdhaXQgKGkgPyBiZSh0LCBpKSA6IHQpO1xuICB9IGZpbmFsbHkge1xuICAgIG8oKTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gQyhzLCBlLCB0LCBuID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHJlc3VsdDogcixcbiAgICBlcnJvcjogaVxuICB9ID0gYXdhaXQgZCh7XG4gICAgLi4ubixcbiAgICBtZXRob2Q6IFwid2ViX2FwcF9pbnZva2VfY3VzdG9tX21ldGhvZFwiLFxuICAgIGV2ZW50OiBcImN1c3RvbV9tZXRob2RfaW52b2tlZFwiLFxuICAgIHBhcmFtczoge1xuICAgICAgbWV0aG9kOiBzLFxuICAgICAgcGFyYW1zOiBlLFxuICAgICAgcmVxX2lkOiB0XG4gICAgfSxcbiAgICBjYXB0dXJlOiBnZSh0KVxuICB9KTtcbiAgaWYgKGkpXG4gICAgdGhyb3cgZihKZSwgaSk7XG4gIHJldHVybiByO1xufVxuZnVuY3Rpb24geiguLi5zKSB7XG4gIHJldHVybiBzLm1hcCgoZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgZSA9PSBcInN0cmluZ1wiKVxuICAgICAgcmV0dXJuIGU7XG4gICAgaWYgKGsoZSkpXG4gICAgICByZXR1cm4geihPYmplY3QuZW50cmllcyhlKS5tYXAoKHQpID0+IHRbMV0gJiYgdFswXSkpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGUpKVxuICAgICAgcmV0dXJuIHooLi4uZSk7XG4gIH0pLmZpbHRlcihCb29sZWFuKS5qb2luKFwiIFwiKTtcbn1cbmZ1bmN0aW9uIHNzKC4uLnMpIHtcbiAgcmV0dXJuIHMucmVkdWNlKChlLCB0KSA9PiAoayh0KSAmJiBPYmplY3QuZW50cmllcyh0KS5mb3JFYWNoKChbbiwgcl0pID0+IHtcbiAgICBjb25zdCBpID0geihlW25dLCByKTtcbiAgICBpLmxlbmd0aCAmJiAoZVtuXSA9IGkpO1xuICB9KSwgZSksIHt9KTtcbn1cbmZ1bmN0aW9uIFEocykge1xuICByZXR1cm4gL14jW1xcZGEtZl17Nn0kL2kudGVzdChzKTtcbn1cbmZ1bmN0aW9uIGh0KHMpIHtcbiAgcmV0dXJuIC9eI1tcXGRhLWZdezN9JC9pLnRlc3Qocyk7XG59XG5mdW5jdGlvbiBtZShzKSB7XG4gIGNvbnN0IGUgPSBzLnJlcGxhY2UoL1xccy9nLCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuICBpZiAoUShlKSlcbiAgICByZXR1cm4gZTtcbiAgaWYgKGh0KGUpKSB7XG4gICAgbGV0IG4gPSBcIiNcIjtcbiAgICBmb3IgKGxldCByID0gMDsgciA8IDM7IHIgKz0gMSlcbiAgICAgIG4gKz0gZVsxICsgcl0ucmVwZWF0KDIpO1xuICAgIHJldHVybiBuO1xuICB9XG4gIGNvbnN0IHQgPSBlLm1hdGNoKC9ecmdiXFwoKFxcZHsxLDN9KSwoXFxkezEsM30pLChcXGR7MSwzfSlcXCkkLykgfHwgZS5tYXRjaCgvXnJnYmFcXCgoXFxkezEsM30pLChcXGR7MSwzfSksKFxcZHsxLDN9KSxcXGR7MSwzfVxcKSQvKTtcbiAgaWYgKCF0KVxuICAgIHRocm93IG5ldyBFcnJvcihgVmFsdWUgXCIke3N9XCIgZG9lcyBub3Qgc2F0aXNmeSBhbnkgb2Yga25vd24gUkdCIGZvcm1hdHMuYCk7XG4gIHJldHVybiB0LnNsaWNlKDEpLnJlZHVjZSgobiwgcikgPT4ge1xuICAgIGNvbnN0IGkgPSBwYXJzZUludChyLCAxMCkudG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBuICsgKGkubGVuZ3RoID09PSAxID8gXCIwXCIgOiBcIlwiKSArIGk7XG4gIH0sIFwiI1wiKTtcbn1cbmZ1bmN0aW9uIHllKHMpIHtcbiAgY29uc3QgZSA9IG1lKHMpO1xuICByZXR1cm4gTWF0aC5zcXJ0KFxuICAgIFswLjI5OSwgMC41ODcsIDAuMTE0XS5yZWR1Y2UoKHQsIG4sIHIpID0+IHtcbiAgICAgIGNvbnN0IGkgPSBwYXJzZUludChlLnNsaWNlKDEgKyByICogMiwgMSArIChyICsgMSkgKiAyKSwgMTYpO1xuICAgICAgcmV0dXJuIHQgKyBpICogaSAqIG47XG4gICAgfSwgMClcbiAgKSA8IDEyMDtcbn1cbmNsYXNzIHV0IHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIGModGhpcywgXCJlZVwiLCBuZXcgUigpKTtcbiAgICAvKipcbiAgICAgKiBBZGRzIG5ldyBldmVudCBsaXN0ZW5lci5cbiAgICAgKi9cbiAgICBjKHRoaXMsIFwib25cIiwgdGhpcy5lZS5vbi5iaW5kKHRoaXMuZWUpKTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGV2ZW50IGxpc3RlbmVyLlxuICAgICAqL1xuICAgIGModGhpcywgXCJvZmZcIiwgdGhpcy5lZS5vZmYuYmluZCh0aGlzLmVlKSk7XG4gICAgdGhpcy5zdGF0ZSA9IGU7XG4gIH1cbiAgLyoqXG4gICAqIENsb25lcyBjdXJyZW50IHN0YXRlIGFuZCByZXR1cm5zIGl0cyBjb3B5LlxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIHsgLi4udGhpcy5zdGF0ZSB9O1xuICB9XG4gIHNldChlLCB0KSB7XG4gICAgT2JqZWN0LmVudHJpZXModHlwZW9mIGUgPT0gXCJzdHJpbmdcIiA/IHsgW2VdOiB0IH0gOiBlKS5yZWR1Y2UoKHIsIFtpLCBvXSkgPT4gdGhpcy5zdGF0ZVtpXSA9PT0gbyB8fCBvID09PSB2b2lkIDAgPyByIDogKHRoaXMuc3RhdGVbaV0gPSBvLCB0aGlzLmVlLmVtaXQoYGNoYW5nZToke2l9YCwgbyksICEwKSwgITEpICYmIHRoaXMuZWUuZW1pdChcImNoYW5nZVwiLCB0aGlzLnN0YXRlKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB2YWx1ZSBieSBzcGVjaWZpZWQga2V5LlxuICAgKiBAcGFyYW0ga2V5IC0gc3RhdGUga2V5LlxuICAgKi9cbiAgZ2V0KGUpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZVtlXTtcbiAgfVxufVxuY2xhc3MgWSB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBjKHRoaXMsIFwic3RhdGVcIik7XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc3RhdGUgdmFsdWUuXG4gICAgICovXG4gICAgYyh0aGlzLCBcImdldFwiKTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzdGF0ZSB2YWx1ZS5cbiAgICAgKi9cbiAgICBjKHRoaXMsIFwic2V0XCIpO1xuICAgIC8qKlxuICAgICAqIENsb25lcyB0aGUgY3VycmVudCBzdGF0ZS5cbiAgICAgKi9cbiAgICBjKHRoaXMsIFwiY2xvbmVcIik7XG4gICAgdGhpcy5zdGF0ZSA9IG5ldyB1dChlKSwgdGhpcy5zZXQgPSB0aGlzLnN0YXRlLnNldC5iaW5kKHRoaXMuc3RhdGUpLCB0aGlzLmdldCA9IHRoaXMuc3RhdGUuZ2V0LmJpbmQodGhpcy5zdGF0ZSksIHRoaXMuY2xvbmUgPSB0aGlzLnN0YXRlLmNsb25lLmJpbmQodGhpcy5zdGF0ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHZlKHMsIGUpIHtcbiAgcmV0dXJuICh0KSA9PiB2KGVbdF0sIHMpO1xufVxuY2xhc3MgWiBleHRlbmRzIFkge1xuICBjb25zdHJ1Y3Rvcih0LCBuLCByKSB7XG4gICAgc3VwZXIodCk7XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgVHJ1ZSwgaWYgc3BlY2lmaWVkIG1ldGhvZCBpcyBzdXBwb3J0ZWQgYnkgdGhlIGN1cnJlbnQgY29tcG9uZW50LlxuICAgICAqL1xuICAgIGModGhpcywgXCJzdXBwb3J0c1wiKTtcbiAgICB0aGlzLnN1cHBvcnRzID0gdmUobiwgcik7XG4gIH1cbn1cbmNsYXNzIGx0IGV4dGVuZHMgWiB7XG4gIGNvbnN0cnVjdG9yKHQsIG4sIHIpIHtcbiAgICBzdXBlcih7IGlzVmlzaWJsZTogdCB9LCBuLCB7XG4gICAgICBzaG93OiBcIndlYl9hcHBfc2V0dXBfYmFja19idXR0b25cIixcbiAgICAgIGhpZGU6IFwid2ViX2FwcF9zZXR1cF9iYWNrX2J1dHRvblwiXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5ldyBldmVudCBsaXN0ZW5lci5cbiAgICAgKiBAcGFyYW0gZXZlbnQgLSBldmVudCB0byBsaXN0ZW4uXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIC0gbGlzdGVuZXIgdG8gYWRkLlxuICAgICAqL1xuICAgIGModGhpcywgXCJvblwiLCAodCwgbikgPT4gdCA9PT0gXCJjbGlja1wiID8gdyhcImJhY2tfYnV0dG9uX3ByZXNzZWRcIiwgbikgOiB0aGlzLnN0YXRlLm9uKHQsIG4pKTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBldmVudCBsaXN0ZW5lci5cbiAgICAgKiBAcGFyYW0gZXZlbnQgLSBldmVudCB0byBsaXN0ZW4uXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIC0gbGlzdGVuZXIgdG8gcmVtb3ZlLlxuICAgICAqL1xuICAgIGModGhpcywgXCJvZmZcIiwgKHQsIG4pID0+IHQgPT09IFwiY2xpY2tcIiA/IEIoXCJiYWNrX2J1dHRvbl9wcmVzc2VkXCIsIG4pIDogdGhpcy5zdGF0ZS5vZmYodCwgbikpO1xuICAgIHRoaXMucG9zdEV2ZW50ID0gcjtcbiAgfVxuICBzZXQgaXNWaXNpYmxlKHQpIHtcbiAgICB0aGlzLnNldChcImlzVmlzaWJsZVwiLCB0KSwgdGhpcy5wb3N0RXZlbnQoXCJ3ZWJfYXBwX3NldHVwX2JhY2tfYnV0dG9uXCIsIHsgaXNfdmlzaWJsZTogdCB9KTtcbiAgfVxuICAvKipcbiAgICogVHJ1ZSBpZiBCYWNrQnV0dG9uIGlzIGN1cnJlbnRseSB2aXNpYmxlLlxuICAgKi9cbiAgZ2V0IGlzVmlzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJpc1Zpc2libGVcIik7XG4gIH1cbiAgLyoqXG4gICAqIEhpZGVzIHRoZSBCYWNrQnV0dG9uLlxuICAgKi9cbiAgaGlkZSgpIHtcbiAgICB0aGlzLmlzVmlzaWJsZSA9ICExO1xuICB9XG4gIC8qKlxuICAgKiBTaG93cyB0aGUgQmFja0J1dHRvbi5cbiAgICovXG4gIHNob3coKSB7XG4gICAgdGhpcy5pc1Zpc2libGUgPSAhMDtcbiAgfVxufVxuY29uc3QgRWUgPSBTKChzKSA9PiBzIGluc3RhbmNlb2YgRGF0ZSA/IHMgOiBuZXcgRGF0ZSh5KCkucGFyc2UocykgKiAxZTMpLCBcIkRhdGVcIik7XG5mdW5jdGlvbiBLKHMsIGUpIHtcbiAgcmV0dXJuIG5ldyBEKCh0KSA9PiB7XG4gICAgaWYgKHR5cGVvZiB0ICE9IFwic3RyaW5nXCIgJiYgISh0IGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zKSlcbiAgICAgIHRocm93IEUoKTtcbiAgICBjb25zdCBuID0gdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiA/IG5ldyBVUkxTZWFyY2hQYXJhbXModCkgOiB0O1xuICAgIHJldHVybiBwZShzLCAocikgPT4ge1xuICAgICAgY29uc3QgaSA9IG4uZ2V0KHIpO1xuICAgICAgcmV0dXJuIGkgPT09IG51bGwgPyB2b2lkIDAgOiBpO1xuICAgIH0pO1xuICB9LCAhMSwgZSk7XG59XG5jb25zdCBkdCA9IGcoe1xuICBpZDogeSgpLFxuICB0eXBlOiBoKCksXG4gIHRpdGxlOiBoKCksXG4gIHBob3RvVXJsOiB7XG4gICAgdHlwZTogaCgpLm9wdGlvbmFsKCksXG4gICAgZnJvbTogXCJwaG90b191cmxcIlxuICB9LFxuICB1c2VybmFtZTogaCgpLm9wdGlvbmFsKClcbn0sIFwiQ2hhdFwiKS5vcHRpb25hbCgpLCBuZSA9IGcoe1xuICBhZGRlZFRvQXR0YWNobWVudE1lbnU6IHtcbiAgICB0eXBlOiBiKCkub3B0aW9uYWwoKSxcbiAgICBmcm9tOiBcImFkZGVkX3RvX2F0dGFjaG1lbnRfbWVudVwiXG4gIH0sXG4gIGFsbG93c1dyaXRlVG9QbToge1xuICAgIHR5cGU6IGIoKS5vcHRpb25hbCgpLFxuICAgIGZyb206IFwiYWxsb3dzX3dyaXRlX3RvX3BtXCJcbiAgfSxcbiAgZmlyc3ROYW1lOiB7XG4gICAgdHlwZTogaCgpLFxuICAgIGZyb206IFwiZmlyc3RfbmFtZVwiXG4gIH0sXG4gIGlkOiB5KCksXG4gIGlzQm90OiB7XG4gICAgdHlwZTogYigpLm9wdGlvbmFsKCksXG4gICAgZnJvbTogXCJpc19ib3RcIlxuICB9LFxuICBpc1ByZW1pdW06IHtcbiAgICB0eXBlOiBiKCkub3B0aW9uYWwoKSxcbiAgICBmcm9tOiBcImlzX3ByZW1pdW1cIlxuICB9LFxuICBsYW5ndWFnZUNvZGU6IHtcbiAgICB0eXBlOiBoKCkub3B0aW9uYWwoKSxcbiAgICBmcm9tOiBcImxhbmd1YWdlX2NvZGVcIlxuICB9LFxuICBsYXN0TmFtZToge1xuICAgIHR5cGU6IGgoKS5vcHRpb25hbCgpLFxuICAgIGZyb206IFwibGFzdF9uYW1lXCJcbiAgfSxcbiAgcGhvdG9Vcmw6IHtcbiAgICB0eXBlOiBoKCkub3B0aW9uYWwoKSxcbiAgICBmcm9tOiBcInBob3RvX3VybFwiXG4gIH0sXG4gIHVzZXJuYW1lOiBoKCkub3B0aW9uYWwoKVxufSwgXCJVc2VyXCIpLm9wdGlvbmFsKCk7XG5mdW5jdGlvbiBTZSgpIHtcbiAgcmV0dXJuIEsoe1xuICAgIGF1dGhEYXRlOiB7XG4gICAgICB0eXBlOiBFZSgpLFxuICAgICAgZnJvbTogXCJhdXRoX2RhdGVcIlxuICAgIH0sXG4gICAgY2FuU2VuZEFmdGVyOiB7XG4gICAgICB0eXBlOiB5KCkub3B0aW9uYWwoKSxcbiAgICAgIGZyb206IFwiY2FuX3NlbmRfYWZ0ZXJcIlxuICAgIH0sXG4gICAgY2hhdDogZHQsXG4gICAgY2hhdEluc3RhbmNlOiB7XG4gICAgICB0eXBlOiBoKCkub3B0aW9uYWwoKSxcbiAgICAgIGZyb206IFwiY2hhdF9pbnN0YW5jZVwiXG4gICAgfSxcbiAgICBjaGF0VHlwZToge1xuICAgICAgdHlwZTogaCgpLm9wdGlvbmFsKCksXG4gICAgICBmcm9tOiBcImNoYXRfdHlwZVwiXG4gICAgfSxcbiAgICBoYXNoOiBoKCksXG4gICAgcXVlcnlJZDoge1xuICAgICAgdHlwZTogaCgpLm9wdGlvbmFsKCksXG4gICAgICBmcm9tOiBcInF1ZXJ5X2lkXCJcbiAgICB9LFxuICAgIHJlY2VpdmVyOiBuZSxcbiAgICBzdGFydFBhcmFtOiB7XG4gICAgICB0eXBlOiBoKCkub3B0aW9uYWwoKSxcbiAgICAgIGZyb206IFwic3RhcnRfcGFyYW1cIlxuICAgIH0sXG4gICAgdXNlcjogbmVcbiAgfSwgXCJJbml0RGF0YVwiKTtcbn1cbmNvbnN0IF90ID0gUygocykgPT4gbWUoaCgpLnBhcnNlKHMpKSwgXCJyZ2JcIik7XG5mdW5jdGlvbiBmdChzKSB7XG4gIHJldHVybiBzLnJlcGxhY2UoL19bYS16XS9nLCAoZSkgPT4gZVsxXS50b1VwcGVyQ2FzZSgpKTtcbn1cbmZ1bmN0aW9uIGd0KHMpIHtcbiAgcmV0dXJuIHMucmVwbGFjZSgvW0EtWl0vZywgKGUpID0+IGBfJHtlLnRvTG93ZXJDYXNlKCl9YCk7XG59XG5jb25zdCBQZSA9IFMoXG4gIChzKSA9PiB7XG4gICAgY29uc3QgZSA9IF90KCkub3B0aW9uYWwoKTtcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMoaGUocykpLnJlZHVjZSgodCwgW24sIHJdKSA9PiAodFtmdChuKV0gPSBlLnBhcnNlKHIpLCB0KSwge30pO1xuICB9LFxuICBcIlRoZW1lUGFyYW1zXCJcbik7XG5mdW5jdGlvbiBYKHMpIHtcbiAgcmV0dXJuIEsoe1xuICAgIGJvdElubGluZToge1xuICAgICAgdHlwZTogYigpLm9wdGlvbmFsKCksXG4gICAgICBmcm9tOiBcInRnV2ViQXBwQm90SW5saW5lXCJcbiAgICB9LFxuICAgIGluaXREYXRhOiB7XG4gICAgICB0eXBlOiBTZSgpLm9wdGlvbmFsKCksXG4gICAgICBmcm9tOiBcInRnV2ViQXBwRGF0YVwiXG4gICAgfSxcbiAgICBpbml0RGF0YVJhdzoge1xuICAgICAgdHlwZTogaCgpLm9wdGlvbmFsKCksXG4gICAgICBmcm9tOiBcInRnV2ViQXBwRGF0YVwiXG4gICAgfSxcbiAgICBwbGF0Zm9ybToge1xuICAgICAgdHlwZTogaCgpLFxuICAgICAgZnJvbTogXCJ0Z1dlYkFwcFBsYXRmb3JtXCJcbiAgICB9LFxuICAgIHNob3dTZXR0aW5nczoge1xuICAgICAgdHlwZTogYigpLm9wdGlvbmFsKCksXG4gICAgICBmcm9tOiBcInRnV2ViQXBwU2hvd1NldHRpbmdzXCJcbiAgICB9LFxuICAgIHN0YXJ0UGFyYW06IHtcbiAgICAgIHR5cGU6IGgoKS5vcHRpb25hbCgpLFxuICAgICAgZnJvbTogXCJ0Z1dlYkFwcFN0YXJ0UGFyYW1cIlxuICAgIH0sXG4gICAgdGhlbWVQYXJhbXM6IHtcbiAgICAgIHR5cGU6IFBlKCksXG4gICAgICBmcm9tOiBcInRnV2ViQXBwVGhlbWVQYXJhbXNcIlxuICAgIH0sXG4gICAgdmVyc2lvbjoge1xuICAgICAgdHlwZTogaCgpLFxuICAgICAgZnJvbTogXCJ0Z1dlYkFwcFZlcnNpb25cIlxuICAgIH1cbiAgfSkucGFyc2Uocyk7XG59XG5mdW5jdGlvbiB4ZShzKSB7XG4gIHJldHVybiBYKFxuICAgIHMucmVwbGFjZSgvXltePyNdKls/I10vLCBcIlwiKS5yZXBsYWNlKC9bPyNdL2csIFwiJlwiKVxuICApO1xufVxuZnVuY3Rpb24gd3QoKSB7XG4gIHJldHVybiB4ZSh3aW5kb3cubG9jYXRpb24uaHJlZik7XG59XG5mdW5jdGlvbiBDZSgpIHtcbiAgcmV0dXJuIHBlcmZvcm1hbmNlLmdldEVudHJpZXNCeVR5cGUoXCJuYXZpZ2F0aW9uXCIpWzBdO1xufVxuZnVuY3Rpb24gYnQoKSB7XG4gIGNvbnN0IHMgPSBDZSgpO1xuICBpZiAoIXMpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGdldCBmaXJzdCBuYXZpZ2F0aW9uIGVudHJ5LlwiKTtcbiAgcmV0dXJuIHhlKHMubmFtZSk7XG59XG5mdW5jdGlvbiBUZShzKSB7XG4gIHJldHVybiBgdGVsZWdyYW0tYXBwcy8ke3MucmVwbGFjZSgvW0EtWl0vZywgKGUpID0+IGAtJHtlLnRvTG93ZXJDYXNlKCl9YCl9YDtcbn1cbmZ1bmN0aW9uIFJlKHMsIGUpIHtcbiAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShUZShzKSwgSlNPTi5zdHJpbmdpZnkoZSkpO1xufVxuZnVuY3Rpb24gQWUocykge1xuICBjb25zdCBlID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShUZShzKSk7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGUgPyBKU09OLnBhcnNlKGUpIDogdm9pZCAwO1xuICB9IGNhdGNoIHtcbiAgfVxufVxuZnVuY3Rpb24gbXQoKSB7XG4gIHJldHVybiBYKEFlKFwibGF1bmNoUGFyYW1zXCIpIHx8IFwiXCIpO1xufVxuZnVuY3Rpb24gSWUocykge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoXG4gICAgT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgT2JqZWN0LmVudHJpZXMocykubWFwKChbZSwgdF0pID0+IFtndChlKSwgdF0pXG4gICAgKVxuICApO1xufVxuZnVuY3Rpb24geXQocykge1xuICBjb25zdCB7XG4gICAgaW5pdERhdGFSYXc6IGUsXG4gICAgdGhlbWVQYXJhbXM6IHQsXG4gICAgcGxhdGZvcm06IG4sXG4gICAgdmVyc2lvbjogcixcbiAgICBzaG93U2V0dGluZ3M6IGksXG4gICAgc3RhcnRQYXJhbTogbyxcbiAgICBib3RJbmxpbmU6IGFcbiAgfSA9IHMsIHAgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gIHJldHVybiBwLnNldChcInRnV2ViQXBwUGxhdGZvcm1cIiwgbiksIHAuc2V0KFwidGdXZWJBcHBUaGVtZVBhcmFtc1wiLCBJZSh0KSksIHAuc2V0KFwidGdXZWJBcHBWZXJzaW9uXCIsIHIpLCBlICYmIHAuc2V0KFwidGdXZWJBcHBEYXRhXCIsIGUpLCBvICYmIHAuc2V0KFwidGdXZWJBcHBTdGFydFBhcmFtXCIsIG8pLCB0eXBlb2YgaSA9PSBcImJvb2xlYW5cIiAmJiBwLnNldChcInRnV2ViQXBwU2hvd1NldHRpbmdzXCIsIGkgPyBcIjFcIiA6IFwiMFwiKSwgdHlwZW9mIGEgPT0gXCJib29sZWFuXCIgJiYgcC5zZXQoXCJ0Z1dlYkFwcEJvdElubGluZVwiLCBhID8gXCIxXCIgOiBcIjBcIiksIHAudG9TdHJpbmcoKTtcbn1cbmZ1bmN0aW9uIHFlKHMpIHtcbiAgUmUoXCJsYXVuY2hQYXJhbXNcIiwgeXQocykpO1xufVxuZnVuY3Rpb24gdnQoKSB7XG4gIGNvbnN0IHMgPSBbXTtcbiAgZm9yIChjb25zdCBlIG9mIFtcbiAgICAvLyBUcnkgdG8gcmV0cmlldmUgbGF1bmNoIHBhcmFtZXRlcnMgZnJvbSB0aGUgY3VycmVudCBsb2NhdGlvbi4gVGhpcyBtZXRob2QgY2FuIHJldHVyblxuICAgIC8vIG5vdGhpbmcgaW4gY2FzZSwgbG9jYXRpb24gd2FzIGNoYW5nZWQsIGFuZCB0aGVuIHRoZSBwYWdlIHdhcyByZWxvYWRlZC5cbiAgICB3dCxcbiAgICAvLyBUaGVuLCB0cnkgdXNpbmcgdGhlIGxvd2VyIGxldmVsIEFQSSAtIHdpbmRvdy5wZXJmb3JtYW5jZS5cbiAgICBidCxcbiAgICAvLyBGaW5hbGx5LCB0cnkgdG8gZXh0cmFjdCBsYXVuY2ggcGFyYW1ldGVycyBmcm9tIHRoZSBzZXNzaW9uIHN0b3JhZ2UuXG4gICAgbXRcbiAgXSlcbiAgICB0cnkge1xuICAgICAgY29uc3QgdCA9IGUoKTtcbiAgICAgIHJldHVybiBxZSh0KSwgdDtcbiAgICB9IGNhdGNoICh0KSB7XG4gICAgICBzLnB1c2godCBpbnN0YW5jZW9mIEVycm9yID8gdC5tZXNzYWdlIDogSlNPTi5zdHJpbmdpZnkodCkpO1xuICAgIH1cbiAgdGhyb3cgbmV3IEVycm9yKFtcbiAgICBgVW5hYmxlIHRvIHJldHJpZXZlIGxhdW5jaCBwYXJhbWV0ZXJzIGZyb20gYW55IGtub3duIHNvdXJjZS4gUGVyaGFwcywgeW91IGhhdmUgb3BlbmVkIHlvdXIgYXBwIG91dHNpZGUgVGVsZWdyYW0/XG5gLFxuICAgIFwi8J+TliBSZWZlciB0byBkb2NzIGZvciBtb3JlIGluZm9ybWF0aW9uOlwiLFxuICAgIGBodHRwczovL2RvY3MudGVsZWdyYW0tbWluaS1hcHBzLmNvbS9wYWNrYWdlcy90ZWxlZ3JhbS1hcHBzLXNkay9lbnZpcm9ubWVudFxuYCxcbiAgICBcIkNvbGxlY3RlZCBlcnJvcnM6XCIsXG4gICAgcy5tYXAoKGUpID0+IGDigJQgJHtlfWApXG4gIF0uam9pbihgXG5gKSk7XG59XG5mdW5jdGlvbiBrZSgpIHtcbiAgY29uc3QgcyA9IENlKCk7XG4gIHJldHVybiAhIShzICYmIHMudHlwZSA9PT0gXCJyZWxvYWRcIik7XG59XG5mdW5jdGlvbiBFdCgpIHtcbiAgbGV0IHMgPSAwO1xuICByZXR1cm4gKCkgPT4gKHMgKz0gMSkudG9TdHJpbmcoKTtcbn1cbmNvbnN0IFtTdF0gPSBvZShFdCk7XG5mdW5jdGlvbiBsKHMsIGUpIHtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBjb25zdCB0ID0gdnQoKSwgbiA9IHtcbiAgICAgIC4uLnQsXG4gICAgICBwb3N0RXZlbnQ6IHB0KHQudmVyc2lvbiksXG4gICAgICBjcmVhdGVSZXF1ZXN0SWQ6IFN0KClcbiAgICB9O1xuICAgIGlmICh0eXBlb2YgcyA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICByZXR1cm4gcyhuKTtcbiAgICBjb25zdCBbciwgaSwgb10gPSBKKCksIGEgPSBlKHtcbiAgICAgIC4uLm4sXG4gICAgICAvLyBTdGF0ZSBzaG91bGQgb25seSBiZSBwYXNzZWQgb25seSBpbiBjYXNlLCBjdXJyZW50IHBhZ2Ugd2FzIHJlbG9hZGVkLiBJZiB3ZSBkb24ndCBhZGRcbiAgICAgIC8vIHRoaXMgY2hlY2ssIHN0YXRlIHJlc3RvcmF0aW9uIHdpbGwgd29yayBpbXByb3Blcmx5IGluIHRoZSB3ZWIgdmVyc2lvbiBvZiBUZWxlZ3JhbSxcbiAgICAgIC8vIHdoZW4gd2UgYXJlIGFsd2F5cyB3b3JraW5nIGluIHRoZSBzYW1lIFwic2Vzc2lvblwiICh0YWIpLlxuICAgICAgc3RhdGU6IGtlKCkgPyBBZShzKSA6IHZvaWQgMCxcbiAgICAgIGFkZENsZWFudXA6IHJcbiAgICB9KSwgcCA9ICh1KSA9PiAobyB8fCByKFxuICAgICAgdS5vbihcImNoYW5nZVwiLCAoJGUpID0+IHtcbiAgICAgICAgUmUocywgJGUpO1xuICAgICAgfSlcbiAgICApLCB1KTtcbiAgICByZXR1cm4gW1xuICAgICAgYSBpbnN0YW5jZW9mIFByb21pc2UgPyBhLnRoZW4ocCkgOiBwKGEpLFxuICAgICAgaVxuICAgIF07XG4gIH07XG59XG5jb25zdCBucyA9IGwoXCJiYWNrQnV0dG9uXCIsICh7XG4gIHBvc3RFdmVudDogcyxcbiAgdmVyc2lvbjogZSxcbiAgc3RhdGU6IHQgPSB7IGlzVmlzaWJsZTogITEgfVxufSkgPT4gbmV3IGx0KHQuaXNWaXNpYmxlLCBlLCBzKSk7XG5jbGFzcyBQIGV4dGVuZHMgWiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5ldyBldmVudCBsaXN0ZW5lci5cbiAgICAgKi9cbiAgICBjKHRoaXMsIFwib25cIiwgdGhpcy5zdGF0ZS5vbi5iaW5kKHRoaXMuc3RhdGUpKTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBldmVudCBsaXN0ZW5lci5cbiAgICAgKi9cbiAgICBjKHRoaXMsIFwib2ZmXCIsIHRoaXMuc3RhdGUub2ZmLmJpbmQodGhpcy5zdGF0ZSkpO1xuICB9XG59XG5mdW5jdGlvbiBOZShzKSB7XG4gIGNvbnN0IGUgPSBzLmF2YWlsYWJsZSA/IHMgOiB7XG4gICAgYXZhaWxhYmxlOiAhMSxcbiAgICBkZXZpY2VfaWQ6IFwiXCIsXG4gICAgdG9rZW5fc2F2ZWQ6ICExLFxuICAgIGFjY2Vzc19yZXF1ZXN0ZWQ6ICExLFxuICAgIGFjY2Vzc19ncmFudGVkOiAhMSxcbiAgICB0eXBlOiBcIlwiXG4gIH07XG4gIHJldHVybiB7XG4gICAgYXZhaWxhYmxlOiAhMCxcbiAgICB0eXBlOiBlLnR5cGUsXG4gICAgZGV2aWNlSWQ6IGUuZGV2aWNlX2lkLFxuICAgIHRva2VuU2F2ZWQ6IGUudG9rZW5fc2F2ZWQsXG4gICAgYWNjZXNzUmVxdWVzdGVkOiBlLmFjY2Vzc19yZXF1ZXN0ZWQsXG4gICAgYWNjZXNzR3JhbnRlZDogZS5hY2Nlc3NfZ3JhbnRlZFxuICB9O1xufVxuY2xhc3MgUHQgZXh0ZW5kcyBQIHtcbiAgY29uc3RydWN0b3IoeyBwb3N0RXZlbnQ6IHQsIHZlcnNpb246IG4sIC4uLnIgfSkge1xuICAgIHN1cGVyKHIsIG4sIHtcbiAgICAgIGF1dGg6IFwid2ViX2FwcF9iaW9tZXRyeV9yZXF1ZXN0X2F1dGhcIixcbiAgICAgIG9wZW5TZXR0aW5nczogXCJ3ZWJfYXBwX2Jpb21ldHJ5X29wZW5fc2V0dGluZ3NcIixcbiAgICAgIHJlcXVlc3RBY2Nlc3M6IFwid2ViX2FwcF9iaW9tZXRyeV9yZXF1ZXN0X2FjY2Vzc1wiLFxuICAgICAgdXBkYXRlVG9rZW46IFwid2ViX2FwcF9iaW9tZXRyeV91cGRhdGVfdG9rZW5cIlxuICAgIH0pO1xuICAgIGModGhpcywgXCJwb3N0RXZlbnRcIik7XG4gICAgYyh0aGlzLCBcImF1dGhQcm9taXNlXCIpO1xuICAgIGModGhpcywgXCJhY2Nlc3NQcm9taXNlXCIpO1xuICAgIHRoaXMucG9zdEV2ZW50ID0gdDtcbiAgfVxuICAvKipcbiAgICogU2hvd3Mgd2hldGhlciBiaW9tZXRyeSBpcyBhdmFpbGFibGUuXG4gICAqL1xuICBnZXQgYXZhaWxhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcImF2YWlsYWJsZVwiKTtcbiAgfVxuICAvKipcbiAgICogU2hvd3Mgd2hldGhlciBwZXJtaXNzaW9uIHRvIHVzZSBiaW9tZXRyaWNzIGhhcyBiZWVuIGdyYW50ZWQuXG4gICAqL1xuICBnZXQgYWNjZXNzR3JhbnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJhY2Nlc3NHcmFudGVkXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTaG93cyB3aGV0aGVyIGlmIHBlcm1pc3Npb24gdG8gdXNlIGJpb21ldHJpY3MgaGFzIGJlZW4gcmVxdWVzdGVkLlxuICAgKi9cbiAgZ2V0IGFjY2Vzc1JlcXVlc3RlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJhY2Nlc3NSZXF1ZXN0ZWRcIik7XG4gIH1cbiAgLyoqXG4gICAqIEF1dGhlbnRpY2F0ZXMgdGhlIHVzZXIgdXNpbmcgYmlvbWV0cmljcy5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBtZXRob2Qgb3B0aW9ucy5cbiAgICogQHNpbmNlIDcuMlxuICAgKiBAcmV0dXJucyBUb2tlbiBmcm9tIHRoZSBsb2NhbCBzZWN1cmUgc3RvcmFnZSwgaWYgYXV0aGVudGljYXRpb24gd2FzIHN1Y2Nlc3NmdWwuXG4gICAqL1xuICBhc3luYyBhdXRoZW50aWNhdGUoe1xuICAgIHJlYXNvbjogdCxcbiAgICAuLi5uXG4gIH0pIHtcbiAgICByZXR1cm4gdGhpcy5hdXRoUHJvbWlzZSB8fCAodGhpcy5hdXRoUHJvbWlzZSA9IGQoe1xuICAgICAgLi4ubixcbiAgICAgIG1ldGhvZDogXCJ3ZWJfYXBwX2Jpb21ldHJ5X3JlcXVlc3RfYXV0aFwiLFxuICAgICAgZXZlbnQ6IFwiYmlvbWV0cnlfYXV0aF9yZXF1ZXN0ZWRcIixcbiAgICAgIHBvc3RFdmVudDogdGhpcy5wb3N0RXZlbnQsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgLy8gVE9ETzogQ2hlY2sgaWYgcmVhc29uIGlzIGVtcHR5IHdvcmtzIGZpbmUuXG4gICAgICAgIHJlYXNvbjogKHQgfHwgXCJcIikudHJpbSgpXG4gICAgICB9XG4gICAgfSkudGhlbigoeyB0b2tlbjogciB9KSA9PiByKS5maW5hbGx5KCgpID0+IHRoaXMuYXV0aFByb21pc2UgPSB2b2lkIDApKSwgdGhpcy5hdXRoUHJvbWlzZTtcbiAgfVxuICAvKipcbiAgICogQSB1bmlxdWUgZGV2aWNlIGlkZW50aWZpZXIgdGhhdCBjYW4gYmUgdXNlZCB0byBtYXRjaCB0aGUgdG9rZW4gdG8gdGhlIGRldmljZS5cbiAgICovXG4gIGdldCBkZXZpY2VJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJkZXZpY2VJZFwiKTtcbiAgfVxuICAvKipcbiAgICogT3BlbnMgdGhlIGJpb21ldHJpYyBhY2Nlc3Mgc2V0dGluZ3MgZm9yIGJvdHMuIFVzZWZ1bCB3aGVuIHlvdSBuZWVkIHRvIHJlcXVlc3QgYmlvbWV0cmljc1xuICAgKiBhY2Nlc3MgdG8gdXNlcnMgd2hvIGhhdmVuJ3QgZ3JhbnRlZCBpdCB5ZXQuXG4gICAqXG4gICAqIF9Ob3RlIHRoYXQgdGhpcyBtZXRob2QgY2FuIGJlIGNhbGxlZCBvbmx5IGluIHJlc3BvbnNlIHRvIHVzZXIgaW50ZXJhY3Rpb24gd2l0aCB0aGUgTWluaSBBcHBcbiAgICogaW50ZXJmYWNlIChlLmcuIGEgY2xpY2sgaW5zaWRlIHRoZSBNaW5pIEFwcCBvciBvbiB0aGUgbWFpbiBidXR0b24pXy5cbiAgICogQHNpbmNlIDcuMlxuICAgKi9cbiAgb3BlblNldHRpbmdzKCkge1xuICAgIHRoaXMucG9zdEV2ZW50KFwid2ViX2FwcF9iaW9tZXRyeV9vcGVuX3NldHRpbmdzXCIpO1xuICB9XG4gIC8qKlxuICAgKiBSZXF1ZXN0cyBwZXJtaXNzaW9uIHRvIHVzZSBiaW9tZXRyaWNzLlxuICAgKiBAc2luY2UgNy4yXG4gICAqIEByZXR1cm5zIFByb21pc2Ugd2l0aCB0cnVlLCBpZiBhY2Nlc3Mgd2FzIGdyYW50ZWQuXG4gICAqL1xuICByZXF1ZXN0QWNjZXNzKHsgcmVhc29uOiB0LCAuLi5uIH0gPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmFjY2Vzc1Byb21pc2UgfHwgKHRoaXMuYWNjZXNzUHJvbWlzZSA9IGQoe1xuICAgICAgLi4ubixcbiAgICAgIHBvc3RFdmVudDogdGhpcy5wb3N0RXZlbnQsXG4gICAgICBtZXRob2Q6IFwid2ViX2FwcF9iaW9tZXRyeV9yZXF1ZXN0X2FjY2Vzc1wiLFxuICAgICAgZXZlbnQ6IFwiYmlvbWV0cnlfaW5mb19yZWNlaXZlZFwiLFxuICAgICAgcGFyYW1zOiB7IHJlYXNvbjogdCB8fCBcIlwiIH1cbiAgICB9KS50aGVuKChyKSA9PiB7XG4gICAgICBjb25zdCBpID0gTmUocik7XG4gICAgICByZXR1cm4gdGhpcy5zZXQoaSksIGkuYWNjZXNzR3JhbnRlZDtcbiAgICB9KS5maW5hbGx5KCgpID0+IHRoaXMuYWNjZXNzUHJvbWlzZSA9IHZvaWQgMCkpLCB0aGlzLmFjY2Vzc1Byb21pc2U7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIGJpb21ldHJpY3MgY3VycmVudGx5IGF2YWlsYWJsZSBvbiB0aGUgZGV2aWNlLlxuICAgKi9cbiAgZ2V0IGJpb21ldHJ5VHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJiaW9tZXRyeVR5cGVcIik7XG4gIH1cbiAgLyoqXG4gICAqIFNob3dzIHdoZXRoZXIgdG9rZW4gd2FzIHNhdmVkIHByZXZpb3VzbHkgaW4gdGhlIGxvY2FsIHNlY3VyZSBzdG9yYWdlLlxuICAgKi9cbiAgZ2V0IHRva2VuU2F2ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFwidG9rZW5TYXZlZFwiKTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgYmlvbWV0cmljIHRva2VuIGluIGEgc2VjdXJlIHN0b3JhZ2Ugb24gdGhlIGRldmljZS5cbiAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIGB0cnVlYCwgaWYgdG9rZW4gd2FzIHVwZGF0ZWQuXG4gICAqL1xuICBhc3luYyB1cGRhdGVUb2tlbih7IHRva2VuOiB0LCAuLi5uIH0gPSB7fSkge1xuICAgIHJldHVybiBbXCJyZW1vdmVkXCIsIFwidXBkYXRlZFwiXS5pbmNsdWRlcyhcbiAgICAgIChhd2FpdCBkKHtcbiAgICAgICAgLi4ubixcbiAgICAgICAgcG9zdEV2ZW50OiB0aGlzLnBvc3RFdmVudCxcbiAgICAgICAgbWV0aG9kOiBcIndlYl9hcHBfYmlvbWV0cnlfdXBkYXRlX3Rva2VuXCIsXG4gICAgICAgIGV2ZW50OiBcImJpb21ldHJ5X3Rva2VuX3VwZGF0ZWRcIixcbiAgICAgICAgcGFyYW1zOiB7IHRva2VuOiB0IHx8IFwiXCIgfVxuICAgICAgfSkpLnN0YXR1c1xuICAgICk7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHh0KHMpIHtcbiAgcmV0dXJuIE5lKFxuICAgIGF3YWl0IGQoe1xuICAgICAgLi4ucyB8fCB7fSxcbiAgICAgIG1ldGhvZDogXCJ3ZWJfYXBwX2Jpb21ldHJ5X2dldF9pbmZvXCIsXG4gICAgICBldmVudDogXCJiaW9tZXRyeV9pbmZvX3JlY2VpdmVkXCJcbiAgICB9KVxuICApO1xufVxuY29uc3QgcnMgPSBsKFxuICBcImJpb21ldHJ5TWFuYWdlclwiLFxuICBhc3luYyAoeyBwb3N0RXZlbnQ6IHMsIHZlcnNpb246IGUsIHN0YXRlOiB0IH0pID0+IG5ldyBQdCh7XG4gICAgLi4udCB8fCB2KFwid2ViX2FwcF9iaW9tZXRyeV9nZXRfaW5mb1wiLCBlKSA/IHQgfHwgYXdhaXQgeHQoeyB0aW1lb3V0OiAxZTMgfSkgOiB7XG4gICAgICBhdmFpbGFibGU6ICExLFxuICAgICAgYWNjZXNzR3JhbnRlZDogITEsXG4gICAgICBhY2Nlc3NSZXF1ZXN0ZWQ6ICExLFxuICAgICAgdG9rZW5TYXZlZDogITEsXG4gICAgICBkZXZpY2VJZDogXCJcIlxuICAgIH0sXG4gICAgdmVyc2lvbjogZSxcbiAgICBwb3N0RXZlbnQ6IHNcbiAgfSlcbik7XG5jbGFzcyBlZSBleHRlbmRzIFkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuZXcgZXZlbnQgbGlzdGVuZXIuXG4gICAgICovXG4gICAgYyh0aGlzLCBcIm9uXCIsIHRoaXMuc3RhdGUub24uYmluZCh0aGlzLnN0YXRlKSk7XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgZXZlbnQgbGlzdGVuZXIuXG4gICAgICovXG4gICAgYyh0aGlzLCBcIm9mZlwiLCB0aGlzLnN0YXRlLm9mZi5iaW5kKHRoaXMuc3RhdGUpKTtcbiAgfVxufVxuY2xhc3MgQ3QgZXh0ZW5kcyBlZSB7XG4gIGNvbnN0cnVjdG9yKGUsIHQpIHtcbiAgICBzdXBlcih7IGlzQ29uZmlybWF0aW9uTmVlZGVkOiBlIH0pLCB0aGlzLnBvc3RFdmVudCA9IHQ7XG4gIH1cbiAgc2V0IGlzQ29uZmlybWF0aW9uTmVlZGVkKGUpIHtcbiAgICB0aGlzLnNldChcImlzQ29uZmlybWF0aW9uTmVlZGVkXCIsIGUpLCB0aGlzLnBvc3RFdmVudChcIndlYl9hcHBfc2V0dXBfY2xvc2luZ19iZWhhdmlvclwiLCB7IG5lZWRfY29uZmlybWF0aW9uOiBlIH0pO1xuICB9XG4gIC8qKlxuICAgKiBUcnVlLCBpZiB0aGUgY29uZmlybWF0aW9uIGRpYWxvZyBzaG91bGQgYmUgc2hvd24gd2hpbGUgdGhlIHVzZXIgaXMgdHJ5aW5nIHRvIGNsb3NlXG4gICAqIHRoZSBNaW5pIEFwcC5cbiAgICovXG4gIGdldCBpc0NvbmZpcm1hdGlvbk5lZWRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJpc0NvbmZpcm1hdGlvbk5lZWRlZFwiKTtcbiAgfVxuICAvKipcbiAgICogRGlzYWJsZXMgdGhlIGNvbmZpcm1hdGlvbiBkaWFsb2cgd2hlbiBjbG9zaW5nIHRoZSBNaW5pIEFwcC5cbiAgICovXG4gIGRpc2FibGVDb25maXJtYXRpb24oKSB7XG4gICAgdGhpcy5pc0NvbmZpcm1hdGlvbk5lZWRlZCA9ICExO1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGVzIHRoZSBjb25maXJtYXRpb24gZGlhbG9nIHdoZW4gY2xvc2luZyB0aGUgTWluaSBBcHAuXG4gICAqL1xuICBlbmFibGVDb25maXJtYXRpb24oKSB7XG4gICAgdGhpcy5pc0NvbmZpcm1hdGlvbk5lZWRlZCA9ICEwO1xuICB9XG59XG5jb25zdCBpcyA9IGwoXG4gIFwiY2xvc2luZ0JlaGF2aW9yXCIsXG4gICh7XG4gICAgcG9zdEV2ZW50OiBzLFxuICAgIHN0YXRlOiBlID0geyBpc0NvbmZpcm1hdGlvbk5lZWRlZDogITEgfVxuICB9KSA9PiBuZXcgQ3QoZS5pc0NvbmZpcm1hdGlvbk5lZWRlZCwgcylcbik7XG5jbGFzcyB0ZSB7XG4gIGNvbnN0cnVjdG9yKGUsIHQpIHtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBUcnVlLCBpZiBzcGVjaWZpZWQgbWV0aG9kIGlzIHN1cHBvcnRlZCBieSB0aGUgY3VycmVudCBjb21wb25lbnQuXG4gICAgICovXG4gICAgYyh0aGlzLCBcInN1cHBvcnRzXCIpO1xuICAgIHRoaXMuc3VwcG9ydHMgPSB2ZShlLCB0KTtcbiAgfVxufVxuZnVuY3Rpb24gVHQocykge1xuICBpZiAoQXJyYXkuaXNBcnJheShzKSlcbiAgICByZXR1cm4gcztcbiAgaWYgKHR5cGVvZiBzID09IFwic3RyaW5nXCIpXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGUgPSBKU09OLnBhcnNlKHMpO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpXG4gICAgICAgIHJldHVybiBlO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgdGhyb3cgRSgpO1xufVxuY2xhc3MgUnQgZXh0ZW5kcyBEIHtcbiAgY29uc3RydWN0b3IodCwgbiwgcikge1xuICAgIHN1cGVyKFR0LCBuLCByKTtcbiAgICBjKHRoaXMsIFwiaXRlbVBhcnNlclwiKTtcbiAgICB0aGlzLml0ZW1QYXJzZXIgPSB0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIgPyB0IDogdC5wYXJzZS5iaW5kKHQpO1xuICB9XG4gIC8qKlxuICAgKiBBdHRlbXB0cyB0byBwYXJzZSBwYXNzZWQgdmFsdWVcbiAgICogQHBhcmFtIHZhbHVlIC0gdmFsdWUgdG8gcGFyc2UuXG4gICAqIEB0aHJvd3Mge1NES0Vycm9yfSBFUlJfUEFSU0VcbiAgICogQHNlZSBFUlJfUEFSU0VcbiAgICovXG4gIHBhcnNlKHQpIHtcbiAgICBjb25zdCBuID0gc3VwZXIucGFyc2UodCk7XG4gICAgcmV0dXJuIG4gPT09IHZvaWQgMCA/IG4gOiBuLm1hcCh0aGlzLml0ZW1QYXJzZXIpO1xuICB9XG4gIG9mKHQpIHtcbiAgICByZXR1cm4gdGhpcy5pdGVtUGFyc2VyID0gdHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiID8gdCA6IHQucGFyc2UuYmluZCh0KSwgdGhpcztcbiAgfVxufVxuZnVuY3Rpb24gQXQocykge1xuICByZXR1cm4gbmV3IFJ0KChlKSA9PiBlLCAhMSwgcyk7XG59XG5mdW5jdGlvbiByZShzLCBlKSB7XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMocy5tYXAoKHQpID0+IFt0LCBlXSkpO1xufVxuY2xhc3MgSXQgZXh0ZW5kcyB0ZSB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIG4pIHtcbiAgICBzdXBlcihlLCB7XG4gICAgICBkZWxldGU6IFwid2ViX2FwcF9pbnZva2VfY3VzdG9tX21ldGhvZFwiLFxuICAgICAgZ2V0OiBcIndlYl9hcHBfaW52b2tlX2N1c3RvbV9tZXRob2RcIixcbiAgICAgIGdldEtleXM6IFwid2ViX2FwcF9pbnZva2VfY3VzdG9tX21ldGhvZFwiLFxuICAgICAgc2V0OiBcIndlYl9hcHBfaW52b2tlX2N1c3RvbV9tZXRob2RcIlxuICAgIH0pLCB0aGlzLmNyZWF0ZVJlcXVlc3RJZCA9IHQsIHRoaXMucG9zdEV2ZW50ID0gbjtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlcyBzcGVjaWZpZWQga2V5IG9yIGtleXMgZnJvbSB0aGUgY2xvdWQgc3RvcmFnZS5cbiAgICogQHBhcmFtIGtleU9yS2V5cyAtIGtleSBvciBrZXlzIHRvIGRlbGV0ZS5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSByZXF1ZXN0IGV4ZWN1dGlvbiBvcHRpb25zLlxuICAgKi9cbiAgYXN5bmMgZGVsZXRlKGUsIHQgPSB7fSkge1xuICAgIGNvbnN0IG4gPSBBcnJheS5pc0FycmF5KGUpID8gZSA6IFtlXTtcbiAgICBuLmxlbmd0aCAmJiBhd2FpdCBDKFxuICAgICAgXCJkZWxldGVTdG9yYWdlVmFsdWVzXCIsXG4gICAgICB7IGtleXM6IG4gfSxcbiAgICAgIHRoaXMuY3JlYXRlUmVxdWVzdElkKCksXG4gICAgICB7IC4uLnQsIHBvc3RFdmVudDogdGhpcy5wb3N0RXZlbnQgfVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgbGlzdCBvZiBhbGwga2V5cyBwcmVzZW50ZWQgaW4gdGhlIGNsb3VkIHN0b3JhZ2UuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gcmVxdWVzdCBleGVjdXRpb24gb3B0aW9ucy5cbiAgICovXG4gIGFzeW5jIGdldEtleXMoZSA9IHt9KSB7XG4gICAgcmV0dXJuIEF0KCkub2YoaCgpKS5wYXJzZShcbiAgICAgIGF3YWl0IEMoXG4gICAgICAgIFwiZ2V0U3RvcmFnZUtleXNcIixcbiAgICAgICAge30sXG4gICAgICAgIHRoaXMuY3JlYXRlUmVxdWVzdElkKCksXG4gICAgICAgIHsgLi4uZSwgcG9zdEV2ZW50OiB0aGlzLnBvc3RFdmVudCB9XG4gICAgICApXG4gICAgKTtcbiAgfVxuICBhc3luYyBnZXQoZSwgdCA9IHt9KSB7XG4gICAgY29uc3QgbiA9IEFycmF5LmlzQXJyYXkoZSkgPyBlIDogW2VdO1xuICAgIGlmICghbi5sZW5ndGgpXG4gICAgICByZXR1cm4gcmUobiwgXCJcIik7XG4gICAgY29uc3QgciA9IGF3YWl0IEMoXG4gICAgICBcImdldFN0b3JhZ2VWYWx1ZXNcIixcbiAgICAgIHsga2V5czogbiB9LFxuICAgICAgdGhpcy5jcmVhdGVSZXF1ZXN0SWQoKSxcbiAgICAgIHsgLi4udCwgcG9zdEV2ZW50OiB0aGlzLnBvc3RFdmVudCB9XG4gICAgKSwgaSA9IGcocmUobiwgaCgpKSwgXCJDbG91ZFN0b3JhZ2VEYXRhXCIpLnBhcnNlKHIpO1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGUpID8gaSA6IGlbZV07XG4gIH1cbiAgLyoqXG4gICAqIFNhdmVzIHNwZWNpZmllZCB2YWx1ZSBieSBrZXkuXG4gICAqIEBwYXJhbSBrZXkgLSBzdG9yYWdlIGtleS5cbiAgICogQHBhcmFtIHZhbHVlIC0gc3RvcmFnZSB2YWx1ZS5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSByZXF1ZXN0IGV4ZWN1dGlvbiBvcHRpb25zLlxuICAgKi9cbiAgYXN5bmMgc2V0KGUsIHQsIG4gPSB7fSkge1xuICAgIGF3YWl0IEMoXG4gICAgICBcInNhdmVTdG9yYWdlVmFsdWVcIixcbiAgICAgIHsga2V5OiBlLCB2YWx1ZTogdCB9LFxuICAgICAgdGhpcy5jcmVhdGVSZXF1ZXN0SWQoKSxcbiAgICAgIHsgLi4ubiwgcG9zdEV2ZW50OiB0aGlzLnBvc3RFdmVudCB9XG4gICAgKTtcbiAgfVxufVxuY29uc3Qgb3MgPSBsKFxuICAoeyBjcmVhdGVSZXF1ZXN0SWQ6IHMsIHBvc3RFdmVudDogZSwgdmVyc2lvbjogdCB9KSA9PiBuZXcgSXQodCwgcywgZSlcbik7XG5jbGFzcyBxdCBleHRlbmRzIHRlIHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHN1cGVyKGUsIHtcbiAgICAgIGltcGFjdE9jY3VycmVkOiBcIndlYl9hcHBfdHJpZ2dlcl9oYXB0aWNfZmVlZGJhY2tcIixcbiAgICAgIG5vdGlmaWNhdGlvbk9jY3VycmVkOiBcIndlYl9hcHBfdHJpZ2dlcl9oYXB0aWNfZmVlZGJhY2tcIixcbiAgICAgIHNlbGVjdGlvbkNoYW5nZWQ6IFwid2ViX2FwcF90cmlnZ2VyX2hhcHRpY19mZWVkYmFja1wiXG4gICAgfSksIHRoaXMucG9zdEV2ZW50ID0gdDtcbiAgfVxuICAvKipcbiAgICogQSBtZXRob2QgdGVsbHMgdGhhdCBhbiBpbXBhY3Qgb2NjdXJyZWQuIFRoZSBUZWxlZ3JhbSBhcHAgbWF5IHBsYXkgdGhlXG4gICAqIGFwcHJvcHJpYXRlIGhhcHRpY3MgYmFzZWQgb24gc3R5bGUgdmFsdWUgcGFzc2VkLlxuICAgKiBAcGFyYW0gc3R5bGUgLSBpbXBhY3Qgc3R5bGUuXG4gICAqL1xuICBpbXBhY3RPY2N1cnJlZChlKSB7XG4gICAgdGhpcy5wb3N0RXZlbnQoXCJ3ZWJfYXBwX3RyaWdnZXJfaGFwdGljX2ZlZWRiYWNrXCIsIHtcbiAgICAgIHR5cGU6IFwiaW1wYWN0XCIsXG4gICAgICBpbXBhY3Rfc3R5bGU6IGVcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQSBtZXRob2QgdGVsbHMgdGhhdCBhIHRhc2sgb3IgYWN0aW9uIGhhcyBzdWNjZWVkZWQsIGZhaWxlZCwgb3IgcHJvZHVjZWRcbiAgICogYSB3YXJuaW5nLiBUaGUgVGVsZWdyYW0gYXBwIG1heSBwbGF5IHRoZSBhcHByb3ByaWF0ZSBoYXB0aWNzIGJhc2VkIG9uXG4gICAqIHR5cGUgdmFsdWUgcGFzc2VkLlxuICAgKiBAcGFyYW0gdHlwZSAtIG5vdGlmaWNhdGlvbiB0eXBlLlxuICAgKi9cbiAgbm90aWZpY2F0aW9uT2NjdXJyZWQoZSkge1xuICAgIHRoaXMucG9zdEV2ZW50KFwid2ViX2FwcF90cmlnZ2VyX2hhcHRpY19mZWVkYmFja1wiLCB7XG4gICAgICB0eXBlOiBcIm5vdGlmaWNhdGlvblwiLFxuICAgICAgbm90aWZpY2F0aW9uX3R5cGU6IGVcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQSBtZXRob2QgdGVsbHMgdGhhdCB0aGUgdXNlciBoYXMgY2hhbmdlZCBhIHNlbGVjdGlvbi4gVGhlIFRlbGVncmFtIGFwcFxuICAgKiBtYXkgcGxheSB0aGUgYXBwcm9wcmlhdGUgaGFwdGljcy5cbiAgICpcbiAgICogRG8gbm90IHVzZSB0aGlzIGZlZWRiYWNrIHdoZW4gdGhlIHVzZXIgbWFrZXMgb3IgY29uZmlybXMgYSBzZWxlY3Rpb247XG4gICAqIHVzZSBpdCBvbmx5IHdoZW4gdGhlIHNlbGVjdGlvbiBjaGFuZ2VzLlxuICAgKi9cbiAgc2VsZWN0aW9uQ2hhbmdlZCgpIHtcbiAgICB0aGlzLnBvc3RFdmVudChcIndlYl9hcHBfdHJpZ2dlcl9oYXB0aWNfZmVlZGJhY2tcIiwgeyB0eXBlOiBcInNlbGVjdGlvbl9jaGFuZ2VcIiB9KTtcbiAgfVxufVxuY29uc3QgYXMgPSBsKFxuICAoeyB2ZXJzaW9uOiBzLCBwb3N0RXZlbnQ6IGUgfSkgPT4gbmV3IHF0KHMsIGUpXG4pO1xuY2xhc3Mga3Qge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy5pbml0RGF0YSA9IGU7XG4gIH1cbiAgLyoqXG4gICAqIEBzZWUgSW5pdERhdGFQYXJzZWQuYXV0aERhdGVcbiAgICovXG4gIGdldCBhdXRoRGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pbml0RGF0YS5hdXRoRGF0ZTtcbiAgfVxuICAvKipcbiAgICogQHNlZSBJbml0RGF0YVBhcnNlZC5jYW5TZW5kQWZ0ZXJcbiAgICovXG4gIGdldCBjYW5TZW5kQWZ0ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5pdERhdGEuY2FuU2VuZEFmdGVyO1xuICB9XG4gIC8qKlxuICAgKiBEYXRlIGFmdGVyIHdoaWNoIGl0IGlzIGFsbG93ZWQgdG8gY2FsbFxuICAgKiB0aGUgW2Fuc3dlcldlYkFwcFF1ZXJ5XShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI2Fuc3dlcndlYmFwcHF1ZXJ5KSBtZXRob2QuXG4gICAqL1xuICBnZXQgY2FuU2VuZEFmdGVyRGF0ZSgpIHtcbiAgICBjb25zdCB7IGNhblNlbmRBZnRlcjogZSB9ID0gdGhpcztcbiAgICByZXR1cm4gZSA/IG5ldyBEYXRlKHRoaXMuYXV0aERhdGUuZ2V0VGltZSgpICsgZSAqIDFlMykgOiB2b2lkIDA7XG4gIH1cbiAgLyoqXG4gICAqIEBzZWUgSW5pdERhdGFQYXJzZWQuY2hhdFxuICAgKi9cbiAgZ2V0IGNoYXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5pdERhdGEuY2hhdDtcbiAgfVxuICAvKipcbiAgICogQHNlZSBJbml0RGF0YVBhcnNlZC5jaGF0VHlwZVxuICAgKi9cbiAgZ2V0IGNoYXRUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLmluaXREYXRhLmNoYXRUeXBlO1xuICB9XG4gIC8qKlxuICAgKiBAc2VlIEluaXREYXRhUGFyc2VkLmNoYXRJbnN0YW5jZVxuICAgKi9cbiAgZ2V0IGNoYXRJbnN0YW5jZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pbml0RGF0YS5jaGF0SW5zdGFuY2U7XG4gIH1cbiAgLyoqXG4gICAqIEBzZWUgSW5pdERhdGFQYXJzZWQuaGFzaFxuICAgKi9cbiAgZ2V0IGhhc2goKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5pdERhdGEuaGFzaDtcbiAgfVxuICAvKipcbiAgICogQHNlZSBJbml0RGF0YVBhcnNlZC5xdWVyeUlkXG4gICAqL1xuICBnZXQgcXVlcnlJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbml0RGF0YS5xdWVyeUlkO1xuICB9XG4gIC8qKlxuICAgKiBAc2VlIEluaXREYXRhUGFyc2VkLnJlY2VpdmVyXG4gICAqL1xuICBnZXQgcmVjZWl2ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5pdERhdGEucmVjZWl2ZXI7XG4gIH1cbiAgLyoqXG4gICAqIEBzZWUgSW5pdERhdGFQYXJzZWQuc3RhcnRQYXJhbVxuICAgKi9cbiAgZ2V0IHN0YXJ0UGFyYW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5pdERhdGEuc3RhcnRQYXJhbTtcbiAgfVxuICAvKipcbiAgICogQHNlZSBJbml0RGF0YVBhcnNlZC51c2VyXG4gICAqL1xuICBnZXQgdXNlcigpIHtcbiAgICByZXR1cm4gdGhpcy5pbml0RGF0YS51c2VyO1xuICB9XG59XG5jb25zdCBjcyA9IGwoXG4gICh7IGluaXREYXRhOiBzIH0pID0+IHMgPyBuZXcga3QocykgOiB2b2lkIDBcbik7XG5mdW5jdGlvbiBwcyhzKSB7XG4gIHJldHVybiBTZSgpLnBhcnNlKHMpO1xufVxuY2xhc3MgTnQgZXh0ZW5kcyBQIHtcbiAgY29uc3RydWN0b3IoZSwgdCwgbikge1xuICAgIHN1cGVyKHsgaXNPcGVuZWQ6IGUgfSwgdCwgeyBvcGVuOiBcIndlYl9hcHBfb3Blbl9pbnZvaWNlXCIgfSksIHRoaXMucG9zdEV2ZW50ID0gbjtcbiAgfVxuICBzZXQgaXNPcGVuZWQoZSkge1xuICAgIHRoaXMuc2V0KFwiaXNPcGVuZWRcIiwgZSk7XG4gIH1cbiAgLyoqXG4gICAqIFRydWUgaWYgaW52b2ljZSBpcyBjdXJyZW50bHkgb3BlbmVkLlxuICAgKi9cbiAgZ2V0IGlzT3BlbmVkKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcImlzT3BlbmVkXCIpO1xuICB9XG4gIGFzeW5jIG9wZW4oZSwgdCkge1xuICAgIGlmICh0aGlzLmlzT3BlbmVkKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52b2ljZSBpcyBhbHJlYWR5IG9wZW5lZFwiKTtcbiAgICBsZXQgbjtcbiAgICBpZiAoIXQpXG4gICAgICBuID0gZTtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IHsgaG9zdG5hbWU6IHIsIHBhdGhuYW1lOiBpIH0gPSBuZXcgVVJMKGUsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICAgIGlmIChyICE9PSBcInQubWVcIilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbmNvcnJlY3QgaG9zdG5hbWU6ICR7cn1gKTtcbiAgICAgIGNvbnN0IG8gPSBpLm1hdGNoKC9eXFwvKFxcJHxpbnZvaWNlXFwvKShbQS1aYS16MC05XFwtXz1dKykkLyk7XG4gICAgICBpZiAoIW8pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTGluayBwYXRobmFtZSBoYXMgaW5jb3JyZWN0IGZvcm1hdC4gRXhwZWN0ZWQgdG8gcmVjZWl2ZSBcIi9pbnZvaWNlL3tzbHVnfVwiIG9yIFwiLyR7c2x1Z31cIicpO1xuICAgICAgWywgLCBuXSA9IG87XG4gICAgfVxuICAgIHRoaXMuaXNPcGVuZWQgPSAhMDtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChhd2FpdCBkKHtcbiAgICAgICAgbWV0aG9kOiBcIndlYl9hcHBfb3Blbl9pbnZvaWNlXCIsXG4gICAgICAgIGV2ZW50OiBcImludm9pY2VfY2xvc2VkXCIsXG4gICAgICAgIHBhcmFtczogeyBzbHVnOiBuIH0sXG4gICAgICAgIHBvc3RFdmVudDogdGhpcy5wb3N0RXZlbnQsXG4gICAgICAgIGNhcHR1cmUoaSkge1xuICAgICAgICAgIHJldHVybiBuID09PSBpLnNsdWc7XG4gICAgICAgIH1cbiAgICAgIH0pKS5zdGF0dXM7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuaXNPcGVuZWQgPSAhMTtcbiAgICB9XG4gIH1cbn1cbmNvbnN0IGhzID0gbChcbiAgKHsgdmVyc2lvbjogcywgcG9zdEV2ZW50OiBlIH0pID0+IG5ldyBOdCghMSwgcywgZSlcbik7XG5jbGFzcyBWdCBleHRlbmRzIFkge1xuICBjb25zdHJ1Y3Rvcih7IHBvc3RFdmVudDogdCwgLi4ubiB9KSB7XG4gICAgc3VwZXIobik7XG4gICAgYyh0aGlzLCBcInBvc3RFdmVudFwiKTtcbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbmV3IGV2ZW50IGxpc3RlbmVyLlxuICAgICAqIEBwYXJhbSBldmVudCAtIGV2ZW50IHRvIGxpc3Rlbi5cbiAgICAgKiBAcGFyYW0gbGlzdGVuZXIgLSBsaXN0ZW5lciB0byBhZGQuXG4gICAgICovXG4gICAgYyh0aGlzLCBcIm9uXCIsICh0LCBuKSA9PiB0ID09PSBcImNsaWNrXCIgPyB3KFwibWFpbl9idXR0b25fcHJlc3NlZFwiLCBuKSA6IHRoaXMuc3RhdGUub24odCwgbikpO1xuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGV2ZW50IGxpc3RlbmVyLlxuICAgICAqIEBwYXJhbSBldmVudCAtIGV2ZW50IHRvIGxpc3Rlbi5cbiAgICAgKiBAcGFyYW0gbGlzdGVuZXIgLSBsaXN0ZW5lciB0byByZW1vdmUuXG4gICAgICovXG4gICAgYyh0aGlzLCBcIm9mZlwiLCAodCwgbikgPT4gdCA9PT0gXCJjbGlja1wiID8gQihcIm1haW5fYnV0dG9uX3ByZXNzZWRcIiwgbikgOiB0aGlzLnN0YXRlLm9mZih0LCBuKSk7XG4gICAgdGhpcy5wb3N0RXZlbnQgPSB0O1xuICB9XG4gIC8qKlxuICAgKiBUaGUgTWFpbkJ1dHRvbiBiYWNrZ3JvdW5kIGNvbG9yLlxuICAgKi9cbiAgZ2V0IGJnQ29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFwiYmdDb2xvclwiKTtcbiAgfVxuICAvKipcbiAgICogU2VuZHMgY3VycmVudCBsb2NhbCBzdGF0ZSB0byB0aGUgVGVsZWdyYW0gYXBwbGljYXRpb24uXG4gICAqL1xuICBjb21taXQoKSB7XG4gICAgdGhpcy50ZXh0ICE9PSBcIlwiICYmIHRoaXMucG9zdEV2ZW50KFwid2ViX2FwcF9zZXR1cF9tYWluX2J1dHRvblwiLCB7XG4gICAgICBpc192aXNpYmxlOiB0aGlzLmlzVmlzaWJsZSxcbiAgICAgIGlzX2FjdGl2ZTogdGhpcy5pc0VuYWJsZWQsXG4gICAgICBpc19wcm9ncmVzc192aXNpYmxlOiB0aGlzLmlzTG9hZGVyVmlzaWJsZSxcbiAgICAgIHRleHQ6IHRoaXMudGV4dCxcbiAgICAgIGNvbG9yOiB0aGlzLmJnQ29sb3IsXG4gICAgICB0ZXh0X2NvbG9yOiB0aGlzLnRleHRDb2xvclxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBEaXNhYmxlcyB0aGUgTWFpbkJ1dHRvbi5cbiAgICogQHNlZSBEb2VzIG5vdCB3b3JrIG9uIEFuZHJvaWQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9UZWxlZ3JhbS1NaW5pLUFwcHMvaXNzdWVzL2lzc3Vlcy8xXG4gICAqL1xuICBkaXNhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmlzRW5hYmxlZCA9ICExLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGVzIHRoZSBNYWluQnV0dG9uLlxuICAgKi9cbiAgZW5hYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmlzRW5hYmxlZCA9ICEwLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBIaWRlcyB0aGUgTWFpbkJ1dHRvbi5cbiAgICovXG4gIGhpZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWaXNpYmxlID0gITEsIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEhpZGVzIHRoZSBNYWluQnV0dG9uIGxvYWRpbmcgaW5kaWNhdG9yLlxuICAgKi9cbiAgaGlkZUxvYWRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc0xvYWRlclZpc2libGUgPSAhMSwgdGhpcztcbiAgfVxuICBzZXQgaXNFbmFibGVkKHQpIHtcbiAgICB0aGlzLnNldFBhcmFtcyh7IGlzRW5hYmxlZDogdCB9KTtcbiAgfVxuICAvKipcbiAgICogVHJ1ZSBpZiB0aGUgTWFpbkJ1dHRvbiBpcyBlbmFibGVkLlxuICAgKi9cbiAgZ2V0IGlzRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJpc0VuYWJsZWRcIik7XG4gIH1cbiAgc2V0IGlzTG9hZGVyVmlzaWJsZSh0KSB7XG4gICAgdGhpcy5zZXRQYXJhbXMoeyBpc0xvYWRlclZpc2libGU6IHQgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFRydWUgaWYgdGhlIE1haW5CdXR0b24gbG9hZGVyIGlzIHZpc2libGUuXG4gICAqL1xuICBnZXQgaXNMb2FkZXJWaXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcImlzTG9hZGVyVmlzaWJsZVwiKTtcbiAgfVxuICBzZXQgaXNWaXNpYmxlKHQpIHtcbiAgICB0aGlzLnNldFBhcmFtcyh7IGlzVmlzaWJsZTogdCB9KTtcbiAgfVxuICAvKipcbiAgICogVHJ1ZSBpZiB0aGUgTWFpbkJ1dHRvbiBpcyB2aXNpYmxlLlxuICAgKi9cbiAgZ2V0IGlzVmlzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJpc1Zpc2libGVcIik7XG4gIH1cbiAgLyoqXG4gICAqIFNob3dzIHRoZSBNYWluQnV0dG9uLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgb3BlbmluZyB0aGUgTWluaSBBcHAgZnJvbSB0aGUgYXR0YWNobWVudCBtZW51IGhpZGVzIHRoZSBtYWluIGJ1dHRvbiB1bnRpbCB0aGVcbiAgICogdXNlciBpbnRlcmFjdHMgd2l0aCB0aGUgTWluaSBBcHAgaW50ZXJmYWNlLlxuICAgKi9cbiAgc2hvdygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1Zpc2libGUgPSAhMCwgdGhpcztcbiAgfVxuICAvKipcbiAgICogU2hvd3MgYSBsb2FkaW5nIGluZGljYXRvciBvbiB0aGUgTWFpbiBCdXR0b24uXG4gICAqL1xuICBzaG93TG9hZGVyKCkge1xuICAgIHJldHVybiB0aGlzLmlzTG9hZGVyVmlzaWJsZSA9ICEwLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIGEgbmV3IE1haW5CdXR0b24gdGV4dC4gTWluaW1hbCBsZW5ndGggZm9yIHRoZSB0ZXh0IGlzIDEgc3ltYm9sLCBhbmQgbWF4aW11bSBpcyA2NCBzeW1ib2xzLlxuICAgKiBAcGFyYW0gdGV4dCAtIGEgbmV3IHRleHQuXG4gICAqL1xuICBzZXRUZXh0KHQpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRQYXJhbXMoeyB0ZXh0OiB0IH0pO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIGEgbmV3IE1haW4gQnV0dG9uIHRleHQgY29sb3IuXG4gICAqIEBwYXJhbSB0ZXh0Q29sb3IgLSBuZXcgdGV4dCBjb2xvci5cbiAgICovXG4gIHNldFRleHRDb2xvcih0KSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0UGFyYW1zKHsgdGV4dENvbG9yOiB0IH0pO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIGN1cnJlbnQgTWFpbiBCdXR0b24gY29sb3IuXG4gICAqIEBwYXJhbSBiZ0NvbG9yIC0gY29sb3IgdG8gc2V0LlxuICAgKi9cbiAgc2V0QmdDb2xvcih0KSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0UGFyYW1zKHsgYmdDb2xvcjogdCB9KTtcbiAgfVxuICAvKipcbiAgICogQWxsb3dzIHNldHRpbmcgbXVsdGlwbGUgTWFpbiBCdXR0b24gcGFyYW1ldGVycy5cbiAgICogQHBhcmFtIHBhcmFtcyAtIE1haW4gQnV0dG9uIHBhcmFtZXRlcnMuXG4gICAqL1xuICBzZXRQYXJhbXModCkge1xuICAgIHJldHVybiB0aGlzLnNldCh0KSwgdGhpcy5jb21taXQoKSwgdGhpcztcbiAgfVxuICAvKipcbiAgICogVGhlIE1haW5CdXR0b24gdGV4dC5cbiAgICovXG4gIGdldCB0ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmdldChcInRleHRcIik7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBNYWluQnV0dG9uIHRleHQgY29sb3IuXG4gICAqL1xuICBnZXQgdGV4dENvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcInRleHRDb2xvclwiKTtcbiAgfVxufVxuY29uc3QgdXMgPSBsKFxuICBcIm1haW5CdXR0b25cIixcbiAgKHtcbiAgICBwb3N0RXZlbnQ6IHMsXG4gICAgdGhlbWVQYXJhbXM6IGUsXG4gICAgc3RhdGU6IHQgPSB7XG4gICAgICBpc1Zpc2libGU6ICExLFxuICAgICAgaXNFbmFibGVkOiAhMSxcbiAgICAgIHRleHQ6IFwiXCIsXG4gICAgICBpc0xvYWRlclZpc2libGU6ICExLFxuICAgICAgdGV4dENvbG9yOiBlLmJ1dHRvblRleHRDb2xvciB8fCBcIiNmZmZmZmZcIixcbiAgICAgIGJnQ29sb3I6IGUuYnV0dG9uQ29sb3IgfHwgXCIjMDAwMDAwXCJcbiAgICB9XG4gIH0pID0+IG5ldyBWdCh7IC4uLnQsIHBvc3RFdmVudDogcyB9KVxuKTtcbmZ1bmN0aW9uIER0KCkge1xuICByZXR1cm4gSyh7XG4gICAgY29udGFjdDogZyh7XG4gICAgICB1c2VySWQ6IHtcbiAgICAgICAgdHlwZTogeSgpLFxuICAgICAgICBmcm9tOiBcInVzZXJfaWRcIlxuICAgICAgfSxcbiAgICAgIHBob25lTnVtYmVyOiB7XG4gICAgICAgIHR5cGU6IGgoKSxcbiAgICAgICAgZnJvbTogXCJwaG9uZV9udW1iZXJcIlxuICAgICAgfSxcbiAgICAgIGZpcnN0TmFtZToge1xuICAgICAgICB0eXBlOiBoKCksXG4gICAgICAgIGZyb206IFwiZmlyc3RfbmFtZVwiXG4gICAgICB9LFxuICAgICAgbGFzdE5hbWU6IHtcbiAgICAgICAgdHlwZTogaCgpLm9wdGlvbmFsKCksXG4gICAgICAgIGZyb206IFwibGFzdF9uYW1lXCJcbiAgICAgIH1cbiAgICB9KSxcbiAgICBhdXRoRGF0ZToge1xuICAgICAgdHlwZTogRWUoKSxcbiAgICAgIGZyb206IFwiYXV0aF9kYXRlXCJcbiAgICB9LFxuICAgIGhhc2g6IGgoKVxuICB9LCBcIlJlcXVlc3RlZENvbnRhY3RcIik7XG59XG5mdW5jdGlvbiBWZShzLCBlKSB7XG4gIHJldHVybiAodCkgPT4ge1xuICAgIGNvbnN0IFtuLCByXSA9IGVbdF07XG4gICAgcmV0dXJuIHYobiwgciwgcyk7XG4gIH07XG59XG5mdW5jdGlvbiBNdChzKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgoZSkgPT4ge1xuICAgIHNldFRpbWVvdXQoZSwgcyk7XG4gIH0pO1xufVxuY2xhc3MgQnQgZXh0ZW5kcyBQIHtcbiAgY29uc3RydWN0b3IoeyBwb3N0RXZlbnQ6IHQsIGNyZWF0ZVJlcXVlc3RJZDogbiwgdmVyc2lvbjogciwgYm90SW5saW5lOiBpLCAuLi5vIH0pIHtcbiAgICBzdXBlcihvLCByLCB7XG4gICAgICByZXF1ZXN0UGhvbmVBY2Nlc3M6IFwid2ViX2FwcF9yZXF1ZXN0X3Bob25lXCIsXG4gICAgICByZXF1ZXN0V3JpdGVBY2Nlc3M6IFwid2ViX2FwcF9yZXF1ZXN0X3dyaXRlX2FjY2Vzc1wiLFxuICAgICAgc3dpdGNoSW5saW5lUXVlcnk6IFwid2ViX2FwcF9zd2l0Y2hfaW5saW5lX3F1ZXJ5XCIsXG4gICAgICBzZXRIZWFkZXJDb2xvcjogXCJ3ZWJfYXBwX3NldF9oZWFkZXJfY29sb3JcIixcbiAgICAgIHNldEJhY2tncm91bmRDb2xvcjogXCJ3ZWJfYXBwX3NldF9iYWNrZ3JvdW5kX2NvbG9yXCJcbiAgICB9KTtcbiAgICBjKHRoaXMsIFwiYm90SW5saW5lXCIpO1xuICAgIGModGhpcywgXCJwb3N0RXZlbnRcIik7XG4gICAgYyh0aGlzLCBcImNyZWF0ZVJlcXVlc3RJZFwiKTtcbiAgICBjKHRoaXMsIFwicmVxdWVzdFBob25lQWNjZXNzUHJvbWlzZVwiKTtcbiAgICBjKHRoaXMsIFwicmVxdWVzdFdyaXRlQWNjZXNzUHJvbWlzZVwiKTtcbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgc3BlY2lmaWVkIG1ldGhvZCBwYXJhbWV0ZXIgaXMgc3VwcG9ydGVkIGJ5IGN1cnJlbnQgY29tcG9uZW50LlxuICAgICAqL1xuICAgIGModGhpcywgXCJzdXBwb3J0c1BhcmFtXCIpO1xuICAgIHRoaXMuY3JlYXRlUmVxdWVzdElkID0gbiwgdGhpcy5wb3N0RXZlbnQgPSB0LCB0aGlzLmJvdElubGluZSA9IGk7XG4gICAgY29uc3QgYSA9IHRoaXMuc3VwcG9ydHMuYmluZCh0aGlzKTtcbiAgICB0aGlzLnN1cHBvcnRzID0gKHApID0+IGEocCkgPyBwICE9PSBcInN3aXRjaElubGluZVF1ZXJ5XCIgfHwgaSA6ICExLCB0aGlzLnN1cHBvcnRzUGFyYW0gPSBWZShyLCB7XG4gICAgICBcInNldEhlYWRlckNvbG9yLmNvbG9yXCI6IFtcIndlYl9hcHBfc2V0X2hlYWRlcl9jb2xvclwiLCBcImNvbG9yXCJdLFxuICAgICAgXCJjbG9zZS5yZXR1cm5CYWNrXCI6IFtcIndlYl9hcHBfY2xvc2VcIiwgXCJyZXR1cm5fYmFja1wiXVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBBdHRlbXB0cyB0byBnZXQgcmVxdWVzdGVkIGNvbnRhY3QuXG4gICAqIEBwYXJhbSB0aW1lb3V0IC0gcmVxdWVzdCB0aW1lb3V0LlxuICAgKi9cbiAgYXN5bmMgZ2V0UmVxdWVzdGVkQ29udGFjdCh7XG4gICAgdGltZW91dDogdCA9IDFlNFxuICB9ID0ge30pIHtcbiAgICByZXR1cm4gRHQoKS5wYXJzZShcbiAgICAgIGF3YWl0IEMoXG4gICAgICAgIFwiZ2V0UmVxdWVzdGVkQ29udGFjdFwiLFxuICAgICAgICB7fSxcbiAgICAgICAgdGhpcy5jcmVhdGVSZXF1ZXN0SWQoKSxcbiAgICAgICAgeyBwb3N0RXZlbnQ6IHRoaXMucG9zdEV2ZW50LCB0aW1lb3V0OiB0IH1cbiAgICAgIClcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgTWluaSBBcHAgYmFja2dyb3VuZCBjb2xvci5cbiAgICogQGV4YW1wbGUgXCIjZmZhYWJiXCJcbiAgICovXG4gIGdldCBiZ0NvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcImJnQ29sb3JcIik7XG4gIH1cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgTWluaSBBcHAuXG4gICAqIEBwYXJhbSByZXR1cm5CYWNrIC0gc2hvdWxkIHRoZSBhcHBsaWNhdGlvbiBiZSB3cmFwcGVkIGludG8gdGhlIGJvdHRvbSBiYXIuXG4gICAqL1xuICBjbG9zZSh0KSB7XG4gICAgdGhpcy5wb3N0RXZlbnQoXCJ3ZWJfYXBwX2Nsb3NlXCIsIHRoaXMuc3VwcG9ydHNQYXJhbShcImNsb3NlLnJldHVybkJhY2tcIikgPyB7IHJldHVybl9iYWNrOiB0IH0gOiB7fSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBNaW5pIEFwcCBoZWFkZXIgY29sb3IuXG4gICAqIEBleGFtcGxlIFwiI2ZmYWFiYlwiXG4gICAqIEBleGFtcGxlIFwiYmdfY29sb3JcIlxuICAgKi9cbiAgZ2V0IGhlYWRlckNvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcImhlYWRlckNvbG9yXCIpO1xuICB9XG4gIC8qKlxuICAgKiBUcnVlIGlmIHRoZSBNaW5pIEFwcCBpcyBjdXJyZW50bHkgbGF1bmNoZWQgaW4gYm90IGlubGluZSBtb2RlLlxuICAgKi9cbiAgZ2V0IGlzQm90SW5saW5lKCkge1xuICAgIHJldHVybiB0aGlzLmJvdElubGluZTtcbiAgfVxuICAvKipcbiAgICogVHJ1ZSBpZiB0aGUgY3VycmVudCBNaW5pIEFwcCBiYWNrZ3JvdW5kIGNvbG9yIGlzIHJlY29nbml6ZWQgYXMgZGFyay5cbiAgICovXG4gIGdldCBpc0RhcmsoKSB7XG4gICAgcmV0dXJuIHllKHRoaXMuYmdDb2xvcik7XG4gIH1cbiAgLyoqXG4gICAqIEluZm9ybXMgdGhlIFRlbGVncmFtIGFwcCB0aGF0IHRoZSBNaW5pIEFwcCBpcyByZWFkeSB0byBiZSBkaXNwbGF5ZWQuXG4gICAqXG4gICAqIEl0IGlzIHJlY29tbWVuZGVkIHRvIGNhbGwgdGhpcyBtZXRob2QgYXMgZWFybHkgYXMgcG9zc2libGUsIGFzIHNvb24gYXMgYWxsIGVzc2VudGlhbFxuICAgKiBpbnRlcmZhY2UgZWxlbWVudHMgbG9hZGVkLiBPbmNlIHRoaXMgbWV0aG9kIGNhbGxlZCwgdGhlIGxvYWRpbmcgcGxhY2Vob2xkZXIgaXMgaGlkZGVuXG4gICAqIGFuZCB0aGUgTWluaSBBcHAgc2hvd24uXG4gICAqXG4gICAqIElmIHRoZSBtZXRob2Qgbm90IGNhbGxlZCwgdGhlIHBsYWNlaG9sZGVyIHdpbGwgYmUgaGlkZGVuIG9ubHkgd2hlbiB0aGUgcGFnZSBmdWxseSBsb2FkZWQuXG4gICAqL1xuICByZWFkeSgpIHtcbiAgICB0aGlzLnBvc3RFdmVudChcIndlYl9hcHBfcmVhZHlcIik7XG4gIH1cbiAgLyoqXG4gICAqIFJlcXVlc3RzIGN1cnJlbnQgdXNlciBjb250YWN0IGluZm9ybWF0aW9uLiBJbiBjb250cmFyeSB0byByZXF1ZXN0UGhvbmVBY2Nlc3MsIHRoaXMgbWV0aG9kXG4gICAqIHJldHVybnMgcHJvbWlzZSB3aXRoIGNvbnRhY3QgaW5mb3JtYXRpb24gdGhhdCByZWplY3RzIGluIGNhc2UsIHVzZXIgZGVuaWVkIGFjY2Vzcywgb3IgcmVxdWVzdFxuICAgKiBmYWlsZWQuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gYWRkaXRpb25hbCBvcHRpb25zLlxuICAgKi9cbiAgYXN5bmMgcmVxdWVzdENvbnRhY3QoeyB0aW1lb3V0OiB0ID0gNWUzIH0gPSB7fSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRSZXF1ZXN0ZWRDb250YWN0KCk7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICAgIGlmIChhd2FpdCB0aGlzLnJlcXVlc3RQaG9uZUFjY2VzcygpICE9PSBcInNlbnRcIilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFjY2VzcyBkZW5pZWQuXCIpO1xuICAgIGNvbnN0IHIgPSBEYXRlLm5vdygpICsgdDtcbiAgICBsZXQgaSA9IDUwO1xuICAgIHJldHVybiBiZShhc3luYyAoKSA9PiB7XG4gICAgICBmb3IgKDsgRGF0ZS5ub3coKSA8IHI7ICkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdldFJlcXVlc3RlZENvbnRhY3QoKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgTXQoaSksIGkgKz0gNTA7XG4gICAgICB9XG4gICAgICB0aHJvdyB3ZSh0KTtcbiAgICB9LCB0KTtcbiAgfVxuICAvKipcbiAgICogUmVxdWVzdHMgY3VycmVudCB1c2VyIHBob25lIGFjY2Vzcy4gTWV0aG9kIHJldHVybnMgcHJvbWlzZSwgd2hpY2ggcmVzb2x2ZXNcbiAgICogc3RhdHVzIG9mIHRoZSByZXF1ZXN0LiBJbiBjYXNlLCB1c2VyIGFjY2VwdGVkIHRoZSByZXF1ZXN0LCBNaW5pIEFwcCBib3Qgd2lsbCByZWNlaXZlXG4gICAqIHRoZSBhY2NvcmRpbmcgbm90aWZpY2F0aW9uLlxuICAgKlxuICAgKiBUbyBvYnRhaW4gdGhlIHJldHJpZXZlZCBpbmZvcm1hdGlvbiBpbnN0ZWFkLCB1dGlsaXplIHRoZSBgcmVxdWVzdENvbnRhY3RgIG1ldGhvZC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBhZGRpdGlvbmFsIG9wdGlvbnMuXG4gICAqIEBzZWUgcmVxdWVzdENvbnRhY3RcbiAgICovXG4gIGFzeW5jIHJlcXVlc3RQaG9uZUFjY2Vzcyh0ID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0UGhvbmVBY2Nlc3NQcm9taXNlIHx8ICh0aGlzLnJlcXVlc3RQaG9uZUFjY2Vzc1Byb21pc2UgPSBkKHtcbiAgICAgIC4uLnQsXG4gICAgICBtZXRob2Q6IFwid2ViX2FwcF9yZXF1ZXN0X3Bob25lXCIsXG4gICAgICBldmVudDogXCJwaG9uZV9yZXF1ZXN0ZWRcIixcbiAgICAgIHBvc3RFdmVudDogdGhpcy5wb3N0RXZlbnRcbiAgICB9KS50aGVuKCh7IHN0YXR1czogbiB9KSA9PiBuKS5maW5hbGx5KCgpID0+IHRoaXMucmVxdWVzdFBob25lQWNjZXNzUHJvbWlzZSA9IHZvaWQgMCkpLCB0aGlzLnJlcXVlc3RQaG9uZUFjY2Vzc1Byb21pc2U7XG4gIH1cbiAgLyoqXG4gICAqIFJlcXVlc3RzIHdyaXRlIG1lc3NhZ2UgYWNjZXNzIHRvIGN1cnJlbnQgdXNlci5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBhZGRpdGlvbmFsIG9wdGlvbnMuXG4gICAqL1xuICBhc3luYyByZXF1ZXN0V3JpdGVBY2Nlc3ModCA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdFdyaXRlQWNjZXNzUHJvbWlzZSB8fCAodGhpcy5yZXF1ZXN0V3JpdGVBY2Nlc3NQcm9taXNlID0gZCh7XG4gICAgICAuLi50LFxuICAgICAgbWV0aG9kOiBcIndlYl9hcHBfcmVxdWVzdF93cml0ZV9hY2Nlc3NcIixcbiAgICAgIGV2ZW50OiBcIndyaXRlX2FjY2Vzc19yZXF1ZXN0ZWRcIixcbiAgICAgIHBvc3RFdmVudDogdGhpcy5wb3N0RXZlbnRcbiAgICB9KS50aGVuKCh7IHN0YXR1czogbiB9KSA9PiBuKS5maW5hbGx5KCgpID0+IHRoaXMucmVxdWVzdFdyaXRlQWNjZXNzUHJvbWlzZSA9IHZvaWQgMCkpLCB0aGlzLnJlcXVlc3RXcml0ZUFjY2Vzc1Byb21pc2U7XG4gIH1cbiAgLyoqXG4gICAqIEEgbWV0aG9kIHVzZWQgdG8gc2VuZCBkYXRhIHRvIHRoZSBib3QuIFdoZW4gdGhpcyBtZXRob2QgY2FsbGVkLCBhIHNlcnZpY2UgbWVzc2FnZSBzZW50IHRvXG4gICAqIHRoZSBib3QgY29udGFpbmluZyB0aGUgZGF0YSBvZiB0aGUgbGVuZ3RoIHVwIHRvIDQwOTYgYnl0ZXMsIGFuZCB0aGUgTWluaSBBcHAgY2xvc2VkLiBTZWUgdGhlXG4gICAqIGZpZWxkIGB3ZWJfYXBwX2RhdGFgIGluIHRoZSBjbGFzcyBbTWVzc2FnZV0oaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9ib3RzL2FwaSNtZXNzYWdlKS5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgb25seSBhdmFpbGFibGUgZm9yIE1pbmkgQXBwcyBsYXVuY2hlZCB2aWEgYSBLZXlib2FyZCBidXR0b24uXG4gICAqIEBwYXJhbSBkYXRhIC0gZGF0YSB0byBzZW5kIHRvIGJvdC5cbiAgICogQHRocm93cyB7RXJyb3J9IGRhdGEgaGFzIGluY29ycmVjdCBzaXplLlxuICAgKi9cbiAgc2VuZERhdGEodCkge1xuICAgIGNvbnN0IHsgc2l6ZTogbiB9ID0gbmV3IEJsb2IoW3RdKTtcbiAgICBpZiAoIW4gfHwgbiA+IDQwOTYpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhc3NlZCBkYXRhIGhhcyBpbmNvcnJlY3Qgc2l6ZTogJHtufWApO1xuICAgIHRoaXMucG9zdEV2ZW50KFwid2ViX2FwcF9kYXRhX3NlbmRcIiwgeyBkYXRhOiB0IH0pO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIGN1cnJlbnQgTWluaSBBcHAgaGVhZGVyIGNvbG9yLlxuICAgKlxuICAgKiBAc2VlIE5vIGVmZmVjdCBvbiBkZXNrdG9wOiBodHRwczovL2dpdGh1Yi5jb20vVGVsZWdyYW0tTWluaS1BcHBzL3RlbGVncmFtLWFwcHMvaXNzdWVzLzlcbiAgICogQHNlZSBXb3JrcyBpbmNvcnJlY3RseSBpbiBBbmRyb2lkOiBodHRwczovL2dpdGh1Yi5jb20vVGVsZWdyYW0tTWluaS1BcHBzL3RlbGVncmFtLWFwcHMvaXNzdWVzLzhcbiAgICogQHBhcmFtIGNvbG9yIC0gY29sb3Iga2V5IG9yIFJHQiBjb2xvci5cbiAgICovXG4gIHNldEhlYWRlckNvbG9yKHQpIHtcbiAgICB0aGlzLnBvc3RFdmVudChcIndlYl9hcHBfc2V0X2hlYWRlcl9jb2xvclwiLCBRKHQpID8geyBjb2xvcjogdCB9IDogeyBjb2xvcl9rZXk6IHQgfSksIHRoaXMuc2V0KFwiaGVhZGVyQ29sb3JcIiwgdCk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgY3VycmVudCBNaW5pIEFwcCBiYWNrZ3JvdW5kIGNvbG9yLlxuICAgKlxuICAgKiBAc2VlIE5vIGVmZmVjdCBvbiBkZXNrdG9wOiBodHRwczovL2dpdGh1Yi5jb20vVGVsZWdyYW0tTWluaS1BcHBzL3RlbGVncmFtLWFwcHMvaXNzdWVzLzlcbiAgICogQHNlZSBXb3JrcyBpbmNvcnJlY3RseSBpbiBBbmRyb2lkOiBodHRwczovL2dpdGh1Yi5jb20vVGVsZWdyYW0tTWluaS1BcHBzL3RlbGVncmFtLWFwcHMvaXNzdWVzLzhcbiAgICogQHBhcmFtIGNvbG9yIC0gUkdCIGNvbG9yLlxuICAgKi9cbiAgc2V0QmdDb2xvcih0KSB7XG4gICAgdGhpcy5wb3N0RXZlbnQoXCJ3ZWJfYXBwX3NldF9iYWNrZ3JvdW5kX2NvbG9yXCIsIHsgY29sb3I6IHQgfSksIHRoaXMuc2V0KFwiYmdDb2xvclwiLCB0KTtcbiAgfVxuICAvKipcbiAgICogSW5zZXJ0cyB0aGUgYm90J3MgdXNlcm5hbWUgYW5kIHRoZSBzcGVjaWZpZWQgaW5saW5lIHF1ZXJ5IGluIHRoZSBjdXJyZW50IGNoYXQncyBpbnB1dCBmaWVsZC5cbiAgICogUXVlcnkgbWF5IGJlIGVtcHR5LCBpbiB3aGljaCBjYXNlIG9ubHkgdGhlIGJvdCdzIHVzZXJuYW1lIHdpbGwgYmUgaW5zZXJ0ZWQuIFRoZSBjbGllbnQgcHJvbXB0c1xuICAgKiB0aGUgdXNlciB0byBjaG9vc2UgYSBzcGVjaWZpYyBjaGF0LCB0aGVuIG9wZW5zIHRoYXQgY2hhdCBhbmQgaW5zZXJ0cyB0aGUgYm90J3MgdXNlcm5hbWUgYW5kXG4gICAqIHRoZSBzcGVjaWZpZWQgaW5saW5lIHF1ZXJ5IGluIHRoZSBpbnB1dCBmaWVsZC5cbiAgICogQHBhcmFtIHRleHQgLSB0ZXh0IHdoaWNoIHNob3VsZCBiZSBpbnNlcnRlZCBpbiB0aGUgaW5wdXQgYWZ0ZXIgdGhlIGN1cnJlbnQgYm90IG5hbWUuIE1heFxuICAgKiBsZW5ndGggaXMgMjU2IHN5bWJvbHMuXG4gICAqIEBwYXJhbSBjaGF0VHlwZXMgLSBMaXN0IG9mIGNoYXQgdHlwZXMgd2hpY2ggY291bGQgYmUgY2hvc2VuIHRvIHNlbmQgdGhlIG1lc3NhZ2UuIENvdWxkIGJlXG4gICAqIGVtcHR5IGxpc3QuXG4gICAqL1xuICBzd2l0Y2hJbmxpbmVRdWVyeSh0LCBuID0gW10pIHtcbiAgICBpZiAoIXRoaXMuc3VwcG9ydHMoXCJzd2l0Y2hJbmxpbmVRdWVyeVwiKSAmJiAhdGhpcy5pc0JvdElubGluZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBpcyB1bnN1cHBvcnRlZCBiZWNhdXNlIE1pbmkgQXBwIHNob3VsZCBiZSBsYXVuY2hlZCBpbiBpbmxpbmUgbW9kZS5cIik7XG4gICAgdGhpcy5wb3N0RXZlbnQoXCJ3ZWJfYXBwX3N3aXRjaF9pbmxpbmVfcXVlcnlcIiwgeyBxdWVyeTogdCwgY2hhdF90eXBlczogbiB9KTtcbiAgfVxufVxuY29uc3QgbHMgPSBsKFxuICBcIm1pbmlBcHBcIixcbiAgKHtcbiAgICB0aGVtZVBhcmFtczogcyxcbiAgICBib3RJbmxpbmU6IGUgPSAhMSxcbiAgICBzdGF0ZTogdCA9IHtcbiAgICAgIGJnQ29sb3I6IHMuYmdDb2xvciB8fCBcIiNmZmZmZmZcIixcbiAgICAgIGhlYWRlckNvbG9yOiBzLmhlYWRlckJnQ29sb3IgfHwgXCIjMDAwMDAwXCJcbiAgICB9LFxuICAgIC4uLm5cbiAgfSkgPT4gbmV3IEJ0KHsgLi4ubiwgLi4udCwgYm90SW5saW5lOiBlIH0pXG4pO1xuZnVuY3Rpb24gTHQocykge1xuICBjb25zdCBlID0gcy5tZXNzYWdlLnRyaW0oKSwgdCA9IChzLnRpdGxlIHx8IFwiXCIpLnRyaW0oKSwgbiA9IHMuYnV0dG9ucyB8fCBbXTtcbiAgbGV0IHI7XG4gIGlmICh0Lmxlbmd0aCA+IDY0KVxuICAgIHRocm93IG5ldyBFcnJvcihgVGl0bGUgaGFzIGluY29ycmVjdCBzaXplOiAke3QubGVuZ3RofWApO1xuICBpZiAoIWUubGVuZ3RoIHx8IGUubGVuZ3RoID4gMjU2KVxuICAgIHRocm93IG5ldyBFcnJvcihgTWVzc2FnZSBoYXMgaW5jb3JyZWN0IHNpemU6ICR7ZS5sZW5ndGh9YCk7XG4gIGlmIChuLmxlbmd0aCA+IDMpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBCdXR0b25zIGhhdmUgaW5jb3JyZWN0IHNpemU6ICR7bi5sZW5ndGh9YCk7XG4gIHJldHVybiBuLmxlbmd0aCA/IHIgPSBuLm1hcCgoaSkgPT4ge1xuICAgIGNvbnN0IHsgaWQ6IG8gPSBcIlwiIH0gPSBpO1xuICAgIGlmIChvLmxlbmd0aCA+IDY0KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBCdXR0b24gSUQgaGFzIGluY29ycmVjdCBzaXplOiAke299YCk7XG4gICAgaWYgKCFpLnR5cGUgfHwgaS50eXBlID09PSBcImRlZmF1bHRcIiB8fCBpLnR5cGUgPT09IFwiZGVzdHJ1Y3RpdmVcIikge1xuICAgICAgY29uc3QgYSA9IGkudGV4dC50cmltKCk7XG4gICAgICBpZiAoIWEubGVuZ3RoIHx8IGEubGVuZ3RoID4gNjQpIHtcbiAgICAgICAgY29uc3QgcCA9IGkudHlwZSB8fCBcImRlZmF1bHRcIjtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCdXR0b24gdGV4dCB3aXRoIHR5cGUgXCIke3B9XCIgaGFzIGluY29ycmVjdCBzaXplOiAke2kudGV4dC5sZW5ndGh9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyAuLi5pLCB0ZXh0OiBhLCBpZDogbyB9O1xuICAgIH1cbiAgICByZXR1cm4geyAuLi5pLCBpZDogbyB9O1xuICB9KSA6IHIgPSBbeyB0eXBlOiBcImNsb3NlXCIsIGlkOiBcIlwiIH1dLCB7IHRpdGxlOiB0LCBtZXNzYWdlOiBlLCBidXR0b25zOiByIH07XG59XG5jbGFzcyAkdCBleHRlbmRzIFAge1xuICBjb25zdHJ1Y3RvcihlLCB0LCBuKSB7XG4gICAgc3VwZXIoeyBpc09wZW5lZDogZSB9LCB0LCB7IG9wZW46IFwid2ViX2FwcF9vcGVuX3BvcHVwXCIgfSksIHRoaXMucG9zdEV2ZW50ID0gbjtcbiAgfVxuICBzZXQgaXNPcGVuZWQoZSkge1xuICAgIHRoaXMuc2V0KFwiaXNPcGVuZWRcIiwgZSk7XG4gIH1cbiAgLyoqXG4gICAqIFRydWUgaWYgdGhlIFBvcHVwIGlzIG9wZW5lZC5cbiAgICovXG4gIGdldCBpc09wZW5lZCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJpc09wZW5lZFwiKTtcbiAgfVxuICAvKipcbiAgICogQSBtZXRob2QgdGhhdCBzaG93cyBhIG5hdGl2ZSBwb3B1cCBkZXNjcmliZWQgYnkgdGhlIGBwYXJhbXNgIGFyZ3VtZW50LlxuICAgKiBQcm9taXNlIHdpbGwgYmUgcmVzb2x2ZWQgd2hlbiBwb3B1cCBpcyBjbG9zZWQuIFJlc29sdmVkIHZhbHVlIHdpbGwgaGF2ZVxuICAgKiBhbiBpZGVudGlmaWVyIG9mIHByZXNzZWQgYnV0dG9uLlxuICAgKlxuICAgKiBJbiBjYXNlLCB1c2VyIGNsaWNrZWQgb3V0c2lkZSB0aGUgcG9wdXAgb3IgY2xpY2tlZCB0b3AgcmlnaHQgcG9wdXAgY2xvc2VcbiAgICogYnV0dG9uLCBudWxsIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gcG9wdXAgcGFyYW1ldGVycy5cbiAgICogQHRocm93cyB7RXJyb3J9IFBvcHVwIGlzIGFscmVhZHkgb3BlbmVkLlxuICAgKi9cbiAgYXN5bmMgb3BlbihlKSB7XG4gICAgaWYgKHRoaXMuaXNPcGVuZWQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQb3B1cCBpcyBhbHJlYWR5IG9wZW5lZC5cIik7XG4gICAgdGhpcy5pc09wZW5lZCA9ICEwO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGJ1dHRvbl9pZDogdCA9IG51bGwgfSA9IGF3YWl0IGQoe1xuICAgICAgICBldmVudDogXCJwb3B1cF9jbG9zZWRcIixcbiAgICAgICAgbWV0aG9kOiBcIndlYl9hcHBfb3Blbl9wb3B1cFwiLFxuICAgICAgICBwb3N0RXZlbnQ6IHRoaXMucG9zdEV2ZW50LFxuICAgICAgICBwYXJhbXM6IEx0KGUpXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0O1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmlzT3BlbmVkID0gITE7XG4gICAgfVxuICB9XG59XG5jb25zdCBkcyA9IGwoXG4gICh7IHBvc3RFdmVudDogcywgdmVyc2lvbjogZSB9KSA9PiBuZXcgJHQoITEsIGUsIHMpXG4pO1xuY2xhc3MgV3QgZXh0ZW5kcyBQIHtcbiAgY29uc3RydWN0b3IoZSwgdCwgbikge1xuICAgIHN1cGVyKHsgaXNPcGVuZWQ6IGUgfSwgdCwge1xuICAgICAgY2xvc2U6IFwid2ViX2FwcF9jbG9zZV9zY2FuX3FyX3BvcHVwXCIsXG4gICAgICBvcGVuOiBcIndlYl9hcHBfb3Blbl9zY2FuX3FyX3BvcHVwXCJcbiAgICB9KSwgdGhpcy5wb3N0RXZlbnQgPSBuO1xuICB9XG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIHNjYW5uZXIuXG4gICAqL1xuICBjbG9zZSgpIHtcbiAgICB0aGlzLnBvc3RFdmVudChcIndlYl9hcHBfY2xvc2Vfc2Nhbl9xcl9wb3B1cFwiKSwgdGhpcy5pc09wZW5lZCA9ICExO1xuICB9XG4gIHNldCBpc09wZW5lZChlKSB7XG4gICAgdGhpcy5zZXQoXCJpc09wZW5lZFwiLCBlKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBzY2FubmVyIGlzIGN1cnJlbnRseSBvcGVuZWQuXG4gICAqL1xuICBnZXQgaXNPcGVuZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFwiaXNPcGVuZWRcIik7XG4gIH1cbiAgYXN5bmMgb3BlbihlKSB7XG4gICAgaWYgKHRoaXMuaXNPcGVuZWQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc2Nhbm5lciBpcyBhbHJlYWR5IG9wZW5lZFwiKTtcbiAgICBjb25zdCB7IHRleHQ6IHQsIGNhcHR1cmU6IG4gfSA9ICh0eXBlb2YgZSA9PSBcInN0cmluZ1wiID8geyB0ZXh0OiBlIH0gOiBlKSB8fCB7fTtcbiAgICB0aGlzLmlzT3BlbmVkID0gITA7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGkgPSAoYXdhaXQgZCh7XG4gICAgICAgIG1ldGhvZDogXCJ3ZWJfYXBwX29wZW5fc2Nhbl9xcl9wb3B1cFwiLFxuICAgICAgICBldmVudDogW1wicXJfdGV4dF9yZWNlaXZlZFwiLCBcInNjYW5fcXJfcG9wdXBfY2xvc2VkXCJdLFxuICAgICAgICBwb3N0RXZlbnQ6IHRoaXMucG9zdEV2ZW50LFxuICAgICAgICBwYXJhbXM6IHsgdGV4dDogdCB9LFxuICAgICAgICBjYXB0dXJlKG8pIHtcbiAgICAgICAgICByZXR1cm4gby5ldmVudCA9PT0gXCJzY2FuX3FyX3BvcHVwX2Nsb3NlZFwiIHx8ICFuIHx8IG4oby5wYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgfSkgfHwge30pLmRhdGEgfHwgbnVsbDtcbiAgICAgIHJldHVybiBpICYmIHRoaXMuY2xvc2UoKSwgaTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5pc09wZW5lZCA9ICExO1xuICAgIH1cbiAgfVxuICAvLyBUT0RPOiBTdHJlYW1pbmcgbW9kZSwgYWxsb3dpbmcgdG8gc2NhbiBzZXZlcmFsIFFScyB1bnRpbCBjbG9zZWQuXG59XG5jb25zdCBfcyA9IGwoXG4gICh7IHZlcnNpb246IHMsIHBvc3RFdmVudDogZSB9KSA9PiBuZXcgV3QoITEsIHMsIGUpXG4pO1xuY2xhc3MgVXQgZXh0ZW5kcyBaIHtcbiAgY29uc3RydWN0b3IodCwgbiwgcikge1xuICAgIHN1cGVyKHsgaXNWaXNpYmxlOiB0IH0sIG4sIHtcbiAgICAgIHNob3c6IFwid2ViX2FwcF9zZXR1cF9zZXR0aW5nc19idXR0b25cIixcbiAgICAgIGhpZGU6IFwid2ViX2FwcF9zZXR1cF9zZXR0aW5nc19idXR0b25cIlxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuZXcgZXZlbnQgbGlzdGVuZXIuXG4gICAgICogQHBhcmFtIGV2ZW50IC0gZXZlbnQgdG8gbGlzdGVuLlxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciAtIGxpc3RlbmVyIHRvIGFkZC5cbiAgICAgKi9cbiAgICBjKHRoaXMsIFwib25cIiwgKHQsIG4pID0+IHQgPT09IFwiY2xpY2tcIiA/IHcoXCJzZXR0aW5nc19idXR0b25fcHJlc3NlZFwiLCBuKSA6IHRoaXMuc3RhdGUub24odCwgbikpO1xuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGV2ZW50IGxpc3RlbmVyLlxuICAgICAqIEBwYXJhbSBldmVudCAtIGV2ZW50IHRvIGxpc3Rlbi5cbiAgICAgKiBAcGFyYW0gbGlzdGVuZXIgLSBsaXN0ZW5lciB0byByZW1vdmUuXG4gICAgICovXG4gICAgYyh0aGlzLCBcIm9mZlwiLCAodCwgbikgPT4gdCA9PT0gXCJjbGlja1wiID8gQihcInNldHRpbmdzX2J1dHRvbl9wcmVzc2VkXCIsIG4pIDogdGhpcy5zdGF0ZS5vZmYodCwgbikpO1xuICAgIHRoaXMucG9zdEV2ZW50ID0gcjtcbiAgfVxuICBzZXQgaXNWaXNpYmxlKHQpIHtcbiAgICB0aGlzLnNldChcImlzVmlzaWJsZVwiLCB0KSwgdGhpcy5wb3N0RXZlbnQoXCJ3ZWJfYXBwX3NldHVwX3NldHRpbmdzX2J1dHRvblwiLCB7IGlzX3Zpc2libGU6IHQgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFRydWUgaWYgdGhlIFNldHRpbmdzQnV0dG9uIGlzIHZpc2libGUuXG4gICAqL1xuICBnZXQgaXNWaXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcImlzVmlzaWJsZVwiKTtcbiAgfVxuICAvKipcbiAgICogSGlkZXMgdGhlIFNldHRpbmdzQnV0dG9uLlxuICAgKi9cbiAgaGlkZSgpIHtcbiAgICB0aGlzLmlzVmlzaWJsZSA9ICExO1xuICB9XG4gIC8qKlxuICAgKiBTaG93cyB0aGUgU2V0dGluZ3NCdXR0b24uXG4gICAqL1xuICBzaG93KCkge1xuICAgIHRoaXMuaXNWaXNpYmxlID0gITA7XG4gIH1cbn1cbmNvbnN0IGZzID0gbChcbiAgXCJzZXR0aW5nc0J1dHRvblwiLFxuICAoe1xuICAgIHZlcnNpb246IHMsXG4gICAgcG9zdEV2ZW50OiBlLFxuICAgIHN0YXRlOiB0ID0geyBpc1Zpc2libGU6ICExIH1cbiAgfSkgPT4gbmV3IFV0KHQuaXNWaXNpYmxlLCBzLCBlKVxuKTtcbmNsYXNzIEh0IGV4dGVuZHMgUCB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIG4pIHtcbiAgICBzdXBlcih7IGlzVmVydGljYWxTd2lwZUVuYWJsZWQ6IGUgfSwgdCwge1xuICAgICAgZGlzYWJsZVZlcnRpY2FsU3dpcGU6IFwid2ViX2FwcF9zZXR1cF9zd2lwZV9iZWhhdmlvclwiLFxuICAgICAgZW5hYmxlVmVydGljYWxTd2lwZTogXCJ3ZWJfYXBwX3NldHVwX3N3aXBlX2JlaGF2aW9yXCJcbiAgICB9KSwgdGhpcy5wb3N0RXZlbnQgPSBuO1xuICB9XG4gIHNldCBpc1ZlcnRpY2FsU3dpcGVFbmFibGVkKGUpIHtcbiAgICB0aGlzLnNldChcImlzVmVydGljYWxTd2lwZUVuYWJsZWRcIiwgZSksIHRoaXMucG9zdEV2ZW50KFwid2ViX2FwcF9zZXR1cF9zd2lwZV9iZWhhdmlvclwiLCB7IGFsbG93X3ZlcnRpY2FsX3N3aXBlOiBlIH0pO1xuICB9XG4gIC8qKlxuICAgKiBUcnVlLCBpZiB0aGUgdmVydGljYWwgc3dpcGUgZW5hYmxlZC5cbiAgICovXG4gIGdldCBpc1ZlcnRpY2FsU3dpcGVFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcImlzVmVydGljYWxTd2lwZUVuYWJsZWRcIik7XG4gIH1cbiAgLyoqXG4gICAqIERpc2FibGVzIHRoZSB2ZXJ0aWNhbCBzd2lwZS5cbiAgICovXG4gIGRpc2FibGVWZXJ0aWNhbFN3aXBlKCkge1xuICAgIHRoaXMuaXNWZXJ0aWNhbFN3aXBlRW5hYmxlZCA9ICExO1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGVzIHRoZSB2ZXJ0aWNhbCBzd2lwZS5cbiAgICovXG4gIGVuYWJsZVZlcnRpY2FsU3dpcGUoKSB7XG4gICAgdGhpcy5pc1ZlcnRpY2FsU3dpcGVFbmFibGVkID0gITA7XG4gIH1cbn1cbmNvbnN0IGdzID0gbChcbiAgXCJzd2lwZUJlaGF2aW9yXCIsXG4gICh7XG4gICAgcG9zdEV2ZW50OiBzLFxuICAgIHN0YXRlOiBlID0geyBpc1ZlcnRpY2FsU3dpcGVFbmFibGVkOiAhMCB9LFxuICAgIHZlcnNpb246IHRcbiAgfSkgPT4gbmV3IEh0KGUuaXNWZXJ0aWNhbFN3aXBlRW5hYmxlZCwgdCwgcylcbik7XG5mdW5jdGlvbiBEZShzKSB7XG4gIHJldHVybiBQZSgpLnBhcnNlKHMpO1xufVxuY2xhc3MgT3QgZXh0ZW5kcyBlZSB7XG4gIC8qKlxuICAgKiBAc2luY2UgdjYuMTBcbiAgICovXG4gIGdldCBhY2NlbnRUZXh0Q29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFwiYWNjZW50VGV4dENvbG9yXCIpO1xuICB9XG4gIGdldCBiZ0NvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcImJnQ29sb3JcIik7XG4gIH1cbiAgZ2V0IGJ1dHRvbkNvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcImJ1dHRvbkNvbG9yXCIpO1xuICB9XG4gIGdldCBidXR0b25UZXh0Q29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFwiYnV0dG9uVGV4dENvbG9yXCIpO1xuICB9XG4gIGdldCBkZXN0cnVjdGl2ZVRleHRDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJkZXN0cnVjdGl2ZVRleHRDb2xvclwiKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY29weSBvZiB0aGUgaW50ZXJuYWwgc3RhdGUgb2YgdGhlIGN1cnJlbnQgY29tcG9uZW50IGluc3RhbmNlLlxuICAgKi9cbiAgZ2V0U3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcbiAgfVxuICAvKipcbiAgICogQHNpbmNlIHY2LjEwXG4gICAqL1xuICBnZXQgaGVhZGVyQmdDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJoZWFkZXJCZ0NvbG9yXCIpO1xuICB9XG4gIGdldCBoaW50Q29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFwiaGludENvbG9yXCIpO1xuICB9XG4gIC8qKlxuICAgKiBAcmV0dXJucyBUcnVlIGluIGNhc2UsIGN1cnJlbnQgY29sb3Igc2NoZW1lIGlzIHJlY29nbml6ZWQgYXMgZGFyay4gVGhpc1xuICAgKiB2YWx1ZSBpcyBjYWxjdWxhdGVkIGFjY29yZGluZyB0byB0aGVtZSBiZyBjb2xvci5cbiAgICovXG4gIGdldCBpc0RhcmsoKSB7XG4gICAgcmV0dXJuICF0aGlzLmJnQ29sb3IgfHwgeWUodGhpcy5iZ0NvbG9yKTtcbiAgfVxuICBnZXQgbGlua0NvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcImxpbmtDb2xvclwiKTtcbiAgfVxuICBnZXQgc2Vjb25kYXJ5QmdDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJzZWNvbmRhcnlCZ0NvbG9yXCIpO1xuICB9XG4gIC8qKlxuICAgKiBAc2luY2UgdjYuMTBcbiAgICovXG4gIGdldCBzZWN0aW9uQmdDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJzZWN0aW9uQmdDb2xvclwiKTtcbiAgfVxuICAvKipcbiAgICogQHNpbmNlIHY2LjEwXG4gICAqL1xuICBnZXQgc2VjdGlvbkhlYWRlclRleHRDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJzZWN0aW9uSGVhZGVyVGV4dENvbG9yXCIpO1xuICB9XG4gIC8qKlxuICAgKiBAc2luY2UgdjcuNlxuICAgKi9cbiAgZ2V0IHNlY3Rpb25TZXBhcmF0b3JDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJzZWN0aW9uSGVhZGVyVGV4dENvbG9yXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTdGFydHMgbGlzdGVuaW5nIHRvIHRoZSBleHRlcm5hbCB0aGVtZSBjaGFuZ2VzIGFuZCBhcHBsaWVzIHRoZW0uXG4gICAqIEByZXR1cm5zIEZ1bmN0aW9uIHRvIHN0b3AgbGlzdGVuaW5nLlxuICAgKi9cbiAgbGlzdGVuKCkge1xuICAgIHJldHVybiB3KFwidGhlbWVfY2hhbmdlZFwiLCAoZSkgPT4ge1xuICAgICAgdGhpcy5zZXQoRGUoZS50aGVtZV9wYXJhbXMpKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQHNpbmNlIHY2LjEwXG4gICAqL1xuICBnZXQgc3VidGl0bGVUZXh0Q29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFwic3VidGl0bGVUZXh0Q29sb3JcIik7XG4gIH1cbiAgZ2V0IHRleHRDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJ0ZXh0Q29sb3JcIik7XG4gIH1cbn1cbmNvbnN0IHdzID0gbChcbiAgXCJ0aGVtZVBhcmFtc1wiLFxuICAoeyB0aGVtZVBhcmFtczogcywgc3RhdGU6IGUgPSBzLCBhZGRDbGVhbnVwOiB0IH0pID0+IHtcbiAgICBjb25zdCBuID0gbmV3IE90KGUpO1xuICAgIHJldHVybiB0KG4ubGlzdGVuKCkpLCBuO1xuICB9XG4pO1xuZnVuY3Rpb24gYnMocyA9IHt9KSB7XG4gIHJldHVybiBkKHtcbiAgICAuLi5zLFxuICAgIG1ldGhvZDogXCJ3ZWJfYXBwX3JlcXVlc3RfdGhlbWVcIixcbiAgICBldmVudDogXCJ0aGVtZV9jaGFuZ2VkXCJcbiAgfSkudGhlbihEZSk7XG59XG5mdW5jdGlvbiBJKHMsIGUpIHtcbiAgcmV0dXJuIHMuc3RhcnRzV2l0aChlKSA/IHMgOiBgJHtlfSR7c31gO1xufVxuZnVuY3Rpb24gcShzKSB7XG4gIHJldHVybiBuZXcgVVJMKFxuICAgIHR5cGVvZiBzID09IFwic3RyaW5nXCIgPyBzIDogYCR7cy5wYXRobmFtZSB8fCBcIlwifSR7SShzLnNlYXJjaCB8fCBcIlwiLCBcIj9cIil9JHtJKHMuaGFzaCB8fCBcIlwiLCBcIiNcIil9YCxcbiAgICBcImh0dHA6Ly9hXCJcbiAgKTtcbn1cbmNsYXNzIEd0IGV4dGVuZHMgdGUge1xuICBjb25zdHJ1Y3Rvcih0LCBuLCByKSB7XG4gICAgc3VwZXIodCwgeyByZWFkVGV4dEZyb21DbGlwYm9hcmQ6IFwid2ViX2FwcF9yZWFkX3RleHRfZnJvbV9jbGlwYm9hcmRcIiB9KTtcbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgc3BlY2lmaWVkIG1ldGhvZCBwYXJhbWV0ZXIgaXMgc3VwcG9ydGVkIGJ5IGN1cnJlbnQgY29tcG9uZW50LlxuICAgICAqL1xuICAgIGModGhpcywgXCJzdXBwb3J0c1BhcmFtXCIpO1xuICAgIHRoaXMudmVyc2lvbiA9IHQsIHRoaXMuY3JlYXRlUmVxdWVzdElkID0gbiwgdGhpcy5wb3N0RXZlbnQgPSByLCB0aGlzLnN1cHBvcnRzUGFyYW0gPSBWZSh0LCB7XG4gICAgICBcIm9wZW5MaW5rLnRyeUluc3RhbnRWaWV3XCI6IFtcIndlYl9hcHBfb3Blbl9saW5rXCIsIFwidHJ5X2luc3RhbnRfdmlld1wiXVxuICAgIH0pO1xuICB9XG4gIG9wZW5MaW5rKHQsIG4pIHtcbiAgICBjb25zdCByID0gcSh0KS50b1N0cmluZygpO1xuICAgIGlmICghdihcIndlYl9hcHBfb3Blbl9saW5rXCIsIHRoaXMudmVyc2lvbikpIHtcbiAgICAgIHdpbmRvdy5vcGVuKHIsIFwiX2JsYW5rXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpID0gdHlwZW9mIG4gPT0gXCJib29sZWFuXCIgPyB7IHRyeUluc3RhbnRWaWV3OiBuIH0gOiBuIHx8IHt9O1xuICAgIHRoaXMucG9zdEV2ZW50KFwid2ViX2FwcF9vcGVuX2xpbmtcIiwge1xuICAgICAgdXJsOiByLFxuICAgICAgdHJ5X2Jyb3dzZXI6IGkudHJ5QnJvd3NlcixcbiAgICAgIHRyeV9pbnN0YW50X3ZpZXc6IGkudHJ5SW5zdGFudFZpZXdcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogT3BlbnMgYSBUZWxlZ3JhbSBsaW5rIGluc2lkZSBUZWxlZ3JhbSBhcHAuIFRoZSBNaW5pIEFwcCB3aWxsIGJlIGNsb3NlZC4gSXQgZXhwZWN0cyBwYXNzaW5nXG4gICAqIGxpbmsgaW4gZnVsbCBmb3JtYXQsIHdpdGggaG9zdG5hbWUgXCJ0Lm1lXCIuXG4gICAqIEBwYXJhbSB1cmwgLSBVUkwgdG8gYmUgb3BlbmVkLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gVVJMIGhhcyBub3QgYWxsb3dlZCBob3N0bmFtZS5cbiAgICovXG4gIG9wZW5UZWxlZ3JhbUxpbmsodCkge1xuICAgIGNvbnN0IHsgaG9zdG5hbWU6IG4sIHBhdGhuYW1lOiByLCBzZWFyY2g6IGkgfSA9IG5ldyBVUkwodCwgXCJodHRwczovL3QubWVcIik7XG4gICAgaWYgKG4gIT09IFwidC5tZVwiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVUkwgaGFzIG5vdCBhbGxvd2VkIGhvc3RuYW1lOiAke259LiBPbmx5IFwidC5tZVwiIGlzIGFsbG93ZWRgKTtcbiAgICBpZiAoIXYoXCJ3ZWJfYXBwX29wZW5fdGdfbGlua1wiLCB0aGlzLnZlcnNpb24pKSB7XG4gICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucG9zdEV2ZW50KFwid2ViX2FwcF9vcGVuX3RnX2xpbmtcIiwgeyBwYXRoX2Z1bGw6IHIgKyBpIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZWFkcyB0ZXh0IGZyb20gY2xpcGJvYXJkIGFuZCByZXR1cm5zIHN0cmluZyBvciBudWxsLiBudWxsIGlzIHJldHVybmVkXG4gICAqIGluIGNhc2VzOlxuICAgKiAtIFZhbHVlIGluIGNsaXBib2FyZCBpcyBub3QgdGV4dFxuICAgKiAtIEFjY2VzcyB0byBjbGlwYm9hcmQgaXMgbm90IGFsbG93ZWRcbiAgICovXG4gIGFzeW5jIHJlYWRUZXh0RnJvbUNsaXBib2FyZCgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5jcmVhdGVSZXF1ZXN0SWQoKSwge1xuICAgICAgZGF0YTogbiA9IG51bGxcbiAgICB9ID0gYXdhaXQgZCh7XG4gICAgICBtZXRob2Q6IFwid2ViX2FwcF9yZWFkX3RleHRfZnJvbV9jbGlwYm9hcmRcIixcbiAgICAgIGV2ZW50OiBcImNsaXBib2FyZF90ZXh0X3JlY2VpdmVkXCIsXG4gICAgICBwb3N0RXZlbnQ6IHRoaXMucG9zdEV2ZW50LFxuICAgICAgcGFyYW1zOiB7IHJlcV9pZDogdCB9LFxuICAgICAgY2FwdHVyZTogZ2UodClcbiAgICB9KTtcbiAgICByZXR1cm4gbjtcbiAgfVxuICAvKipcbiAgICogU2hhcmVzIHNwZWNpZmllZCBVUkwgd2l0aCB0aGUgcGFzc2VkIHRvIHRoZSBjaGF0cywgc2VsZWN0ZWQgYnkgdXNlci4gQWZ0ZXIgYmVpbmcgY2FsbGVkLFxuICAgKiBpdCBjbG9zZXMgdGhlIG1pbmkgYXBwbGljYXRpb24uXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIHVzZXMgVGVsZWdyYW0ncyBTaGFyZSBMaW5rcy5cbiAgICogQHBhcmFtIHVybCAtIFVSTCB0byBzaGFyZS5cbiAgICogQHBhcmFtIHRleHQgLSB0ZXh0IHRvIGFwcGVuZCBhZnRlciB0aGUgVVJMLlxuICAgKiBAc2VlIGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYXBpL2xpbmtzI3NoYXJlLWxpbmtzXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy93aWRnZXRzL3NoYXJlI2N1c3RvbS1idXR0b25zXG4gICAqL1xuICBzaGFyZVVSTCh0LCBuKSB7XG4gICAgdGhpcy5vcGVuVGVsZWdyYW1MaW5rKFxuICAgICAgXCJodHRwczovL3QubWUvc2hhcmUvdXJsP1wiICsgbmV3IFVSTFNlYXJjaFBhcmFtcyh7IHVybDogdCwgdGV4dDogbiB8fCBcIlwiIH0pLnRvU3RyaW5nKCkucmVwbGFjZSgvXFwrL2csIFwiJTIwXCIpXG4gICAgKTtcbiAgfVxufVxuY29uc3QgbXMgPSBsKFxuICAoeyB2ZXJzaW9uOiBzLCBwb3N0RXZlbnQ6IGUsIGNyZWF0ZVJlcXVlc3RJZDogdCB9KSA9PiBuZXcgR3QocywgdCwgZSlcbik7XG5hc3luYyBmdW5jdGlvbiBNZShzID0ge30pIHtcbiAgY29uc3Qge1xuICAgIGlzX2V4cGFuZGVkOiBlLFxuICAgIGlzX3N0YXRlX3N0YWJsZTogdCxcbiAgICAuLi5uXG4gIH0gPSBhd2FpdCBkKHtcbiAgICAuLi5zLFxuICAgIG1ldGhvZDogXCJ3ZWJfYXBwX3JlcXVlc3Rfdmlld3BvcnRcIixcbiAgICBldmVudDogXCJ2aWV3cG9ydF9jaGFuZ2VkXCJcbiAgfSk7XG4gIHJldHVybiB7IC4uLm4sIGlzRXhwYW5kZWQ6IGUsIGlzU3RhdGVTdGFibGU6IHQgfTtcbn1cbmZ1bmN0aW9uIHgocykge1xuICByZXR1cm4gcyA8IDAgPyAwIDogcztcbn1cbmNsYXNzIGp0IGV4dGVuZHMgZWUge1xuICBjb25zdHJ1Y3Rvcih7IHBvc3RFdmVudDogdCwgc3RhYmxlSGVpZ2h0OiBuLCBoZWlnaHQ6IHIsIHdpZHRoOiBpLCBpc0V4cGFuZGVkOiBvIH0pIHtcbiAgICBzdXBlcih7XG4gICAgICBoZWlnaHQ6IHgociksXG4gICAgICBpc0V4cGFuZGVkOiBvLFxuICAgICAgc3RhYmxlSGVpZ2h0OiB4KG4pLFxuICAgICAgd2lkdGg6IHgoaSlcbiAgICB9KTtcbiAgICBjKHRoaXMsIFwicG9zdEV2ZW50XCIpO1xuICAgIHRoaXMucG9zdEV2ZW50ID0gdDtcbiAgfVxuICAvKipcbiAgICogUmVxdWVzdHMgdmlld3BvcnQgaW5mb3JtYXRpb24gZnJvbSB0aGUgVGVsZWdyYW0gYXBwbGljYXRpb24gYW5kIHVwZGF0ZXMgY3VycmVudCBWaWV3cG9ydFxuICAgKiBpbnN0YW5jZS5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBvcHRpb25zIHRvIHJlcXVlc3QgZnJlc2ggZGF0YS5cbiAgICovXG4gIGFzeW5jIHN5bmModCkge1xuICAgIGNvbnN0IHsgaXNTdGF0ZVN0YWJsZTogbiwgLi4uciB9ID0gYXdhaXQgTWUodCk7XG4gICAgdGhpcy5zZXQoe1xuICAgICAgLi4ucixcbiAgICAgIHN0YWJsZUhlaWdodDogbiA/IHIuaGVpZ2h0IDogdGhpcy5nZXQoXCJzdGFibGVIZWlnaHRcIilcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgaGVpZ2h0IG9mIHRoZSAqKnZpc2libGUgYXJlYSoqIG9mIHRoZSBNaW5pIEFwcC5cbiAgICpcbiAgICogVGhlIGFwcGxpY2F0aW9uIGNhbiBkaXNwbGF5IGp1c3QgdGhlIHRvcCBwYXJ0IG9mIHRoZSBNaW5pIEFwcCwgd2l0aCBpdHMgbG93ZXIgcGFydCByZW1haW5pbmdcbiAgICogb3V0c2lkZSB0aGUgc2NyZWVuIGFyZWEuIEZyb20gdGhpcyBwb3NpdGlvbiwgdGhlIHVzZXIgY2FuIFwicHVsbFwiIHRoZSBNaW5pIEFwcCB0byBpdHNcbiAgICogbWF4aW11bSBoZWlnaHQsIHdoaWxlIHRoZSBib3QgY2FuIGRvIHRoZSBzYW1lIGJ5IGNhbGxpbmcgYGV4cGFuZGAgbWV0aG9kLiBBcyB0aGUgcG9zaXRpb24gb2ZcbiAgICogdGhlIE1pbmkgQXBwIGNoYW5nZXMsIHRoZSBjdXJyZW50IGhlaWdodCB2YWx1ZSBvZiB0aGUgdmlzaWJsZSBhcmVhIHdpbGwgYmUgdXBkYXRlZCAgaW4gcmVhbFxuICAgKiB0aW1lLlxuICAgKlxuICAgKiBQbGVhc2Ugbm90ZSB0aGF0IHRoZSByZWZyZXNoIHJhdGUgb2YgdGhpcyB2YWx1ZSBpcyBub3Qgc3VmZmljaWVudCB0byBzbW9vdGhseSBmb2xsb3cgdGhlXG4gICAqIGxvd2VyIGJvcmRlciBvZiB0aGUgd2luZG93LiBJdCBzaG91bGQgbm90IGJlIHVzZWQgdG8gcGluIGludGVyZmFjZSBlbGVtZW50cyB0byB0aGUgYm90dG9tXG4gICAqIG9mIHRoZSB2aXNpYmxlIGFyZWEuIEl0J3MgbW9yZSBhcHByb3ByaWF0ZSB0byB1c2UgdGhlIHZhbHVlIG9mIHRoZSBgc3RhYmxlSGVpZ2h0YFxuICAgKiBmaWVsZCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgKlxuICAgKiBAc2VlIHN0YWJsZUhlaWdodFxuICAgKi9cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJoZWlnaHRcIik7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBoZWlnaHQgb2YgdGhlIHZpc2libGUgYXJlYSBvZiB0aGUgTWluaSBBcHAgaW4gaXRzIGxhc3Qgc3RhYmxlIHN0YXRlLlxuICAgKlxuICAgKiBUaGUgYXBwbGljYXRpb24gY2FuIGRpc3BsYXkganVzdCB0aGUgdG9wIHBhcnQgb2YgdGhlIE1pbmkgQXBwLCB3aXRoIGl0cyBsb3dlciBwYXJ0IHJlbWFpbmluZ1xuICAgKiBvdXRzaWRlIHRoZSBzY3JlZW4gYXJlYS4gRnJvbSB0aGlzIHBvc2l0aW9uLCB0aGUgdXNlciBjYW4gXCJwdWxsXCIgdGhlIE1pbmkgQXBwIHRvIGl0c1xuICAgKiBtYXhpbXVtIGhlaWdodCwgd2hpbGUgdGhlIGFwcGxpY2F0aW9uIGNhbiBkbyB0aGUgc2FtZSBieSBjYWxsaW5nIGBleHBhbmRgIG1ldGhvZC5cbiAgICpcbiAgICogVW5saWtlIHRoZSB2YWx1ZSBvZiBgaGVpZ2h0YCwgdGhlIHZhbHVlIG9mIGBzdGFibGVIZWlnaHRgIGRvZXMgbm90IGNoYW5nZSBhcyB0aGUgcG9zaXRpb25cbiAgICogb2YgdGhlIE1pbmkgQXBwIGNoYW5nZXMgd2l0aCB1c2VyIGdlc3R1cmVzIG9yIGR1cmluZyBhbmltYXRpb25zLiBUaGUgdmFsdWUgb2YgYHN0YWJsZUhlaWdodGBcbiAgICogd2lsbCBiZSB1cGRhdGVkIGFmdGVyIGFsbCBnZXN0dXJlcyBhbmQgYW5pbWF0aW9ucyBhcmUgY29tcGxldGVkIGFuZFxuICAgKiB0aGUgTWluaSBBcHAgcmVhY2hlcyBpdHMgZmluYWwgc2l6ZS5cbiAgICpcbiAgICogQHNlZSBoZWlnaHRcbiAgICovXG4gIGdldCBzdGFibGVIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFwic3RhYmxlSGVpZ2h0XCIpO1xuICB9XG4gIC8qKlxuICAgKiBTdGFydHMgbGlzdGVuaW5nIHRvIHZpZXdwb3J0IGNoYW5nZXMgYW5kIGFwcGxpZXMgdGhlbS5cbiAgICogQHJldHVybnMgRnVuY3Rpb24gdG8gc3RvcCBsaXN0ZW5pbmcuXG4gICAqL1xuICBsaXN0ZW4oKSB7XG4gICAgcmV0dXJuIHcoXCJ2aWV3cG9ydF9jaGFuZ2VkXCIsICh0KSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGhlaWdodDogbixcbiAgICAgICAgd2lkdGg6IHIsXG4gICAgICAgIGlzX2V4cGFuZGVkOiBpLFxuICAgICAgICBpc19zdGF0ZV9zdGFibGU6IG9cbiAgICAgIH0gPSB0LCBhID0geChuKTtcbiAgICAgIHRoaXMuc2V0KHtcbiAgICAgICAgaGVpZ2h0OiBhLFxuICAgICAgICBpc0V4cGFuZGVkOiBpLFxuICAgICAgICB3aWR0aDogeChyKSxcbiAgICAgICAgLi4ubyA/IHsgc3RhYmxlSGVpZ2h0OiBhIH0gOiB7fVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFRydWUgaWYgdGhlIE1pbmkgQXBwIGlzIGV4cGFuZGVkIHRvIHRoZSBtYXhpbXVtIGF2YWlsYWJsZSBoZWlnaHQuIE90aGVyd2lzZSwgaWZcbiAgICogdGhlIE1pbmkgQXBwIG9jY3VwaWVzIHBhcnQgb2YgdGhlIHNjcmVlbiBhbmQgY2FuIGJlIGV4cGFuZGVkIHRvIHRoZSBmdWxsIGhlaWdodCB1c2luZ1xuICAgKiBgZXhwYW5kYCBtZXRob2QuXG4gICAqIEBzZWUgZXhwYW5kXG4gICAqL1xuICBnZXQgaXNFeHBhbmRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJpc0V4cGFuZGVkXCIpO1xuICB9XG4gIC8qKlxuICAgKiBDdXJyZW50IHZpc2libGUgYXJlYSB3aWR0aC5cbiAgICovXG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJ3aWR0aFwiKTtcbiAgfVxuICAvKipcbiAgICogQSBtZXRob2QgdGhhdCBleHBhbmRzIHRoZSBNaW5pIEFwcCB0byB0aGUgbWF4aW11bSBhdmFpbGFibGUgaGVpZ2h0LiBUbyBmaW5kIG91dCBpZiB0aGUgTWluaVxuICAgKiBBcHAgaXMgZXhwYW5kZWQgdG8gdGhlIG1heGltdW0gaGVpZ2h0LCByZWZlciB0byB0aGUgdmFsdWUgb2YgdGhlIGBpc0V4cGFuZGVkYC5cbiAgICogQHNlZSBpc0V4cGFuZGVkXG4gICAqL1xuICBleHBhbmQoKSB7XG4gICAgdGhpcy5wb3N0RXZlbnQoXCJ3ZWJfYXBwX2V4cGFuZFwiKSwgdGhpcy5zZXQoXCJpc0V4cGFuZGVkXCIsICEwKTtcbiAgfVxuICAvKipcbiAgICogVHJ1ZSBpZiB0aGUgY3VycmVudCB2aWV3cG9ydCBoZWlnaHQgaXMgc3RhYmxlIGFuZCBpcyBub3QgZ29pbmcgdG8gY2hhbmdlIGluIHRoZSBuZXh0IG1vbWVudC5cbiAgICovXG4gIGdldCBpc1N0YWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFibGVIZWlnaHQgPT09IHRoaXMuaGVpZ2h0O1xuICB9XG59XG5jb25zdCB5cyA9IGwoXG4gIFwidmlld3BvcnRcIixcbiAgYXN5bmMgKHsgc3RhdGU6IHMsIHBsYXRmb3JtOiBlLCBwb3N0RXZlbnQ6IHQsIGFkZENsZWFudXA6IG4gfSkgPT4ge1xuICAgIGxldCByID0gITEsIGkgPSAwLCBvID0gMCwgYSA9IDA7XG4gICAgaWYgKHMpXG4gICAgICByID0gcy5pc0V4cGFuZGVkLCBpID0gcy5oZWlnaHQsIG8gPSBzLndpZHRoLCBhID0gcy5zdGFibGVIZWlnaHQ7XG4gICAgZWxzZSBpZiAoW1wibWFjb3NcIiwgXCJ0ZGVza3RvcFwiLCBcInVuaWdyYW1cIiwgXCJ3ZWJrXCIsIFwid2ViYVwiLCBcIndlYlwiXS5pbmNsdWRlcyhlKSlcbiAgICAgIHIgPSAhMCwgaSA9IHdpbmRvdy5pbm5lckhlaWdodCwgbyA9IHdpbmRvdy5pbm5lcldpZHRoLCBhID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgdSA9IGF3YWl0IE1lKHsgdGltZW91dDogMWUzLCBwb3N0RXZlbnQ6IHQgfSk7XG4gICAgICByID0gdS5pc0V4cGFuZGVkLCBpID0gdS5oZWlnaHQsIG8gPSB1LndpZHRoLCBhID0gdS5pc1N0YXRlU3RhYmxlID8gaSA6IDA7XG4gICAgfVxuICAgIGNvbnN0IHAgPSBuZXcganQoe1xuICAgICAgcG9zdEV2ZW50OiB0LFxuICAgICAgaGVpZ2h0OiBpLFxuICAgICAgd2lkdGg6IG8sXG4gICAgICBzdGFibGVIZWlnaHQ6IGEsXG4gICAgICBpc0V4cGFuZGVkOiByXG4gICAgfSk7XG4gICAgcmV0dXJuIG4ocC5saXN0ZW4oKSksIHA7XG4gIH1cbik7XG5mdW5jdGlvbiBtKHMsIGUpIHtcbiAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KHMsIGUpO1xufVxuZnVuY3Rpb24gdnMocywgZSwgdCkge1xuICB0IHx8ICh0ID0gKGEpID0+IGAtLXRnLSR7YX0tY29sb3JgKTtcbiAgY29uc3QgbiA9IHQoXCJoZWFkZXJcIiksIHIgPSB0KFwiYmdcIiksIGkgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBoZWFkZXJDb2xvcjogYSB9ID0gcztcbiAgICBpZiAoUShhKSlcbiAgICAgIG0obiwgYSk7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCB7IGJnQ29sb3I6IHAsIHNlY29uZGFyeUJnQ29sb3I6IHUgfSA9IGU7XG4gICAgICBhID09PSBcImJnX2NvbG9yXCIgJiYgcCA/IG0obiwgcCkgOiBhID09PSBcInNlY29uZGFyeV9iZ19jb2xvclwiICYmIHUgJiYgbShuLCB1KTtcbiAgICB9XG4gICAgbShyLCBzLmJnQ29sb3IpO1xuICB9LCBvID0gW1xuICAgIGUub24oXCJjaGFuZ2VcIiwgaSksXG4gICAgcy5vbihcImNoYW5nZVwiLCBpKVxuICBdO1xuICByZXR1cm4gaSgpLCAoKSA9PiBvLmZvckVhY2goKGEpID0+IGEoKSk7XG59XG5mdW5jdGlvbiBFcyhzLCBlKSB7XG4gIGUgfHwgKGUgPSAobikgPT4gYC0tdGctdGhlbWUtJHtuLnJlcGxhY2UoL1tBLVpdL2csIChyKSA9PiBgLSR7ci50b0xvd2VyQ2FzZSgpfWApfWApO1xuICBjb25zdCB0ID0gKCkgPT4ge1xuICAgIE9iamVjdC5lbnRyaWVzKHMuZ2V0U3RhdGUoKSkuZm9yRWFjaCgoW24sIHJdKSA9PiB7XG4gICAgICByICYmIG0oZShuKSwgcik7XG4gICAgfSk7XG4gIH07XG4gIHJldHVybiB0KCksIHMub24oXCJjaGFuZ2VcIiwgdCk7XG59XG5mdW5jdGlvbiBTcyhzLCBlKSB7XG4gIGUgfHwgKGUgPSAodSkgPT4gYC0tdGctdmlld3BvcnQtJHt1fWApO1xuICBjb25zdCBbXG4gICAgdCxcbiAgICBuLFxuICAgIHJcbiAgXSA9IFtcImhlaWdodFwiLCBcIndpZHRoXCIsIFwic3RhYmxlLWhlaWdodFwiXS5tYXAoKHUpID0+IGUodSkpLCBpID0gKCkgPT4gbSh0LCBgJHtzLmhlaWdodH1weGApLCBvID0gKCkgPT4gbShuLCBgJHtzLndpZHRofXB4YCksIGEgPSAoKSA9PiBtKHIsIGAke3Muc3RhYmxlSGVpZ2h0fXB4YCksIHAgPSBbXG4gICAgcy5vbihcImNoYW5nZTpoZWlnaHRcIiwgaSksXG4gICAgcy5vbihcImNoYW5nZTp3aWR0aFwiLCBvKSxcbiAgICBzLm9uKFwiY2hhbmdlOnN0YWJsZUhlaWdodFwiLCBhKVxuICBdO1xuICByZXR1cm4gaSgpLCBvKCksIGEoKSwgKCkgPT4gcC5mb3JFYWNoKCh1KSA9PiB1KCkpO1xufVxuZnVuY3Rpb24gUHMocyA9ICEwKSB7XG4gIGNvbnN0IGUgPSBbXG4gICAgdyhcInJlbG9hZF9pZnJhbWVcIiwgKCkgPT4ge1xuICAgICAgQShcImlmcmFtZV93aWxsX3JlbG9hZFwiKSwgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgIH0pXG4gIF0sIHQgPSAoKSA9PiBlLmZvckVhY2goKG4pID0+IG4oKSk7XG4gIGlmIChzKSB7XG4gICAgY29uc3QgbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICBuLmlkID0gXCJ0ZWxlZ3JhbS1jdXN0b20tc3R5bGVzXCIsIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQobiksIGUucHVzaChcbiAgICAgIHcoXCJzZXRfY3VzdG9tX3N0eWxlXCIsIChyKSA9PiB7XG4gICAgICAgIG4uaW5uZXJIVE1MID0gcjtcbiAgICAgIH0pLFxuICAgICAgKCkgPT4gZG9jdW1lbnQuaGVhZC5yZW1vdmVDaGlsZChuKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIEEoXCJpZnJhbWVfcmVhZHlcIiwgeyByZWxvYWRfc3VwcG9ydGVkOiAhMCB9KSwgdDtcbn1cbmZ1bmN0aW9uIHhzKCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyA+IFwidVwiO1xufVxuYXN5bmMgZnVuY3Rpb24gQ3MoKSB7XG4gIGlmIChkZSh3aW5kb3cpKVxuICAgIHJldHVybiAhMDtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgZCh7IG1ldGhvZDogXCJ3ZWJfYXBwX3JlcXVlc3RfdGhlbWVcIiwgZXZlbnQ6IFwidGhlbWVfY2hhbmdlZFwiLCB0aW1lb3V0OiAxMDAgfSksICEwO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gITE7XG4gIH1cbn1cbmZ1bmN0aW9uIFRzKHMpIHtcbiAgY29uc3QgZSA9IHR5cGVvZiBzID09IFwic3RyaW5nXCIgPyBYKHMpIDogcztcbiAgcWUoZSk7XG4gIGZ1bmN0aW9uIHQocikge1xuICAgIGlmICh0eXBlb2YgciA9PSBcInN0cmluZ1wiKVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyBldmVudFR5cGU6IGkgfSA9IHVlKHIpO1xuICAgICAgICBpID09PSBcIndlYl9hcHBfcmVxdWVzdF90aGVtZVwiICYmIGooXCJ0aGVtZV9jaGFuZ2VkXCIsIHtcbiAgICAgICAgICB0aGVtZV9wYXJhbXM6IEpTT04ucGFyc2UoSWUoZS50aGVtZVBhcmFtcykpXG4gICAgICAgIH0pLCBpID09PSBcIndlYl9hcHBfcmVxdWVzdF92aWV3cG9ydFwiICYmIGooXCJ2aWV3cG9ydF9jaGFuZ2VkXCIsIHtcbiAgICAgICAgICB3aWR0aDogd2luZG93LmlubmVyV2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHQsXG4gICAgICAgICAgaXNfc3RhdGVfc3RhYmxlOiAhMCxcbiAgICAgICAgICBpc19leHBhbmRlZDogITBcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgIH1cbiAgfVxuICBpZiAoX2UoKSkge1xuICAgIGNvbnN0IHIgPSB3aW5kb3cucGFyZW50LnBvc3RNZXNzYWdlLmJpbmQod2luZG93LnBhcmVudCk7XG4gICAgd2luZG93LnBhcmVudC5wb3N0TWVzc2FnZSA9IChpKSA9PiB7XG4gICAgICB0KGkpLCByKGkpO1xuICAgIH07XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChsZSh3aW5kb3cpKSB7XG4gICAgY29uc3QgciA9IHdpbmRvdy5leHRlcm5hbC5ub3RpZnkuYmluZCh3aW5kb3cuZXh0ZXJuYWwpO1xuICAgIHdpbmRvdy5leHRlcm5hbC5ub3RpZnkgPSAoaSkgPT4ge1xuICAgICAgdChpKSwgcihpKTtcbiAgICB9O1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBuID0gd2luZG93LlRlbGVncmFtV2Vidmlld1Byb3h5O1xuICB3aW5kb3cuVGVsZWdyYW1XZWJ2aWV3UHJveHkgPSB7XG4gICAgLi4ubiB8fCB7fSxcbiAgICBwb3N0RXZlbnQoLi4ucikge1xuICAgICAgdChKU09OLnN0cmluZ2lmeSh7IGV2ZW50VHlwZTogclswXSwgZXZlbnREYXRhOiByWzFdIH0pKSwgbiAmJiBuLnBvc3RFdmVudCguLi5yKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiB6dChzKSB7XG4gIHJldHVybiBzIGluc3RhbmNlb2YgVjtcbn1cbmZ1bmN0aW9uIFJzKHMsIGUpIHtcbiAgcmV0dXJuIHp0KHMpICYmIHMudHlwZSA9PT0gZTtcbn1cbmZ1bmN0aW9uIEwocywgZSkge1xuICBsZXQgdCwgbiwgcjtcbiAgcmV0dXJuIHR5cGVvZiBzID09IFwic3RyaW5nXCIgPyB0ID0gcyA6ICh0ID0gcy5wYXRobmFtZSA9PT0gdm9pZCAwID8gZSA6IHMucGF0aG5hbWUsIG4gPSBzLnBhcmFtcywgciA9IHMuaWQpLCBPYmplY3QuZnJlZXplKHtcbiAgICBpZDogciB8fCAoTWF0aC5yYW5kb20oKSAqIDIgKiogMTQgfCAwKS50b1N0cmluZygxNiksXG4gICAgcGF0aG5hbWU6IHQsXG4gICAgcGFyYW1zOiBuXG4gIH0pO1xufVxuY2xhc3MgRnQge1xuICBjb25zdHJ1Y3RvcihlLCB0LCBuID0gQSkge1xuICAgIC8qKlxuICAgICAqIE5hdmlnYXRpb24gaGlzdG9yeS5cbiAgICAgKi9cbiAgICBjKHRoaXMsIFwiaGlzdG9yeVwiKTtcbiAgICBjKHRoaXMsIFwiZWVcIiwgbmV3IFIoKSk7XG4gICAgLyoqXG4gICAgICogVHJ1ZSwgaWYgY3VycmVudCBuYXZpZ2F0b3IgaXMgY3VycmVudGx5IGF0dGFjaGVkLlxuICAgICAqL1xuICAgIGModGhpcywgXCJhdHRhY2hlZFwiLCAhMSk7XG4gICAgLyoqXG4gICAgICogR29lcyB0byB0aGUgcHJldmlvdXMgaGlzdG9yeSBpdGVtLlxuICAgICAqL1xuICAgIGModGhpcywgXCJiYWNrXCIsICgpID0+IHRoaXMuZ28oLTEpKTtcbiAgICAvKipcbiAgICAgKiBBZGRzIG5ldyBldmVudCBsaXN0ZW5lci5cbiAgICAgKi9cbiAgICBjKHRoaXMsIFwib25cIiwgdGhpcy5lZS5vbi5iaW5kKHRoaXMuZWUpKTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGV2ZW50IGxpc3RlbmVyLlxuICAgICAqL1xuICAgIGModGhpcywgXCJvZmZcIiwgdGhpcy5lZS5vZmYuYmluZCh0aGlzLmVlKSk7XG4gICAgaWYgKHRoaXMuX2luZGV4ID0gdCwgdGhpcy5wb3N0RXZlbnQgPSBuLCBlLmxlbmd0aCA9PT0gMClcbiAgICAgIHRocm93IGYoWmUsIFwiSGlzdG9yeSBzaG91bGQgbm90IGJlIGVtcHR5LlwiKTtcbiAgICBpZiAodCA8IDAgfHwgdCA+PSBlLmxlbmd0aClcbiAgICAgIHRocm93IGYoXG4gICAgICAgIEtlLFxuICAgICAgICBcIkluZGV4IHNob3VsZCBub3QgYmUgemVybyBhbmQgaGlnaGVyIG9yIGVxdWFsIHRoYW4gaGlzdG9yeSBzaXplLlwiXG4gICAgICApO1xuICAgIHRoaXMuaGlzdG9yeSA9IGUubWFwKChyKSA9PiBMKHIsIFwiXCIpKTtcbiAgfVxuICAvKipcbiAgICogQWxsb3dzIHRoaXMgbmF2aWdhdG9yIHRvIGNvbnRyb2wgdGhlIGBCYWNrQnV0dG9uYCB2aXNpYmlsaXR5IHN0YXRlLiBJdCBhbHNvIHRyYWNrcyB0aGVcbiAgICogYEJhY2tCdXR0b25gIGNsaWNrcyBhbmQgY2FsbHMgdGhlIGBiYWNrYCBtZXRob2QuXG4gICAqL1xuICBhdHRhY2goKSB7XG4gICAgdGhpcy5hdHRhY2hlZCB8fCAodGhpcy5hdHRhY2hlZCA9ICEwLCB0aGlzLnN5bmMoKSwgdyhcImJhY2tfYnV0dG9uX3ByZXNzZWRcIiwgdGhpcy5iYWNrKSk7XG4gIH1cbiAgLyoqXG4gICAqIEN1cnJlbnRseSBhY3RpdmUgaGlzdG9yeSBpdGVtLlxuICAgKi9cbiAgZ2V0IGN1cnJlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGlzdG9yeVt0aGlzLmluZGV4XTtcbiAgfVxuICAvKipcbiAgICogUHJldmVudHMgY3VycmVudCBuYXZpZ2F0b3IgZnJvbSBjb250cm9sbGluZyB0aGUgQmFja0J1dHRvbiB2aXNpYmlsaXR5IHN0YXRlLlxuICAgKi9cbiAgZGV0YWNoKCkge1xuICAgIHRoaXMuYXR0YWNoZWQgPSAhMSwgQihcImJhY2tfYnV0dG9uX3ByZXNzZWRcIiwgdGhpcy5iYWNrKTtcbiAgfVxuICAvKipcbiAgICogR29lcyB0byB0aGUgbmV4dCBoaXN0b3J5IGl0ZW0uXG4gICAqL1xuICBmb3J3YXJkKCkge1xuICAgIHRoaXMuZ28oMSk7XG4gIH1cbiAgLyoqXG4gICAqIENoYW5nZXMgY3VycmVudGx5IGFjdGl2ZSBoaXN0b3J5IGl0ZW0gaW5kZXggYnkgdGhlIHNwZWNpZmllZCBkZWx0YS4gVGhpcyBtZXRob2QgZG9lc24ndFxuICAgKiBjaGFuZ2UgaW5kZXggaW4gY2FzZSwgdGhlIHVwZGF0ZWQgaW5kZXggcG9pbnRzIHRvIHRoZSBub24tZXhpc3RpbmcgaGlzdG9yeSBpdGVtLiBUaGlzIGJlaGF2aW9yXG4gICAqIGlzIHByZXNlcnZlZCB1bnRpbCB0aGUgYGZpdGAgYXJndW1lbnQgaXMgc3BlY2lmaWVkLlxuICAgKiBAcGFyYW0gZGVsdGEgLSBpbmRleCBkZWx0YS5cbiAgICogQHBhcmFtIGZpdCAtIGN1dHMgdGhlIGRlbHRhIGFyZ3VtZW50IHRvIGZpdCB0aGUgYm91bmRzIGBbMCwgaGlzdG9yeS5sZW5ndGggLSAxXWAuXG4gICAqL1xuICBnbyhlLCB0KSB7XG4gICAgY29uc3QgbiA9IHRoaXMuaW5kZXggKyBlLCByID0gTWF0aC5taW4oXG4gICAgICBNYXRoLm1heCgwLCBuKSxcbiAgICAgIHRoaXMuaGlzdG9yeS5sZW5ndGggLSAxXG4gICAgKTtcbiAgICAobiA9PT0gciB8fCB0KSAmJiB0aGlzLnJlcGxhY2VBbmRNb3ZlKHIsIHRoaXMuaGlzdG9yeVtyXSk7XG4gIH1cbiAgLyoqXG4gICAqIEdvZXMgdG8gdGhlIHNwZWNpZmllZCBpbmRleC4gTWV0aG9kIGRvZXMgbm90aGluZyBpbiBjYXNlLCBwYXNzZWQgaW5kZXggaXMgb3V0IG9mIGJvdW5kcy5cbiAgICpcbiAgICogSWYgXCJmaXRcIiBvcHRpb24gd2FzIHNwZWNpZmllZCBhbmQgaW5kZXggaXMgb3V0IG9mIGJvdW5kcywgaXQgd2lsbCBiZSBjdXQgdG8gdGhlIG5lYXJlc3RcbiAgICogYm91bmQuXG4gICAqIEBwYXJhbSBpbmRleCAtIHRhcmdldCBpbmRleC5cbiAgICogQHBhcmFtIGZpdCAtIGN1dHMgdGhlIGluZGV4IGFyZ3VtZW50IHRvIGZpdCB0aGUgYm91bmRzIGBbMCwgaGlzdG9yeS5sZW5ndGggLSAxXWAuXG4gICAqL1xuICBnb1RvKGUsIHQpIHtcbiAgICB0aGlzLmdvKGUgLSB0aGlzLmluZGV4LCB0KTtcbiAgfVxuICAvKipcbiAgICogVHJ1ZSBpZiBuYXZpZ2F0b3IgaGFzIGl0ZW1zIGJlZm9yZSB0aGUgY3VycmVudCBpdGVtLlxuICAgKi9cbiAgZ2V0IGhhc1ByZXYoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXggPiAwO1xuICB9XG4gIC8qKlxuICAgKiBUcnVlIGlmIG5hdmlnYXRvciBoYXMgaXRlbXMgYWZ0ZXIgdGhlIGN1cnJlbnQgaXRlbS5cbiAgICovXG4gIGdldCBoYXNOZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmluZGV4ICE9PSB0aGlzLmhpc3RvcnkubGVuZ3RoIC0gMTtcbiAgfVxuICAvKipcbiAgICogQ3VycmVudGx5IGFjdGl2ZSBoaXN0b3J5IGl0ZW0gaW5kZXguXG4gICAqL1xuICBnZXQgaW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luZGV4O1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgbmV3IGhpc3RvcnkgaXRlbSByZW1vdmluZyBhbGwgYWZ0ZXIgdGhlIGN1cnJlbnQgb25lLlxuICAgKiBAcGFyYW0gaXRlbSAtIGl0ZW0gdG8gYWRkLlxuICAgKi9cbiAgcHVzaChlKSB7XG4gICAgdGhpcy5oYXNOZXh0ICYmIHRoaXMuaGlzdG9yeS5zcGxpY2UodGhpcy5pbmRleCArIDEpLCB0aGlzLnJlcGxhY2VBbmRNb3ZlKHRoaXMuaW5kZXggKyAxLCBMKGUsIHRoaXMuY3VycmVudC5wYXRobmFtZSkpO1xuICB9XG4gIC8qKlxuICAgKiBSZXBsYWNlcyB0aGUgY3VycmVudCBoaXN0b3J5IGl0ZW0uXG4gICAqIEBwYXJhbSBpdGVtIC0gaXRlbSB0byByZXBsYWNlIHRoZSBjdXJyZW50IGl0ZW0gd2l0aC5cbiAgICovXG4gIHJlcGxhY2UoZSkge1xuICAgIHRoaXMucmVwbGFjZUFuZE1vdmUodGhpcy5pbmRleCwgTChlLCB0aGlzLmN1cnJlbnQucGF0aG5hbWUpKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyBoaXN0b3J5IGl0ZW0gYnkgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICogQHBhcmFtIGluZGV4IC0gaGlzdG9yeSBpdGVtIGluZGV4IHRvIHJlcGxhY2UuXG4gICAqIEBwYXJhbSBoaXN0b3J5SXRlbSAtIGhpc3RvcnkgaXRlbSB0byBzZXQuXG4gICAqL1xuICByZXBsYWNlQW5kTW92ZShlLCB0KSB7XG4gICAgY29uc3QgbiA9IGUgLSB0aGlzLmluZGV4O1xuICAgIGlmICghbiAmJiB0aGlzLmN1cnJlbnQgPT09IHQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgciA9IHRoaXMuY3VycmVudDtcbiAgICBpZiAodGhpcy5pbmRleCAhPT0gZSkge1xuICAgICAgY29uc3QgaSA9IHRoaXMuX2luZGV4O1xuICAgICAgdGhpcy5faW5kZXggPSBlLCB0aGlzLmF0dGFjaGVkICYmIGkgPiAwICE9IGUgPiAwICYmIHRoaXMuc3luYygpO1xuICAgIH1cbiAgICB0aGlzLmhpc3RvcnlbZV0gPSB0LCB0aGlzLmVlLmVtaXQoXCJjaGFuZ2VcIiwge1xuICAgICAgbmF2aWdhdG9yOiB0aGlzLFxuICAgICAgZnJvbTogcixcbiAgICAgIHRvOiB0aGlzLmN1cnJlbnQsXG4gICAgICBkZWx0YTogblxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBBY3R1YWxpemVzIHRoZSBgQmFja0J1dHRvbmAgdmlzaWJpbGl0eSBzdGF0ZS5cbiAgICovXG4gIHN5bmMoKSB7XG4gICAgdGhpcy5wb3N0RXZlbnQoXCJ3ZWJfYXBwX3NldHVwX2JhY2tfYnV0dG9uXCIsIHsgaXNfdmlzaWJsZTogISF0aGlzLmluZGV4IH0pO1xuICB9XG59XG5mdW5jdGlvbiAkKHtcbiAgcGFyYW1zOiBzLFxuICAuLi5lXG59KSB7XG4gIHJldHVybiB7IC4uLnMgfHwgeyBoYXNoOiBcIlwiLCBzZWFyY2g6IFwiXCIgfSwgLi4uZSB9O1xufVxuZnVuY3Rpb24gTihzKSB7XG4gIGNvbnN0IGUgPSB0eXBlb2YgcyA9PSBcInN0cmluZ1wiID8gcy5zdGFydHNXaXRoKFwiL1wiKSA6ICEhKHMucGF0aG5hbWUgJiYgcy5wYXRobmFtZS5zdGFydHNXaXRoKFwiL1wiKSksIHQgPSBxKHMpO1xuICByZXR1cm4gYCR7ZSA/IHQucGF0aG5hbWUgOiB0LnBhdGhuYW1lLnNsaWNlKDEpfSR7dC5zZWFyY2h9JHt0Lmhhc2h9YDtcbn1cbmZ1bmN0aW9uIFcocywgZSwgdCkge1xuICBsZXQgbiwgcjtcbiAgdHlwZW9mIHMgPT0gXCJzdHJpbmdcIiA/IG4gPSBzIDogKG4gPSBOKHMpLCB0ID0gcy5zdGF0ZSwgciA9IHMuaWQpO1xuICBjb25zdCB7IHBhdGhuYW1lOiBpLCBzZWFyY2g6IG8sIGhhc2g6IGEgfSA9IG5ldyBVUkwobiwgYGh0dHA6Ly9hJHtJKGUsIFwiL1wiKX1gKTtcbiAgcmV0dXJuIHsgaWQ6IHIsIHBhdGhuYW1lOiBpLCBwYXJhbXM6IHsgaGFzaDogYSwgc2VhcmNoOiBvLCBzdGF0ZTogdCB9IH07XG59XG5hc3luYyBmdW5jdGlvbiBUKHMpIHtcbiAgcmV0dXJuIHMgPT09IDAgPyAhMCA6IFByb21pc2UucmFjZShbXG4gICAgbmV3IFByb21pc2UoKGUpID0+IHtcbiAgICAgIGNvbnN0IHQgPSBHKFwicG9wc3RhdGVcIiwgKCkgPT4ge1xuICAgICAgICB0KCksIGUoITApO1xuICAgICAgfSk7XG4gICAgICB3aW5kb3cuaGlzdG9yeS5nbyhzKTtcbiAgICB9KSxcbiAgICAvLyBVc3VhbGx5LCBpdCB0YWtlcyBhYm91dCAxbXMgdG8gZW1pdCB0aGlzIGV2ZW50LCBidXQgd2UgdXNlIHNvbWUgYnVmZmVyLlxuICAgIG5ldyBQcm9taXNlKChlKSA9PiB7XG4gICAgICBzZXRUaW1lb3V0KGUsIDUwLCAhMSk7XG4gICAgfSlcbiAgXSk7XG59XG5hc3luYyBmdW5jdGlvbiBKdCgpIHtcbiAgaWYgKHdpbmRvdy5oaXN0b3J5Lmxlbmd0aCA8PSAxIHx8ICh3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUobnVsbCwgXCJcIiksIGF3YWl0IFQoMSAtIHdpbmRvdy5oaXN0b3J5Lmxlbmd0aCkpKVxuICAgIHJldHVybjtcbiAgbGV0IGUgPSBhd2FpdCBUKC0xKTtcbiAgZm9yICg7IGU7IClcbiAgICBlID0gYXdhaXQgVCgtMSk7XG59XG5mdW5jdGlvbiBCZShzKSB7XG4gIHJldHVybiBxKHMpLnBhdGhuYW1lO1xufVxuY29uc3QgaWUgPSAwLCBVID0gMSwgSCA9IDI7XG5jbGFzcyBMZSB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIHsgcG9zdEV2ZW50OiBuLCBoYXNoTW9kZTogciA9IFwiY2xhc3NpY1wiLCBiYXNlOiBpIH0gPSB7fSkge1xuICAgIGModGhpcywgXCJuYXZpZ2F0b3JcIik7XG4gICAgYyh0aGlzLCBcImVlXCIsIG5ldyBSKCkpO1xuICAgIGModGhpcywgXCJoYXNoTW9kZVwiKTtcbiAgICBjKHRoaXMsIFwiYmFzZVwiKTtcbiAgICAvKipcbiAgICAgKiBTaG93cyB3aGV0aGVyIHRoZSBuYXZpZ2F0b3IgaXMgY3VycmVudGx5IGF0dGFjaGVkIHRvIHRoZSBicm93c2VyIGhpc3RvcnkuXG4gICAgICovXG4gICAgYyh0aGlzLCBcImF0dGFjaGVkXCIsICExKTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHRoZSB3aW5kb3cgXCJwb3BzdGF0ZVwiIGV2ZW50LlxuICAgICAqIEBwYXJhbSBzdGF0ZSAtIGV2ZW50IHN0YXRlLlxuICAgICAqL1xuICAgIGModGhpcywgXCJvblBvcFN0YXRlXCIsICh7IHN0YXRlOiBlIH0pID0+IHtcbiAgICAgIGlmIChlID09PSBudWxsKVxuICAgICAgICByZXR1cm4gdGhpcy5wdXNoKHRoaXMucGFyc2VQYXRoKHdpbmRvdy5sb2NhdGlvbi5ocmVmKSk7XG4gICAgICBlID09PSBpZSA/IHdpbmRvdy5oaXN0b3J5LmZvcndhcmQoKSA6IGUgPT09IFUgJiYgdGhpcy5iYWNrKCksIGUgPT09IEggJiYgdGhpcy5mb3J3YXJkKCk7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogVW5kZXJseWluZyBuYXZpZ2F0b3IgY2hhbmdlIGV2ZW50IGxpc3RlbmVyLlxuICAgICAqL1xuICAgIGModGhpcywgXCJvbk5hdmlnYXRvckNoYW5nZVwiLCBhc3luYyAoe1xuICAgICAgdG86IGUsXG4gICAgICBmcm9tOiB0LFxuICAgICAgZGVsdGE6IG5cbiAgICB9KSA9PiB7XG4gICAgICB0aGlzLmF0dGFjaGVkICYmIGF3YWl0IHRoaXMuc3luY0hpc3RvcnkoKSwgdGhpcy5lZS5lbWl0KFwiY2hhbmdlXCIsIHtcbiAgICAgICAgZGVsdGE6IG4sXG4gICAgICAgIGZyb206ICQodCksXG4gICAgICAgIHRvOiAkKGUpLFxuICAgICAgICBuYXZpZ2F0b3I6IHRoaXNcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEFkZHMgbmV3IGV2ZW50IGxpc3RlbmVyLlxuICAgICAqL1xuICAgIGModGhpcywgXCJvblwiLCB0aGlzLmVlLm9uLmJpbmQodGhpcy5lZSkpO1xuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgZXZlbnQgbGlzdGVuZXIuXG4gICAgICovXG4gICAgYyh0aGlzLCBcIm9mZlwiLCB0aGlzLmVlLm9mZi5iaW5kKHRoaXMuZWUpKTtcbiAgICB0aGlzLm5hdmlnYXRvciA9IG5ldyBGdChcbiAgICAgIGUubWFwKChvKSA9PiBXKG8sIFwiL1wiKSksXG4gICAgICB0LFxuICAgICAgblxuICAgICksIHRoaXMubmF2aWdhdG9yLm9uKFwiY2hhbmdlXCIsIChvKSA9PiB7XG4gICAgICB0aGlzLm9uTmF2aWdhdG9yQ2hhbmdlKG8pO1xuICAgIH0pLCB0aGlzLmhhc2hNb2RlID0gciwgdGhpcy5iYXNlID0gQmUoaSB8fCBcIlwiKTtcbiAgfVxuICAvKipcbiAgICogQXR0YWNoZXMgY3VycmVudCBuYXZpZ2F0b3IgdG8gdGhlIGJyb3dzZXIgaGlzdG9yeSBhbGxvd2luZyBuYXZpZ2F0b3IgdG8gbWFuaXB1bGF0ZSBpdC5cbiAgICovXG4gIGFzeW5jIGF0dGFjaCgpIHtcbiAgICB0aGlzLmF0dGFjaGVkIHx8ICh0aGlzLmF0dGFjaGVkID0gITAsIHRoaXMubmF2aWdhdG9yLmF0dGFjaCgpLCB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvcHN0YXRlXCIsIHRoaXMub25Qb3BTdGF0ZSksIGF3YWl0IHRoaXMuc3luY0hpc3RvcnkoKSk7XG4gIH1cbiAgLyoqXG4gICAqIEdvZXMgYmFjayBpbiBoaXN0b3J5IGJ5IDEuXG4gICAqL1xuICBiYWNrKCkge1xuICAgIHRoaXMubmF2aWdhdG9yLmJhY2soKTtcbiAgfVxuICAvKipcbiAgICogRGV0YWNoZXMgY3VycmVudCBuYXZpZ2F0b3IgZnJvbSB0aGUgYnJvd3NlciBoaXN0b3J5LlxuICAgKi9cbiAgZGV0YWNoKCkge1xuICAgIHRoaXMuYXR0YWNoZWQgPSAhMSwgdGhpcy5uYXZpZ2F0b3IuZGV0YWNoKCksIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9wc3RhdGVcIiwgdGhpcy5vblBvcFN0YXRlKTtcbiAgfVxuICAvKipcbiAgICogR29lcyBmb3J3YXJkIGluIGhpc3RvcnkuXG4gICAqL1xuICBmb3J3YXJkKCkge1xuICAgIHJldHVybiB0aGlzLm5hdmlnYXRvci5mb3J3YXJkKCk7XG4gIH1cbiAgLyoqXG4gICAqIEN1cnJlbnQgaGlzdG9yeSBjdXJzb3IuXG4gICAqL1xuICBnZXQgaW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMubmF2aWdhdG9yLmluZGV4O1xuICB9XG4gIC8qKlxuICAgKiBDdXJyZW50IGhpc3RvcnkgaXRlbSBpZGVudGlmaWVyLlxuICAgKi9cbiAgZ2V0IGlkKCkge1xuICAgIHJldHVybiB0aGlzLm5hdmlnYXRvci5jdXJyZW50LmlkO1xuICB9XG4gIC8qKlxuICAgKiBDaGFuZ2VzIGN1cnJlbnRseSBhY3RpdmUgaGlzdG9yeSBpdGVtIGluZGV4IGJ5IHRoZSBzcGVjaWZpZWQgZGVsdGEuIFRoaXMgbWV0aG9kIGRvZXNuJ3RcbiAgICogY2hhbmdlIGluZGV4IGluIGNhc2UsIHRoZSB1cGRhdGVkIGluZGV4IHBvaW50cyB0byB0aGUgbm9uLWV4aXN0aW5nIGhpc3RvcnkgaXRlbS4gVGhpcyBiZWhhdmlvclxuICAgKiBpcyBwcmVzZXJ2ZWQgdW50aWwgdGhlIGBmaXRgIGFyZ3VtZW50IGlzIHNwZWNpZmllZC5cbiAgICogQHBhcmFtIGRlbHRhIC0gaW5kZXggZGVsdGEuXG4gICAqIEBwYXJhbSBmaXQgLSBjdXRzIHRoZSBkZWx0YSBhcmd1bWVudCB0byBmaXQgdGhlIGJvdW5kcyBgWzAsIGhpc3RvcnkubGVuZ3RoIC0gMV1gLlxuICAgKi9cbiAgZ28oZSwgdCkge1xuICAgIHJldHVybiB0aGlzLm5hdmlnYXRvci5nbyhlLCB0KTtcbiAgfVxuICAvKipcbiAgICogR29lcyB0byB0aGUgc3BlY2lmaWVkIGluZGV4LiBNZXRob2QgZG9lcyBub3RoaW5nIGluIGNhc2UsIHBhc3NlZCBpbmRleCBpcyBvdXQgb2YgYm91bmRzLlxuICAgKlxuICAgKiBJZiBcImZpdFwiIG9wdGlvbiB3YXMgc3BlY2lmaWVkIGFuZCBpbmRleCBpcyBvdXQgb2YgYm91bmRzLCBpdCB3aWxsIGJlIGN1dCB0byB0aGUgbmVhcmVzdFxuICAgKiBib3VuZC5cbiAgICogQHBhcmFtIGluZGV4IC0gdGFyZ2V0IGluZGV4LlxuICAgKiBAcGFyYW0gZml0IC0gY3V0cyB0aGUgaW5kZXggYXJndW1lbnQgdG8gZml0IHRoZSBib3VuZHMgYFswLCBoaXN0b3J5Lmxlbmd0aCAtIDFdYC5cbiAgICovXG4gIGdvVG8oZSwgdCkge1xuICAgIHRoaXMubmF2aWdhdG9yLmdvVG8oZSwgdCk7XG4gIH1cbiAgLyoqXG4gICAqIEN1cnJlbnQgaGlzdG9yeSBpdGVtIGhhc2guXG4gICAqIEBzZWUgVVJMLmhhc2hcbiAgICogQGV4YW1wbGVcbiAgICogXCJcIiwgXCIjbXktaGFzaFwiXG4gICAqL1xuICBnZXQgaGFzaCgpIHtcbiAgICByZXR1cm4gKHRoaXMubmF2aWdhdG9yLmN1cnJlbnQucGFyYW1zIHx8IHt9KS5oYXNoIHx8IFwiXCI7XG4gIH1cbiAgLyoqXG4gICAqIFRydWUgaWYgbmF2aWdhdG9yIGhhcyBpdGVtcyBiZWZvcmUgdGhlIGN1cnJlbnQgaXRlbS5cbiAgICovXG4gIGdldCBoYXNQcmV2KCkge1xuICAgIHJldHVybiB0aGlzLm5hdmlnYXRvci5oYXNQcmV2O1xuICB9XG4gIC8qKlxuICAgKiBUcnVlIGlmIG5hdmlnYXRvciBoYXMgaXRlbXMgYWZ0ZXIgdGhlIGN1cnJlbnQgaXRlbS5cbiAgICovXG4gIGdldCBoYXNOZXh0KCkge1xuICAgIHJldHVybiB0aGlzLm5hdmlnYXRvci5oYXNOZXh0O1xuICB9XG4gIC8qKlxuICAgKiBOYXZpZ2F0aW9uIGhpc3RvcnkuXG4gICAqL1xuICBnZXQgaGlzdG9yeSgpIHtcbiAgICByZXR1cm4gdGhpcy5uYXZpZ2F0b3IuaGlzdG9yeS5tYXAoJCk7XG4gIH1cbiAgLyoqXG4gICAqIFBhdGgsIGluY2x1ZGluZyBwYXRobmFtZSwgc2VhcmNoIGFuZCBoYXNoLlxuICAgKiBAZXhhbXBsZSBQYXRobmFtZSBvbmx5LlxuICAgKiBcIi9wYXRobmFtZVwiXG4gICAqIEBleGFtcGxlIFBhdGhuYW1lICsgc2VhcmNoLlxuICAgKiBcIi9wYXRobmFtZT9zZWFyY2hcIlxuICAgKiBAZXhhbXBsZSBQYXRobmFtZSArIGhhc2guXG4gICAqIFwiL3BhdGhuYW1lI2hhc2hcIlxuICAgKiBAZXhhbXBsZSBQYXRobmFtZSArIHNlYXJjaCArIGhhc2guXG4gICAqIFwiL3BhdGhuYW1lP3NlYXJjaCNoYXNoXCJcbiAgICovXG4gIGdldCBwYXRoKCkge1xuICAgIHJldHVybiBOKHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBDdXJyZW50IHBhdGhuYW1lLiBBbHdheXMgc3RhcnRzIHdpdGggdGhlIHNsYXNoLlxuICAgKiBAc2VlIFVSTC5wYXRobmFtZVxuICAgKiBAZXhhbXBsZVxuICAgKiBcIi9cIiwgXCIvYWJjXCJcbiAgICovXG4gIGdldCBwYXRobmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5uYXZpZ2F0b3IuY3VycmVudC5wYXRobmFtZTtcbiAgfVxuICAvKipcbiAgICogRGVwZW5kaW5nIG9uIHRoZSBjdXJyZW50IG5hdmlnYXRpb24gdHlwZSwgcGFyc2VzIGluY29taW5nIHBhdGggYW5kIHJldHVybnMgaXQgcHJlc2VudGVkIGFzXG4gICAqIGFuIG9iamVjdC4gSW4gb3RoZXIgd29yZHMsIHRoaXMgbWV0aG9kIHBhcnNlcyB0aGUgcGFzc2VkIHBhdGggYW5kIHJldHVybnMgb2JqZWN0LCBkZXNjcmliaW5nXG4gICAqIGhvdyB0aGUgbmF2aWdhdG9yIFwic2Vlc1wiIGl0LlxuICAgKlxuICAgKiBAZXhhbXBsZSBIYXNoIG1vZGUgaXMgb21pdHRlZC5cbiAgICogcGFyc2VQYXRoKCcvYWJjP2E9MSNoYXNoJyk7XG4gICAqIC8vIHsgcGF0aG5hbWU6ICcvYWJjJywgc2VhcmNoOiAnP2E9MScsIGhhc2g6ICcjaGFzaCcgfVxuICAgKiBwYXJzZVBhdGgoJ2h0dHA6Ly9leGFtcGxlLmNvbS9hYmM/YT0xI2hhc2gnKTtcbiAgICogLy8geyBwYXRobmFtZTogJy9hYmMnLCBzZWFyY2g6ICc/YT0xJywgaGFzaDogJyNoYXNoJyB9XG4gICAqXG4gICAqIEBleGFtcGxlIEhhc2ggbW9kZSBpcyBlbmFibGVkLlxuICAgKiBwYXJzZVBhdGgoJy9hYmM/YT0xI3RtYT9pcz1jb29sI3llYWgnKTtcbiAgICogLy8geyBwYXRobmFtZTogJy90bWEnLCBzZWFyY2g6ICc/aXM9Y29vbCcsIGhhc2g6ICcjeWVhaCcgfVxuICAgKiBwYXJzZVBhdGgoJ2h0dHA6Ly9leGFtcGxlLmNvbS9hYmM/YT0xI3RtYT9pcz1jb29sI3llYWgnKTtcbiAgICogLy8geyBwYXRobmFtZTogJy90bWEnLCBzZWFyY2g6ICc/aXM9Y29vbCcsIGhhc2g6ICcjeWVhaCcgfVxuICAgKi9cbiAgcGFyc2VQYXRoKGUpIHtcbiAgICBsZXQgdCA9IHEoZSk7XG4gICAgcmV0dXJuIHRoaXMuaGFzaE1vZGUgJiYgKHQgPSBxKHQuaGFzaC5zbGljZSgxKSkpLCB7XG4gICAgICBwYXRobmFtZTogdC5wYXRobmFtZSxcbiAgICAgIHNlYXJjaDogdC5zZWFyY2gsXG4gICAgICBoYXNoOiB0Lmhhc2hcbiAgICB9O1xuICB9XG4gIHB1c2goZSwgdCkge1xuICAgIGNvbnN0IG4gPSBXKGUsIHRoaXMucGF0aCksIHsgc3RhdGU6IHIgPSB0IH0gPSBuLnBhcmFtcztcbiAgICB0aGlzLm5hdmlnYXRvci5wdXNoKHsgLi4ubiwgcGFyYW1zOiB7IC4uLm4ucGFyYW1zLCBzdGF0ZTogciB9IH0pO1xuICB9XG4gIHJlcGxhY2UoZSwgdCkge1xuICAgIGNvbnN0IG4gPSBXKGUsIHRoaXMucGF0aCksIHsgc3RhdGU6IHIgPSB0IH0gPSBuLnBhcmFtcztcbiAgICB0aGlzLm5hdmlnYXRvci5yZXBsYWNlKHsgLi4ubiwgcGFyYW1zOiB7IC4uLm4ucGFyYW1zLCBzdGF0ZTogciB9IH0pO1xuICB9XG4gIC8qKlxuICAgKiBDb21iaW5lcyB0aGUgbmF2aWdhdG9yIGBiYXNlYCBwcm9wZXJ0eSB3aXRoIHRoZSBwYXNzZWQgcGF0aCBkYXRhIGFwcGx5aW5nIHRoZSBuYXZpZ2F0b3JcbiAgICogbmF2aWdhdGlvbiBtb2RlLlxuICAgKiBAcGFyYW0gdmFsdWUgLSBwYXRoIHByZXNlbnRlZCBhcyBzdHJpbmcgb3IgVVJMTGlrZS5cbiAgICovXG4gIHJlbmRlclBhdGgoZSkge1xuICAgIGNvbnN0IHQgPSAodGhpcy5iYXNlLmxlbmd0aCA9PT0gMSA/IFwiXCIgOiB0aGlzLmJhc2UpICsgSShOKGUpLCBcIi9cIik7XG4gICAgcmV0dXJuIHRoaXMuaGFzaE1vZGUgPyBJKHQuc2xpY2UoMSksIHRoaXMuaGFzaE1vZGUgPT09IFwiY2xhc3NpY1wiID8gXCIjXCIgOiBcIiMvXCIpIDogdDtcbiAgfVxuICAvKipcbiAgICogU3luY2hyb25pemVzIGN1cnJlbnQgbmF2aWdhdG9yIHN0YXRlIHdpdGggYnJvd3NlciBoaXN0b3J5LlxuICAgKi9cbiAgYXN5bmMgc3luY0hpc3RvcnkoKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb3BzdGF0ZVwiLCB0aGlzLm9uUG9wU3RhdGUpO1xuICAgIGNvbnN0IHsgc3RhdGU6IGUgfSA9IHRoaXMsIHQgPSB0aGlzLnJlbmRlclBhdGgodGhpcyk7XG4gICAgYXdhaXQgSnQoKSwgdGhpcy5oYXNQcmV2ICYmIHRoaXMuaGFzTmV4dCA/ICh3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoVSwgXCJcIiksIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZShlLCBcIlwiLCB0KSwgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKEgsIFwiXCIpLCBhd2FpdCBUKC0xKSkgOiB0aGlzLmhhc1ByZXYgPyAod2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKFUsIFwiXCIpLCB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoZSwgXCJcIiwgdCkpIDogdGhpcy5oYXNOZXh0ID8gKHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZShlLCB0KSwgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKEgsIFwiXCIpLCBhd2FpdCBUKC0xKSkgOiAod2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKGllLCBcIlwiKSwgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKGUsIFwiXCIsIHQpKSwgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb3BzdGF0ZVwiLCB0aGlzLm9uUG9wU3RhdGUpO1xuICB9XG4gIC8qKlxuICAgKiBDdXJyZW50IHF1ZXJ5IHBhcmFtZXRlcnMuXG4gICAqIEBzZWUgVVJMLnNlYXJjaFxuICAgKiBAZXhhbXBsZVxuICAgKiBcIlwiLCBcIj9cIiwgXCI/YT0xXCJcbiAgICovXG4gIGdldCBzZWFyY2goKSB7XG4gICAgcmV0dXJuICh0aGlzLm5hdmlnYXRvci5jdXJyZW50LnBhcmFtcyB8fCB7fSkuc2VhcmNoIHx8IFwiXCI7XG4gIH1cbiAgLyoqXG4gICAqIEN1cnJlbnQgaGlzdG9yeSBpdGVtIHN0YXRlLlxuICAgKi9cbiAgZ2V0IHN0YXRlKCkge1xuICAgIHJldHVybiAodGhpcy5uYXZpZ2F0b3IuY3VycmVudC5wYXJhbXMgfHwge30pLnN0YXRlO1xuICB9XG59XG5mdW5jdGlvbiBRdChzKSB7XG4gIHMgfHwgKHMgPSB7fSk7XG4gIGNvbnN0IHsgaHJlZjogZSwgaGFzaDogdCB9ID0gd2luZG93LmxvY2F0aW9uO1xuICBsZXQgbiA9IE4oXG4gICAgcy5oYXNoTW9kZSA9PT0gbnVsbCA/IGUgOiB0LmluY2x1ZGVzKFwiP1wiKSA/IHQuc2xpY2UoMSkgOiBgPyR7dC5zbGljZSgxKX1gXG4gICk7XG4gIGNvbnN0IHIgPSBzLmJhc2UgPyBCZShzLmJhc2UpIDogdm9pZCAwO1xuICBpZiAocikge1xuICAgIGlmICghbi5zdGFydHNXaXRoKHIpKVxuICAgICAgdGhyb3cgZihcbiAgICAgICAgWGUsXG4gICAgICAgIGBQYXRoIFwiJHtufVwiIGV4cGVjdGVkIHRvIGJlIHN0YXJ0aW5nIHdpdGggXCIke3J9XCJgXG4gICAgICApO1xuICAgIG4gPSBuLnNsaWNlKHIubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gbmV3IExlKFtuXSwgMCwgcyk7XG59XG5mdW5jdGlvbiBBcyhzKSB7XG4gIGNvbnN0IGUgPSBzLm1hdGNoKC8jKC4rKS8pO1xuICByZXR1cm4gZSA/IGVbMV0gOiBudWxsO1xufVxuZnVuY3Rpb24gWXQocywgZSkge1xuICBpZiAoa2UoKSkge1xuICAgIGNvbnN0IHQgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKHMpO1xuICAgIGlmICh0KVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyBpbmRleDogbiwgaGlzdG9yeTogciB9ID0gSlNPTi5wYXJzZSh0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBMZShcbiAgICAgICAgICByLFxuICAgICAgICAgIG4sXG4gICAgICAgICAgZVxuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAobikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiVW5hYmxlIHRvIHJlc3RvcmUgaGFzaCBuYXZpZ2F0b3Igc3RhdGUuXCIsIG4pO1xuICAgICAgfVxuICB9XG4gIHJldHVybiBRdChlKTtcbn1cbmZ1bmN0aW9uIElzKHMsIGUpIHtcbiAgY29uc3QgdCA9IFl0KHMsIGUpLCBuID0gKCkgPT4gc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShzLCBKU09OLnN0cmluZ2lmeSh7XG4gICAgaW5kZXg6IHQuaW5kZXgsXG4gICAgaGlzdG9yeTogdC5oaXN0b3J5XG4gIH0pKTtcbiAgcmV0dXJuIHQub24oXCJjaGFuZ2VcIiwgbiksIG4oKSwgdDtcbn1cbmV4cG9ydCB7XG4gIGx0IGFzIEJhY2tCdXR0b24sXG4gIEZ0IGFzIEJhc2ljTmF2aWdhdG9yLFxuICBQdCBhcyBCaW9tZXRyeU1hbmFnZXIsXG4gIExlIGFzIEJyb3dzZXJOYXZpZ2F0b3IsXG4gIEN0IGFzIENsb3NpbmdCZWhhdmlvcixcbiAgSXQgYXMgQ2xvdWRTdG9yYWdlLFxuICBYZSBhcyBFUlJfSU5WQUxJRF9QQVRIX0JBU0UsXG4gIEplIGFzIEVSUl9JTlZPS0VfQ1VTVE9NX01FVEhPRF9SRVNQT05TRSxcbiAgemUgYXMgRVJSX01FVEhPRF9QQVJBTUVURVJfVU5TVVBQT1JURUQsXG4gIGplIGFzIEVSUl9NRVRIT0RfVU5TVVBQT1JURUQsXG4gIFplIGFzIEVSUl9OQVZJR0FUSU9OX0hJU1RPUllfRU1QVFksXG4gIEtlIGFzIEVSUl9OQVZJR0FUSU9OX0lOREVYX0lOVkFMSUQsXG4gIFh0IGFzIEVSUl9OQVZJR0FUSU9OX0lURU1fSU5WQUxJRCxcbiAgY2UgYXMgRVJSX1BBUlNFLFxuICBlcyBhcyBFUlJfU1NSX0lOSVQsXG4gIFFlIGFzIEVSUl9USU1FRF9PVVQsXG4gIFllIGFzIEVSUl9VTkVYUEVDVEVEX1RZUEUsXG4gIEZlIGFzIEVSUl9VTktOT1dOX0VOVixcbiAgUiBhcyBFdmVudEVtaXR0ZXIsXG4gIHF0IGFzIEhhcHRpY0ZlZWRiYWNrLFxuICBrdCBhcyBJbml0RGF0YSxcbiAgTnQgYXMgSW52b2ljZSxcbiAgVnQgYXMgTWFpbkJ1dHRvbixcbiAgQnQgYXMgTWluaUFwcCxcbiAgJHQgYXMgUG9wdXAsXG4gIFd0IGFzIFFSU2Nhbm5lcixcbiAgViBhcyBTREtFcnJvcixcbiAgVXQgYXMgU2V0dGluZ3NCdXR0b24sXG4gIEh0IGFzIFN3aXBlQmVoYXZpb3IsXG4gIE90IGFzIFRoZW1lUGFyYW1zLFxuICBHdCBhcyBVdGlscyxcbiAganQgYXMgVmlld3BvcnQsXG4gIEF0IGFzIGFycmF5LFxuICB2cyBhcyBiaW5kTWluaUFwcENTU1ZhcnMsXG4gIEVzIGFzIGJpbmRUaGVtZVBhcmFtc0NTU1ZhcnMsXG4gIFNzIGFzIGJpbmRWaWV3cG9ydENTU1ZhcnMsXG4gIGIgYXMgYm9vbGVhbixcbiAgZ2UgYXMgY2FwdHVyZVNhbWVSZXEsXG4gIHogYXMgY2xhc3NOYW1lcyxcbiAgb3QgYXMgY29tcGFyZVZlcnNpb25zLFxuICBRdCBhcyBjcmVhdGVCcm93c2VyTmF2aWdhdG9yRnJvbUxvY2F0aW9uLFxuICBwdCBhcyBjcmVhdGVQb3N0RXZlbnQsXG4gIHEgYXMgY3JlYXRlU2FmZVVSTCxcbiAgRWUgYXMgZGF0ZSxcbiAgQXMgYXMgZ2V0SGFzaCxcbiAgQmUgYXMgZ2V0UGF0aG5hbWUsXG4gIG5zIGFzIGluaXRCYWNrQnV0dG9uLFxuICBycyBhcyBpbml0QmlvbWV0cnlNYW5hZ2VyLFxuICBpcyBhcyBpbml0Q2xvc2luZ0JlaGF2aW9yLFxuICBvcyBhcyBpbml0Q2xvdWRTdG9yYWdlLFxuICBhcyBhcyBpbml0SGFwdGljRmVlZGJhY2ssXG4gIGNzIGFzIGluaXRJbml0RGF0YSxcbiAgaHMgYXMgaW5pdEludm9pY2UsXG4gIHVzIGFzIGluaXRNYWluQnV0dG9uLFxuICBscyBhcyBpbml0TWluaUFwcCxcbiAgSXMgYXMgaW5pdE5hdmlnYXRvcixcbiAgZHMgYXMgaW5pdFBvcHVwLFxuICBfcyBhcyBpbml0UVJTY2FubmVyLFxuICBmcyBhcyBpbml0U2V0dGluZ3NCdXR0b24sXG4gIGdzIGFzIGluaXRTd2lwZUJlaGF2aW9yLFxuICB3cyBhcyBpbml0VGhlbWVQYXJhbXMsXG4gIG1zIGFzIGluaXRVdGlscyxcbiAgeXMgYXMgaW5pdFZpZXdwb3J0LFxuICBQcyBhcyBpbml0V2ViLFxuICBDIGFzIGludm9rZUN1c3RvbU1ldGhvZCxcbiAgeWUgYXMgaXNDb2xvckRhcmssXG4gIF9lIGFzIGlzSWZyYW1lLFxuICBrZSBhcyBpc1BhZ2VSZWxvYWQsXG4gIFEgYXMgaXNSR0IsXG4gIGh0IGFzIGlzUkdCU2hvcnQsXG4gIHp0IGFzIGlzU0RLRXJyb3IsXG4gIFJzIGFzIGlzU0RLRXJyb3JPZlR5cGUsXG4gIHhzIGFzIGlzU1NSLFxuICBDcyBhcyBpc1RNQSxcbiAgZyBhcyBqc29uLFxuICBzcyBhcyBtZXJnZUNsYXNzTmFtZXMsXG4gIFRzIGFzIG1vY2tUZWxlZ3JhbUVudixcbiAgeSBhcyBudW1iZXIsXG4gIEIgYXMgb2ZmLFxuICB3IGFzIG9uLFxuICBwcyBhcyBwYXJzZUluaXREYXRhLFxuICBYIGFzIHBhcnNlTGF1bmNoUGFyYW1zLFxuICBEZSBhcyBwYXJzZVRoZW1lUGFyYW1zLFxuICBBIGFzIHBvc3RFdmVudCxcbiAgZCBhcyByZXF1ZXN0LFxuICB4dCBhcyByZXF1ZXN0QmlvbWV0cnlJbmZvLFxuICBicyBhcyByZXF1ZXN0VGhlbWVQYXJhbXMsXG4gIE1lIGFzIHJlcXVlc3RWaWV3cG9ydCxcbiAgdnQgYXMgcmV0cmlldmVMYXVuY2hQYXJhbXMsXG4gIF90IGFzIHJnYixcbiAgSyBhcyBzZWFyY2hQYXJhbXMsXG4gIHl0IGFzIHNlcmlhbGl6ZUxhdW5jaFBhcmFtcyxcbiAgSWUgYXMgc2VyaWFsaXplVGhlbWVQYXJhbXMsXG4gIG0gYXMgc2V0Q1NTVmFyLFxuICBLdCBhcyBzZXREZWJ1ZyxcbiAgdHMgYXMgc2V0VGFyZ2V0T3JpZ2luLFxuICBoIGFzIHN0cmluZyxcbiAgSGUgYXMgc3Vic2NyaWJlLFxuICB2IGFzIHN1cHBvcnRzLFxuICBjdCBhcyB0YXJnZXRPcmlnaW4sXG4gIG1lIGFzIHRvUkdCLFxuICBhZSBhcyB1bnN1YnNjcmliZSxcbiAgTiBhcyB1cmxUb1BhdGgsXG4gIGJlIGFzIHdpdGhUaW1lb3V0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@telegram-apps/sdk/dist/index.js\n");

/***/ })

};
;